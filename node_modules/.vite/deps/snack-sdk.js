import {
  require_assert
} from "./chunk-UVZPA7W3.js";
import "./chunk-SNVPYF72.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-EWTE5DHJ.js";

// node_modules/snack-content/build/defaults.js
var require_defaults = __commonJS({
  "node_modules/snack-content/build/defaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.newestSdkVersion = exports.oldestSdkVersion = exports.defaultSdkVersion = void 0;
    exports.defaultSdkVersion = "51.0.0";
    exports.oldestSdkVersion = "50.0.0";
    exports.newestSdkVersion = "52.0.0";
  }
});

// node_modules/snack-content/node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/snack-content/node_modules/semver/internal/constants.js"(exports, module) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/snack-content/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/snack-content/node_modules/semver/internal/debug.js"(exports, module) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});

// node_modules/snack-content/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/snack-content/node_modules/semver/internal/re.js"(exports, module) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug = require_debug();
    exports = module.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var safeSrc = exports.safeSrc = [];
    var t = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/snack-content/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/snack-content/node_modules/semver/internal/parse-options.js"(exports, module) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// node_modules/snack-content/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/snack-content/node_modules/semver/internal/identifiers.js"(exports, module) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/snack-content/node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/snack-content/node_modules/semver/classes/semver.js"(exports, module) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, safeSrc: src, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const r = new RegExp(`^${this.options.loose ? src[t.PRERELEASELOOSE] : src[t.PRERELEASE]}$`);
            const match = `-${identifier}`.match(r);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// node_modules/snack-content/node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/parse.js"(exports, module) {
    var SemVer = require_semver();
    var parse = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module.exports = parse;
  }
});

// node_modules/snack-content/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/valid.js"(exports, module) {
    var parse = require_parse();
    var valid = (version, options) => {
      const v = parse(version, options);
      return v ? v.version : null;
    };
    module.exports = valid;
  }
});

// node_modules/snack-content/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/clean.js"(exports, module) {
    var parse = require_parse();
    var clean = (version, options) => {
      const s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module.exports = clean;
  }
});

// node_modules/snack-content/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/inc.js"(exports, module) {
    var SemVer = require_semver();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module.exports = inc;
  }
});

// node_modules/snack-content/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/diff.js"(exports, module) {
    var parse = require_parse();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module.exports = diff;
  }
});

// node_modules/snack-content/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/major.js"(exports, module) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module.exports = major;
  }
});

// node_modules/snack-content/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/minor.js"(exports, module) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module.exports = minor;
  }
});

// node_modules/snack-content/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/patch.js"(exports, module) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module.exports = patch;
  }
});

// node_modules/snack-content/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/prerelease.js"(exports, module) {
    var parse = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  }
});

// node_modules/snack-content/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/compare.js"(exports, module) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module.exports = compare;
  }
});

// node_modules/snack-content/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/rcompare.js"(exports, module) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module.exports = rcompare;
  }
});

// node_modules/snack-content/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/compare-loose.js"(exports, module) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module.exports = compareLoose;
  }
});

// node_modules/snack-content/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/compare-build.js"(exports, module) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  }
});

// node_modules/snack-content/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/sort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module.exports = sort;
  }
});

// node_modules/snack-content/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/rsort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module.exports = rsort;
  }
});

// node_modules/snack-content/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/gt.js"(exports, module) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module.exports = gt;
  }
});

// node_modules/snack-content/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/lt.js"(exports, module) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module.exports = lt;
  }
});

// node_modules/snack-content/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/eq.js"(exports, module) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module.exports = eq;
  }
});

// node_modules/snack-content/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/neq.js"(exports, module) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module.exports = neq;
  }
});

// node_modules/snack-content/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/gte.js"(exports, module) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module.exports = gte;
  }
});

// node_modules/snack-content/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/lte.js"(exports, module) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module.exports = lte;
  }
});

// node_modules/snack-content/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/cmp.js"(exports, module) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// node_modules/snack-content/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/coerce.js"(exports, module) {
    var SemVer = require_semver();
    var parse = require_parse();
    var { safeRe: re, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module.exports = coerce;
  }
});

// node_modules/snack-content/node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/snack-content/node_modules/semver/internal/lrucache.js"(exports, module) {
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});

// node_modules/snack-content/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/snack-content/node_modules/semver/classes/range.js"(exports, module) {
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/snack-content/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/snack-content/node_modules/semver/classes/comparator.js"(exports, module) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/snack-content/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/snack-content/node_modules/semver/functions/satisfies.js"(exports, module) {
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module.exports = satisfies;
  }
});

// node_modules/snack-content/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/snack-content/node_modules/semver/ranges/to-comparators.js"(exports, module) {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module.exports = toComparators;
  }
});

// node_modules/snack-content/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/snack-content/node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module.exports = maxSatisfying;
  }
});

// node_modules/snack-content/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/snack-content/node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module.exports = minSatisfying;
  }
});

// node_modules/snack-content/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/snack-content/node_modules/semver/ranges/min-version.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  }
});

// node_modules/snack-content/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/snack-content/node_modules/semver/ranges/valid.js"(exports, module) {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module.exports = validRange;
  }
});

// node_modules/snack-content/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/snack-content/node_modules/semver/ranges/outside.js"(exports, module) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  }
});

// node_modules/snack-content/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/snack-content/node_modules/semver/ranges/gtr.js"(exports, module) {
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module.exports = gtr;
  }
});

// node_modules/snack-content/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/snack-content/node_modules/semver/ranges/ltr.js"(exports, module) {
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module.exports = ltr;
  }
});

// node_modules/snack-content/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/snack-content/node_modules/semver/ranges/intersects.js"(exports, module) {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module.exports = intersects;
  }
});

// node_modules/snack-content/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/snack-content/node_modules/semver/ranges/simplify.js"(exports, module) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/snack-content/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/snack-content/node_modules/semver/ranges/subset.js"(exports, module) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module.exports = subset;
  }
});

// node_modules/snack-content/node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/snack-content/node_modules/semver/index.js"(exports, module) {
    var internalRe = require_re();
    var constants = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/snack-content/build/sdks/index.js
var require_sdks = __commonJS({
  "node_modules/snack-content/build/sdks/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var assets = {
      // @expo/snack-static/react-native-logo.png is an alias that is
      // implemented in the runtime, and uses by the react-native image docs
      "@expo/snack-static/react-native-logo.png": "*"
    };
    var sdks = {
      // TODO(cedric): drop SDK 48
      "48.0.0": {
        version: "^48.0.0",
        coreModules: {
          ...assets,
          expo: "~48.0.17",
          react: "18.2.0",
          "react-dom": "*",
          "react-native": "0.71.8",
          "react-native-web": "*",
          // Used by @shopify/react-native-skia, on web only
          // See runtime/src/NativeModules/ReactNativeSkia.tsx for more info
          "@shopify/react-native-skia/lib/module/web": "*"
        },
        bundledModules: {
          "expo-asset": "*",
          "expo-font": "*",
          "react-native-gesture-handler": "*",
          "react-native-safe-area-context": "*",
          "@expo/vector-icons": "*",
          "expo-constants": "*",
          "expo-file-system": "*",
          "expo-updates": "*",
          "@react-native-async-storage/async-storage": "*",
          "react-native-reanimated": "*",
          "expo-router": "*",
          "expo-router/stack": "*",
          "expo-router/tabs": "*",
          "expo-router/drawer": "*",
          "expo-router/html": "*",
          "expo-router/head": "*",
          "expo-router/entry": "*",
          "react-native-pager-view": "*"
        },
        deprecatedModules: {}
      },
      "49.0.0": {
        version: "^49.0.0",
        coreModules: {
          ...assets,
          expo: "~49.0.10",
          react: "18.2.0",
          "react-dom": "*",
          "react-native": "0.72.4",
          "react-native-web": "*",
          // Used by @shopify/react-native-skia, on web only
          // See runtime/src/NativeModules/ReactNativeSkia.tsx for more info
          "@shopify/react-native-skia/lib/module/web": "*"
        },
        bundledModules: {
          "expo-asset": "*",
          "expo-font": "*",
          "react-native-gesture-handler": "*",
          "react-native-safe-area-context": "*",
          "@expo/vector-icons": "*",
          "expo-constants": "*",
          "expo-file-system": "*",
          "expo-updates": "*",
          "@react-native-async-storage/async-storage": "*",
          "react-native-reanimated": "*",
          "expo-router": "*",
          "expo-router/stack": "*",
          "expo-router/tabs": "*",
          "expo-router/drawer": "*",
          "expo-router/html": "*",
          "expo-router/head": "*",
          "expo-router/entry": "*",
          "react-native-pager-view": "*"
        },
        deprecatedModules: {}
      },
      "50.0.0": {
        version: "^50.0.0",
        coreModules: {
          ...assets,
          expo: "~50.0.17",
          react: "18.2.0",
          "react-dom": "*",
          "react-native": "0.73.6",
          "react-native-web": "*",
          // Used by @shopify/react-native-skia, on web only
          // See runtime/src/NativeModules/ReactNativeSkia.tsx for more info
          "@shopify/react-native-skia/lib/module/web": "*"
        },
        bundledModules: {
          "expo-asset": "*",
          "expo-font": "*",
          "react-native-gesture-handler": "*",
          "react-native-safe-area-context": "*",
          "@expo/vector-icons": "*",
          "expo-constants": "*",
          "expo-file-system": "*",
          "expo-updates": "*",
          "expo-modules-core": "*",
          "@react-native-async-storage/async-storage": "*",
          "react-native-reanimated": "*",
          "expo-router": "*",
          "expo-router/stack": "*",
          "expo-router/tabs": "*",
          "expo-router/drawer": "*",
          "expo-router/html": "*",
          "expo-router/head": "*",
          "expo-router/entry": "*",
          "react-native-pager-view": "*"
        },
        deprecatedModules: {}
      },
      "51.0.0": {
        version: "^51.0.0",
        coreModules: {
          ...assets,
          expo: "~51.0.31",
          react: "18.2.0",
          "react-dom": "*",
          "react-native": "0.74.5",
          "react-native-web": "*",
          // Used by @shopify/react-native-skia, on web only
          // See runtime/src/NativeModules/ReactNativeSkia.tsx for more info
          "@shopify/react-native-skia/lib/module/web": "*"
        },
        bundledModules: {
          "expo-asset": "*",
          "expo-font": "*",
          "react-native-gesture-handler": "*",
          "react-native-safe-area-context": "*",
          "@expo/vector-icons": "*",
          "expo-constants": "*",
          "expo-file-system": "*",
          "expo-updates": "*",
          "@react-native-async-storage/async-storage": "*",
          "react-native-reanimated": "*",
          "expo-router": "*",
          "expo-router/stack": "*",
          "expo-router/tabs": "*",
          "expo-router/drawer": "*",
          "expo-router/html": "*",
          "expo-router/head": "*",
          "expo-router/entry": "*",
          "react-native-pager-view": "*"
        },
        deprecatedModules: {}
      },
      "52.0.0": {
        version: "^52.0.0",
        coreModules: {
          ...assets,
          expo: "~52.0.2",
          react: "18.3.1",
          "react-dom": "18.3.1",
          "react-native": "0.76.3",
          "react-native-web": "*",
          // Used by @shopify/react-native-skia, on web only
          // See runtime/src/NativeModules/ReactNativeSkia.tsx for more info
          "@shopify/react-native-skia/lib/module/web": "*"
        },
        bundledModules: {
          "expo-asset": "*",
          "expo-font": "*",
          "react-native-gesture-handler": "*",
          "react-native-safe-area-context": "*",
          "@expo/vector-icons": "*",
          "expo-constants": "*",
          "expo-file-system": "*",
          "expo-updates": "*",
          "@react-native-async-storage/async-storage": "*",
          "react-native-reanimated": "*",
          "expo-router": "*",
          "expo-router/stack": "*",
          "expo-router/tabs": "*",
          "expo-router/drawer": "*",
          "expo-router/html": "*",
          "expo-router/head": "*",
          "expo-router/entry": "*",
          "react-native-pager-view": "*"
        },
        deprecatedModules: {}
      }
    };
    exports.default = sdks;
  }
});

// node_modules/snack-content/build/sdks/features.js
var require_features = __commonJS({
  "node_modules/snack-content/build/sdks/features.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var features = {
      MULTIPLE_FILES: "21.0.0",
      PROJECT_DEPENDENCIES: "25.0.0",
      TYPESCRIPT: "31.0.0",
      UNIMODULE_IMPORTS: "33.0.0",
      POSTMESSAGE_TRANSPORT: "35.0.0",
      VERSIONED_SNACKAGER: "37.0.0"
    };
    exports.default = features;
  }
});

// node_modules/snack-content/build/sdk.js
var require_sdk = __commonJS({
  "node_modules/snack-content/build/sdk.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.standardizeDependencies = exports.isFeatureSupported = exports.isValidSemver = exports.getSupportedSDKVersions = exports.getDeprecatedModule = exports.validateSDKVersion = exports.getPreloadedModules = exports.isModulePreloaded = void 0;
    var semver_1 = __importDefault(require_semver2());
    var sdks_1 = __importDefault(require_sdks());
    var features_1 = __importDefault(require_features());
    function isModulePreloaded(name, sdkVersion, coreModulesOnly) {
      const sdk = sdks_1.default[sdkVersion];
      if (!sdk)
        return false;
      return !!(sdk.coreModules[name] || !coreModulesOnly && sdk.bundledModules[name]);
    }
    exports.isModulePreloaded = isModulePreloaded;
    function getPreloadedModules(sdkVersion, coreModulesOnly) {
      const sdk = sdks_1.default[sdkVersion];
      if (!sdk)
        return {};
      return coreModulesOnly ? sdk.coreModules : {
        ...sdk.coreModules,
        ...sdk.bundledModules
      };
    }
    exports.getPreloadedModules = getPreloadedModules;
    function validateSDKVersion(sdkVersion) {
      if (Object.keys(sdks_1.default).indexOf(sdkVersion) < 0) {
        throw new Error(`Invalid SDKVersion, the following versions are supported: ${Object.keys(sdks_1.default)}`);
      }
      return sdkVersion;
    }
    exports.validateSDKVersion = validateSDKVersion;
    function getDeprecatedModule(name, sdkVersion) {
      var _a, _b;
      return (_b = (_a = sdks_1.default[sdkVersion]) === null || _a === void 0 ? void 0 : _a.deprecatedModules) === null || _b === void 0 ? void 0 : _b[name];
    }
    exports.getDeprecatedModule = getDeprecatedModule;
    function getSupportedSDKVersions() {
      return Object.keys(sdks_1.default);
    }
    exports.getSupportedSDKVersions = getSupportedSDKVersions;
    function isValidSemver(version) {
      return version === "latest" || !!semver_1.default.validRange(version);
    }
    exports.isValidSemver = isValidSemver;
    function isFeatureSupported(feature, sdkVersion) {
      const featureVersion = features_1.default[feature];
      if (!featureVersion) {
        throw new Error(`Invalid SDKFeature, the following versions are supported: ${Object.keys(features_1.default)}`);
      }
      return semver_1.default.gte(sdkVersion, featureVersion);
    }
    exports.isFeatureSupported = isFeatureSupported;
    function standardizeDependencies(dependencies) {
      let result = dependencies;
      for (const name in dependencies) {
        const dep = dependencies[name];
        if (typeof dep === "string") {
          result = result === dependencies ? { ...dependencies } : result;
          result[name] = {
            version: dep
          };
        } else if (typeof dep === "object") {
          const peerDependencies = standardizePeerDependencies(dep.peerDependencies);
          if (dep.peerDependencies !== peerDependencies) {
            result = result === dependencies ? { ...dependencies } : result;
            result[name] = {
              ...dep,
              peerDependencies
            };
          }
        } else {
          result = result === dependencies ? { ...dependencies } : result;
          delete result[name];
        }
      }
      return result;
    }
    exports.standardizeDependencies = standardizeDependencies;
    function standardizePeerDependencies(peerDependencies) {
      if (!peerDependencies) {
        return peerDependencies;
      }
      let result = peerDependencies;
      for (const name in peerDependencies) {
        const peerDep = peerDependencies[name];
        if (typeof peerDep === "string" || peerDep === null) {
        } else if (typeof peerDep === "object" && typeof peerDep.version === "string") {
          result = result === peerDependencies ? { ...peerDependencies } : result;
          result[name] = peerDep.version;
        } else {
          result = result === peerDependencies ? { ...peerDependencies } : result;
          delete result[name];
        }
      }
      return result;
    }
  }
});

// node_modules/snack-content/build/types.js
var require_types = __commonJS({
  "node_modules/snack-content/build/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/snack-content/build/urls.js
var require_urls = __commonJS({
  "node_modules/snack-content/build/urls.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseRuntimeUrl = exports.createRuntimeUrl = exports.SNACK_RUNTIME_URL_PROTOCOL = exports.SNACK_RUNTIME_URL_ENDPOINT = void 0;
    exports.SNACK_RUNTIME_URL_ENDPOINT = "u.expo.dev/933fd9c0-1666-11e7-afca-d980795c5824";
    exports.SNACK_RUNTIME_URL_PROTOCOL = "exp";
    function createRuntimeUrl(options) {
      const protocol = options.protocol || exports.SNACK_RUNTIME_URL_PROTOCOL;
      const endpoint = options.endpoint || exports.SNACK_RUNTIME_URL_ENDPOINT;
      const parameters = new URLSearchParams();
      parameters.set("runtime-version", `exposdk:${options.sdkVersion}`);
      parameters.set("channel-name", "production");
      if (options.snack)
        parameters.set("snack", options.snack);
      if (options.channel)
        parameters.set("snack-channel", options.channel);
      return `${protocol}://${endpoint}?${parameters}`;
    }
    exports.createRuntimeUrl = createRuntimeUrl;
    function parseRuntimeUrl(uri) {
      var _a, _b, _c;
      const url = typeof uri === "string" ? (
        // Force non-standard protocols to `http`, avoiding Node-related parsing issues
        new URL(uri.replace(/^[a-zA-Z]+:/, "http:"))
      ) : uri;
      const snack = (_a = url.searchParams.get("snack")) !== null && _a !== void 0 ? _a : void 0;
      const channel = (_b = url.searchParams.get("snack-channel")) !== null && _b !== void 0 ? _b : void 0;
      const runtimeVersion = url.searchParams.get("runtime-version");
      const [, sdkVersion] = (_c = runtimeVersion === null || runtimeVersion === void 0 ? void 0 : runtimeVersion.match(/(?:exposdk:)?([0-9]+\.[0-9]+\.[0-9]+)/)) !== null && _c !== void 0 ? _c : [];
      if (!sdkVersion) {
        return null;
      }
      return {
        sdkVersion,
        snack,
        channel
      };
    }
    exports.parseRuntimeUrl = parseRuntimeUrl;
  }
});

// node_modules/snack-content/build/index.js
var require_build = __commonJS({
  "node_modules/snack-content/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sdks = void 0;
    __exportStar(require_defaults(), exports);
    __exportStar(require_sdk(), exports);
    var sdks_1 = require_sdks();
    Object.defineProperty(exports, "sdks", { enumerable: true, get: function() {
      return __importDefault(sdks_1).default;
    } });
    __exportStar(require_types(), exports);
    __exportStar(require_urls(), exports);
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module) {
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module.exports = isObject;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports, module) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports, module) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports, module) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports, module) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports, module) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module.exports = getValue;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports, module) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module.exports = getNative;
  }
});

// node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/lodash/_defineProperty.js"(exports, module) {
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    module.exports = defineProperty;
  }
});

// node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "node_modules/lodash/_baseAssignValue.js"(exports, module) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    module.exports = baseAssignValue;
  }
});

// node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "node_modules/lodash/_createBaseFor.js"(exports, module) {
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    module.exports = createBaseFor;
  }
});

// node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "node_modules/lodash/_baseFor.js"(exports, module) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module.exports = baseFor;
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports, module) {
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module.exports = baseTimes;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports, module) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module.exports = isArguments;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module) {
    var isArray = Array.isArray;
    module.exports = isArray;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports, module) {
    function stubFalse() {
      return false;
    }
    module.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports, module) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module.exports = isIndex;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module.exports = isLength;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports, module) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports, module) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports, module) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module.exports = isPrototype;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports, module) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module.exports = overArg;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports, module) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports, module) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeys;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports, module) {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module.exports = isArrayLike;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module.exports = keys;
  }
});

// node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "node_modules/lodash/_baseForOwn.js"(exports, module) {
    var baseFor = require_baseFor();
    var keys = require_keys();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    module.exports = baseForOwn;
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports, module) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module.exports = listCacheClear;
  }
});

// node_modules/lodash/eq.js
var require_eq2 = __commonJS({
  "node_modules/lodash/eq.js"(exports, module) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module.exports = eq;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports, module) {
    var eq = require_eq2();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports, module) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
  }
});

// node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/lodash/_stackClear.js"(exports, module) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module.exports = stackClear;
  }
});

// node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/lodash/_stackDelete.js"(exports, module) {
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module.exports = stackDelete;
  }
});

// node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/lodash/_stackGet.js"(exports, module) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module.exports = stackGet;
  }
});

// node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/lodash/_stackHas.js"(exports, module) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module.exports = stackHas;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module.exports = Map2;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports, module) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports, module) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports, module) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module.exports = Hash;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports, module) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports, module) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports, module) {
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports, module) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
  }
});

// node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/lodash/_stackSet.js"(exports, module) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module.exports = stackSet;
  }
});

// node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/lodash/_Stack.js"(exports, module) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module.exports = Stack;
  }
});

// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/lodash/_setCacheAdd.js"(exports, module) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module.exports = setCacheAdd;
  }
});

// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/lodash/_setCacheHas.js"(exports, module) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module.exports = setCacheHas;
  }
});

// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/lodash/_SetCache.js"(exports, module) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module.exports = SetCache;
  }
});

// node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "node_modules/lodash/_arraySome.js"(exports, module) {
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    module.exports = arraySome;
  }
});

// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/lodash/_cacheHas.js"(exports, module) {
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module.exports = cacheHas;
  }
});

// node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "node_modules/lodash/_equalArrays.js"(exports, module) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    module.exports = equalArrays;
  }
});

// node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/lodash/_Uint8Array.js"(exports, module) {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module.exports = Uint8Array2;
  }
});

// node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "node_modules/lodash/_mapToArray.js"(exports, module) {
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    module.exports = mapToArray;
  }
});

// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/lodash/_setToArray.js"(exports, module) {
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module.exports = setToArray;
  }
});

// node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "node_modules/lodash/_equalByTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq2();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module.exports = equalByTag;
  }
});

// node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/lodash/_arrayPush.js"(exports, module) {
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module.exports = arrayPush;
  }
});

// node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module.exports = baseGetAllKeys;
  }
});

// node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/lodash/_arrayFilter.js"(exports, module) {
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module.exports = arrayFilter;
  }
});

// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/lodash/stubArray.js"(exports, module) {
    function stubArray() {
      return [];
    }
    module.exports = stubArray;
  }
});

// node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/lodash/_getSymbols.js"(exports, module) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module.exports = getSymbols;
  }
});

// node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/lodash/_getAllKeys.js"(exports, module) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module.exports = getAllKeys;
  }
});

// node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "node_modules/lodash/_equalObjects.js"(exports, module) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    module.exports = equalObjects;
  }
});

// node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/lodash/_DataView.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView2 = getNative(root, "DataView");
    module.exports = DataView2;
  }
});

// node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/lodash/_Promise.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module.exports = Promise2;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module.exports = Set2;
  }
});

// node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/lodash/_WeakMap.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module.exports = WeakMap2;
  }
});

// node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/lodash/_getTag.js"(exports, module) {
    var DataView2 = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module.exports = getTag;
  }
});

// node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "node_modules/lodash/_baseIsEqualDeep.js"(exports, module) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    module.exports = baseIsEqualDeep;
  }
});

// node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "node_modules/lodash/_baseIsEqual.js"(exports, module) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module.exports = baseIsEqual;
  }
});

// node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "node_modules/lodash/_baseIsMatch.js"(exports, module) {
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module.exports = baseIsMatch;
  }
});

// node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "node_modules/lodash/_isStrictComparable.js"(exports, module) {
    var isObject = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    module.exports = isStrictComparable;
  }
});

// node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "node_modules/lodash/_getMatchData.js"(exports, module) {
    var isStrictComparable = require_isStrictComparable();
    var keys = require_keys();
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    module.exports = getMatchData;
  }
});

// node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "node_modules/lodash/_matchesStrictComparable.js"(exports, module) {
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    module.exports = matchesStrictComparable;
  }
});

// node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "node_modules/lodash/_baseMatches.js"(exports, module) {
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    module.exports = baseMatches;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module.exports = isSymbol;
  }
});

// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/lodash/_isKey.js"(exports, module) {
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module.exports = isKey;
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports, module) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module.exports = memoize;
  }
});

// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/lodash/_memoizeCapped.js"(exports, module) {
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    module.exports = memoizeCapped;
  }
});

// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/lodash/_stringToPath.js"(exports, module) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    module.exports = stringToPath;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports, module) {
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module.exports = arrayMap;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module.exports = baseToString;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports, module) {
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module.exports = toString;
  }
});

// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/lodash/_castPath.js"(exports, module) {
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    module.exports = castPath;
  }
});

// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/lodash/_toKey.js"(exports, module) {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module.exports = toKey;
  }
});

// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/lodash/_baseGet.js"(exports, module) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    module.exports = baseGet;
  }
});

// node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/lodash/get.js"(exports, module) {
    var baseGet = require_baseGet();
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    module.exports = get;
  }
});

// node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "node_modules/lodash/_baseHasIn.js"(exports, module) {
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    module.exports = baseHasIn;
  }
});

// node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "node_modules/lodash/_hasPath.js"(exports, module) {
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);
      var index = -1, length = path.length, result = false;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    module.exports = hasPath;
  }
});

// node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "node_modules/lodash/hasIn.js"(exports, module) {
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    module.exports = hasIn;
  }
});

// node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "node_modules/lodash/_baseMatchesProperty.js"(exports, module) {
    var baseIsEqual = require_baseIsEqual();
    var get = require_get();
    var hasIn = require_hasIn();
    var isKey = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    module.exports = baseMatchesProperty;
  }
});

// node_modules/lodash/identity.js
var require_identity = __commonJS({
  "node_modules/lodash/identity.js"(exports, module) {
    function identity(value) {
      return value;
    }
    module.exports = identity;
  }
});

// node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "node_modules/lodash/_baseProperty.js"(exports, module) {
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    module.exports = baseProperty;
  }
});

// node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "node_modules/lodash/_basePropertyDeep.js"(exports, module) {
    var baseGet = require_baseGet();
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    module.exports = basePropertyDeep;
  }
});

// node_modules/lodash/property.js
var require_property = __commonJS({
  "node_modules/lodash/property.js"(exports, module) {
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey = require_isKey();
    var toKey = require_toKey();
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module.exports = property;
  }
});

// node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "node_modules/lodash/_baseIteratee.js"(exports, module) {
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity = require_identity();
    var isArray = require_isArray();
    var property = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    module.exports = baseIteratee;
  }
});

// node_modules/lodash/mapValues.js
var require_mapValues = __commonJS({
  "node_modules/lodash/mapValues.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var baseForOwn = require_baseForOwn();
    var baseIteratee = require_baseIteratee();
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = baseIteratee(iteratee, 3);
      baseForOwn(object, function(value, key, object2) {
        baseAssignValue(result, key, iteratee(value, key, object2));
      });
      return result;
    }
    module.exports = mapValues;
  }
});

// node_modules/nullthrows/nullthrows.js
var require_nullthrows = __commonJS({
  "node_modules/nullthrows/nullthrows.js"(exports, module) {
    "use strict";
    function nullthrows(x, message) {
      if (x != null) {
        return x;
      }
      var error = new Error(message !== void 0 ? message : "Got unexpected " + x);
      error.framesToPop = 1;
      throw error;
    }
    module.exports = nullthrows;
    module.exports.default = nullthrows;
    Object.defineProperty(module.exports, "__esModule", { value: true });
  }
});

// node_modules/snack-sdk/node_modules/semver/internal/constants.js
var require_constants2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/internal/constants.js"(exports, module) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/snack-sdk/node_modules/semver/internal/debug.js
var require_debug2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/internal/debug.js"(exports, module) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});

// node_modules/snack-sdk/node_modules/semver/internal/re.js
var require_re2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/internal/re.js"(exports, module) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants2();
    var debug = require_debug2();
    exports = module.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var safeSrc = exports.safeSrc = [];
    var t = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/snack-sdk/node_modules/semver/internal/parse-options.js
var require_parse_options2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/internal/parse-options.js"(exports, module) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// node_modules/snack-sdk/node_modules/semver/internal/identifiers.js
var require_identifiers2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/internal/identifiers.js"(exports, module) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/snack-sdk/node_modules/semver/classes/semver.js
var require_semver3 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/classes/semver.js"(exports, module) {
    var debug = require_debug2();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants2();
    var { safeRe: re, safeSrc: src, t } = require_re2();
    var parseOptions = require_parse_options2();
    var { compareIdentifiers } = require_identifiers2();
    var SemVer = class _SemVer {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof _SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const r = new RegExp(`^${this.options.loose ? src[t.PRERELEASELOOSE] : src[t.PRERELEASE]}$`);
            const match = `-${identifier}`.match(r);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/parse.js
var require_parse2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/parse.js"(exports, module) {
    var SemVer = require_semver3();
    var parse = (version, options, throwErrors = false) => {
      if (version instanceof SemVer) {
        return version;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module.exports = parse;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/valid.js
var require_valid3 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/valid.js"(exports, module) {
    var parse = require_parse2();
    var valid = (version, options) => {
      const v = parse(version, options);
      return v ? v.version : null;
    };
    module.exports = valid;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/clean.js
var require_clean2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/clean.js"(exports, module) {
    var parse = require_parse2();
    var clean = (version, options) => {
      const s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module.exports = clean;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/inc.js
var require_inc2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/inc.js"(exports, module) {
    var SemVer = require_semver3();
    var inc = (version, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version instanceof SemVer ? version.version : version,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module.exports = inc;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/diff.js
var require_diff2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/diff.js"(exports, module) {
    var parse = require_parse2();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module.exports = diff;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/major.js
var require_major2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/major.js"(exports, module) {
    var SemVer = require_semver3();
    var major = (a, loose) => new SemVer(a, loose).major;
    module.exports = major;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/minor.js
var require_minor2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/minor.js"(exports, module) {
    var SemVer = require_semver3();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module.exports = minor;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/patch.js
var require_patch2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/patch.js"(exports, module) {
    var SemVer = require_semver3();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module.exports = patch;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/prerelease.js
var require_prerelease2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/prerelease.js"(exports, module) {
    var parse = require_parse2();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/compare.js
var require_compare2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/compare.js"(exports, module) {
    var SemVer = require_semver3();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module.exports = compare;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/rcompare.js
var require_rcompare2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/rcompare.js"(exports, module) {
    var compare = require_compare2();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module.exports = rcompare;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/compare-loose.js
var require_compare_loose2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/compare-loose.js"(exports, module) {
    var compare = require_compare2();
    var compareLoose = (a, b) => compare(a, b, true);
    module.exports = compareLoose;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/compare-build.js
var require_compare_build2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/compare-build.js"(exports, module) {
    var SemVer = require_semver3();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/sort.js
var require_sort2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/sort.js"(exports, module) {
    var compareBuild = require_compare_build2();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module.exports = sort;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/rsort.js
var require_rsort2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/rsort.js"(exports, module) {
    var compareBuild = require_compare_build2();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module.exports = rsort;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/gt.js
var require_gt2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/gt.js"(exports, module) {
    var compare = require_compare2();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module.exports = gt;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/lt.js
var require_lt2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/lt.js"(exports, module) {
    var compare = require_compare2();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module.exports = lt;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/eq.js
var require_eq3 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/eq.js"(exports, module) {
    var compare = require_compare2();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module.exports = eq;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/neq.js
var require_neq2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/neq.js"(exports, module) {
    var compare = require_compare2();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module.exports = neq;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/gte.js
var require_gte2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/gte.js"(exports, module) {
    var compare = require_compare2();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module.exports = gte;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/lte.js
var require_lte2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/lte.js"(exports, module) {
    var compare = require_compare2();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module.exports = lte;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/cmp.js
var require_cmp2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/cmp.js"(exports, module) {
    var eq = require_eq3();
    var neq = require_neq2();
    var gt = require_gt2();
    var gte = require_gte2();
    var lt = require_lt2();
    var lte = require_lte2();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/coerce.js
var require_coerce2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/coerce.js"(exports, module) {
    var SemVer = require_semver3();
    var parse = require_parse2();
    var { safeRe: re, t } = require_re2();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module.exports = coerce;
  }
});

// node_modules/snack-sdk/node_modules/semver/internal/lrucache.js
var require_lrucache2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/internal/lrucache.js"(exports, module) {
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});

// node_modules/snack-sdk/node_modules/semver/classes/range.js
var require_range2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/classes/range.js"(exports, module) {
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache2();
    var cache = new LRU();
    var parseOptions = require_parse_options2();
    var Comparator = require_comparator2();
    var debug = require_debug2();
    var SemVer = require_semver3();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re2();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants2();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/snack-sdk/node_modules/semver/classes/comparator.js
var require_comparator2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/classes/comparator.js"(exports, module) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options2();
    var { safeRe: re, t } = require_re2();
    var cmp = require_cmp2();
    var debug = require_debug2();
    var SemVer = require_semver3();
    var Range = require_range2();
  }
});

// node_modules/snack-sdk/node_modules/semver/functions/satisfies.js
var require_satisfies2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/functions/satisfies.js"(exports, module) {
    var Range = require_range2();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module.exports = satisfies;
  }
});

// node_modules/snack-sdk/node_modules/semver/ranges/to-comparators.js
var require_to_comparators2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/ranges/to-comparators.js"(exports, module) {
    var Range = require_range2();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module.exports = toComparators;
  }
});

// node_modules/snack-sdk/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    var SemVer = require_semver3();
    var Range = require_range2();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module.exports = maxSatisfying;
  }
});

// node_modules/snack-sdk/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    var SemVer = require_semver3();
    var Range = require_range2();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module.exports = minSatisfying;
  }
});

// node_modules/snack-sdk/node_modules/semver/ranges/min-version.js
var require_min_version2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/ranges/min-version.js"(exports, module) {
    var SemVer = require_semver3();
    var Range = require_range2();
    var gt = require_gt2();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  }
});

// node_modules/snack-sdk/node_modules/semver/ranges/valid.js
var require_valid4 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/ranges/valid.js"(exports, module) {
    var Range = require_range2();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module.exports = validRange;
  }
});

// node_modules/snack-sdk/node_modules/semver/ranges/outside.js
var require_outside2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/ranges/outside.js"(exports, module) {
    var SemVer = require_semver3();
    var Comparator = require_comparator2();
    var { ANY } = Comparator;
    var Range = require_range2();
    var satisfies = require_satisfies2();
    var gt = require_gt2();
    var lt = require_lt2();
    var lte = require_lte2();
    var gte = require_gte2();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  }
});

// node_modules/snack-sdk/node_modules/semver/ranges/gtr.js
var require_gtr2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/ranges/gtr.js"(exports, module) {
    var outside = require_outside2();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module.exports = gtr;
  }
});

// node_modules/snack-sdk/node_modules/semver/ranges/ltr.js
var require_ltr2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/ranges/ltr.js"(exports, module) {
    var outside = require_outside2();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module.exports = ltr;
  }
});

// node_modules/snack-sdk/node_modules/semver/ranges/intersects.js
var require_intersects2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/ranges/intersects.js"(exports, module) {
    var Range = require_range2();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module.exports = intersects;
  }
});

// node_modules/snack-sdk/node_modules/semver/ranges/simplify.js
var require_simplify2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/ranges/simplify.js"(exports, module) {
    var satisfies = require_satisfies2();
    var compare = require_compare2();
    module.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/snack-sdk/node_modules/semver/ranges/subset.js
var require_subset2 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/ranges/subset.js"(exports, module) {
    var Range = require_range2();
    var Comparator = require_comparator2();
    var { ANY } = Comparator;
    var satisfies = require_satisfies2();
    var compare = require_compare2();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module.exports = subset;
  }
});

// node_modules/snack-sdk/node_modules/semver/index.js
var require_semver4 = __commonJS({
  "node_modules/snack-sdk/node_modules/semver/index.js"(exports, module) {
    var internalRe = require_re2();
    var constants = require_constants2();
    var SemVer = require_semver3();
    var identifiers = require_identifiers2();
    var parse = require_parse2();
    var valid = require_valid3();
    var clean = require_clean2();
    var inc = require_inc2();
    var diff = require_diff2();
    var major = require_major2();
    var minor = require_minor2();
    var patch = require_patch2();
    var prerelease = require_prerelease2();
    var compare = require_compare2();
    var rcompare = require_rcompare2();
    var compareLoose = require_compare_loose2();
    var compareBuild = require_compare_build2();
    var sort = require_sort2();
    var rsort = require_rsort2();
    var gt = require_gt2();
    var lt = require_lt2();
    var eq = require_eq3();
    var neq = require_neq2();
    var gte = require_gte2();
    var lte = require_lte2();
    var cmp = require_cmp2();
    var coerce = require_coerce2();
    var Comparator = require_comparator2();
    var Range = require_range2();
    var satisfies = require_satisfies2();
    var toComparators = require_to_comparators2();
    var maxSatisfying = require_max_satisfying2();
    var minSatisfying = require_min_satisfying2();
    var minVersion = require_min_version2();
    var validRange = require_valid4();
    var outside = require_outside2();
    var gtr = require_gtr2();
    var ltr = require_ltr2();
    var intersects = require_intersects2();
    var simplifyRange = require_simplify2();
    var subset = require_subset2();
    module.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/builtins/builtins.json
var require_builtins = __commonJS({
  "node_modules/builtins/builtins.json"(exports, module) {
    module.exports = [
      "assert",
      "buffer",
      "child_process",
      "cluster",
      "console",
      "constants",
      "crypto",
      "dgram",
      "dns",
      "domain",
      "events",
      "fs",
      "http",
      "https",
      "module",
      "net",
      "os",
      "path",
      "process",
      "punycode",
      "querystring",
      "readline",
      "repl",
      "stream",
      "string_decoder",
      "timers",
      "tls",
      "tty",
      "url",
      "util",
      "v8",
      "vm",
      "zlib"
    ];
  }
});

// node_modules/validate-npm-package-name/index.js
var require_validate_npm_package_name = __commonJS({
  "node_modules/validate-npm-package-name/index.js"(exports, module) {
    "use strict";
    var scopedPackagePattern = new RegExp("^(?:@([^/]+?)[/])?([^/]+?)$");
    var builtins = require_builtins();
    var blacklist = [
      "node_modules",
      "favicon.ico"
    ];
    var validate = module.exports = function(name) {
      var warnings = [];
      var errors = [];
      if (name === null) {
        errors.push("name cannot be null");
        return done(warnings, errors);
      }
      if (name === void 0) {
        errors.push("name cannot be undefined");
        return done(warnings, errors);
      }
      if (typeof name !== "string") {
        errors.push("name must be a string");
        return done(warnings, errors);
      }
      if (!name.length) {
        errors.push("name length must be greater than zero");
      }
      if (name.match(/^\./)) {
        errors.push("name cannot start with a period");
      }
      if (name.match(/^_/)) {
        errors.push("name cannot start with an underscore");
      }
      if (name.trim() !== name) {
        errors.push("name cannot contain leading or trailing spaces");
      }
      blacklist.forEach(function(blacklistedName) {
        if (name.toLowerCase() === blacklistedName) {
          errors.push(blacklistedName + " is a blacklisted name");
        }
      });
      builtins.forEach(function(builtin) {
        if (name.toLowerCase() === builtin) {
          warnings.push(builtin + " is a core module name");
        }
      });
      if (name.length > 214) {
        warnings.push("name can no longer contain more than 214 characters");
      }
      if (name.toLowerCase() !== name) {
        warnings.push("name can no longer contain capital letters");
      }
      if (/[~'!()*]/.test(name.split("/").slice(-1)[0])) {
        warnings.push(`name can no longer contain special characters ("~'!()*")`);
      }
      if (encodeURIComponent(name) !== name) {
        var nameMatch = name.match(scopedPackagePattern);
        if (nameMatch) {
          var user = nameMatch[1];
          var pkg = nameMatch[2];
          if (encodeURIComponent(user) === user && encodeURIComponent(pkg) === pkg) {
            return done(warnings, errors);
          }
        }
        errors.push("name can only contain URL-friendly characters");
      }
      return done(warnings, errors);
    };
    validate.scopedPackagePattern = scopedPackagePattern;
    var done = function(warnings, errors) {
      var result = {
        validForNewPackages: errors.length === 0 && warnings.length === 0,
        validForOldPackages: errors.length === 0,
        warnings,
        errors
      };
      if (!result.warnings.length) delete result.warnings;
      if (!result.errors.length) delete result.errors;
      return result;
    };
  }
});

// node_modules/fetch-ponyfill/build/fetch-browser.js
var require_fetch_browser = __commonJS({
  "node_modules/fetch-ponyfill/build/fetch-browser.js"(exports, module) {
    (function(global2) {
      "use strict";
      function fetchPonyfill(options) {
        var Promise2 = options && options.Promise || global2.Promise;
        var XMLHttpRequest2 = options && options.XMLHttpRequest || global2.XMLHttpRequest;
        return function() {
          var globalThis2 = Object.create(global2, {
            fetch: {
              value: void 0,
              writable: true
            }
          });
          (function(global3, factory) {
            typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global3.WHATWGFetch = {});
          })(this, function(exports2) {
            "use strict";
            var global3 = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || typeof global3 !== "undefined" && global3;
            var support = {
              searchParams: "URLSearchParams" in global3,
              iterable: "Symbol" in global3 && "iterator" in Symbol,
              blob: "FileReader" in global3 && "Blob" in global3 && function() {
                try {
                  new Blob();
                  return true;
                } catch (e) {
                  return false;
                }
              }(),
              formData: "FormData" in global3,
              arrayBuffer: "ArrayBuffer" in global3
            };
            function isDataView(obj) {
              return obj && DataView.prototype.isPrototypeOf(obj);
            }
            if (support.arrayBuffer) {
              var viewClasses = [
                "[object Int8Array]",
                "[object Uint8Array]",
                "[object Uint8ClampedArray]",
                "[object Int16Array]",
                "[object Uint16Array]",
                "[object Int32Array]",
                "[object Uint32Array]",
                "[object Float32Array]",
                "[object Float64Array]"
              ];
              var isArrayBufferView = ArrayBuffer.isView || function(obj) {
                return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
              };
            }
            function normalizeName(name) {
              if (typeof name !== "string") {
                name = String(name);
              }
              if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
                throw new TypeError("Invalid character in header field name");
              }
              return name.toLowerCase();
            }
            function normalizeValue(value) {
              if (typeof value !== "string") {
                value = String(value);
              }
              return value;
            }
            function iteratorFor(items) {
              var iterator = {
                next: function() {
                  var value = items.shift();
                  return { done: value === void 0, value };
                }
              };
              if (support.iterable) {
                iterator[Symbol.iterator] = function() {
                  return iterator;
                };
              }
              return iterator;
            }
            function Headers(headers) {
              this.map = {};
              if (headers instanceof Headers) {
                headers.forEach(function(value, name) {
                  this.append(name, value);
                }, this);
              } else if (Array.isArray(headers)) {
                headers.forEach(function(header) {
                  this.append(header[0], header[1]);
                }, this);
              } else if (headers) {
                Object.getOwnPropertyNames(headers).forEach(function(name) {
                  this.append(name, headers[name]);
                }, this);
              }
            }
            Headers.prototype.append = function(name, value) {
              name = normalizeName(name);
              value = normalizeValue(value);
              var oldValue = this.map[name];
              this.map[name] = oldValue ? oldValue + ", " + value : value;
            };
            Headers.prototype["delete"] = function(name) {
              delete this.map[normalizeName(name)];
            };
            Headers.prototype.get = function(name) {
              name = normalizeName(name);
              return this.has(name) ? this.map[name] : null;
            };
            Headers.prototype.has = function(name) {
              return this.map.hasOwnProperty(normalizeName(name));
            };
            Headers.prototype.set = function(name, value) {
              this.map[normalizeName(name)] = normalizeValue(value);
            };
            Headers.prototype.forEach = function(callback, thisArg) {
              for (var name in this.map) {
                if (this.map.hasOwnProperty(name)) {
                  callback.call(thisArg, this.map[name], name, this);
                }
              }
            };
            Headers.prototype.keys = function() {
              var items = [];
              this.forEach(function(value, name) {
                items.push(name);
              });
              return iteratorFor(items);
            };
            Headers.prototype.values = function() {
              var items = [];
              this.forEach(function(value) {
                items.push(value);
              });
              return iteratorFor(items);
            };
            Headers.prototype.entries = function() {
              var items = [];
              this.forEach(function(value, name) {
                items.push([name, value]);
              });
              return iteratorFor(items);
            };
            if (support.iterable) {
              Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
            }
            function consumed(body) {
              if (body.bodyUsed) {
                return Promise2.reject(new TypeError("Already read"));
              }
              body.bodyUsed = true;
            }
            function fileReaderReady(reader) {
              return new Promise2(function(resolve, reject) {
                reader.onload = function() {
                  resolve(reader.result);
                };
                reader.onerror = function() {
                  reject(reader.error);
                };
              });
            }
            function readBlobAsArrayBuffer(blob) {
              var reader = new FileReader();
              var promise = fileReaderReady(reader);
              reader.readAsArrayBuffer(blob);
              return promise;
            }
            function readBlobAsText(blob) {
              var reader = new FileReader();
              var promise = fileReaderReady(reader);
              reader.readAsText(blob);
              return promise;
            }
            function readArrayBufferAsText(buf) {
              var view = new Uint8Array(buf);
              var chars = new Array(view.length);
              for (var i = 0; i < view.length; i++) {
                chars[i] = String.fromCharCode(view[i]);
              }
              return chars.join("");
            }
            function bufferClone(buf) {
              if (buf.slice) {
                return buf.slice(0);
              } else {
                var view = new Uint8Array(buf.byteLength);
                view.set(new Uint8Array(buf));
                return view.buffer;
              }
            }
            function Body() {
              this.bodyUsed = false;
              this._initBody = function(body) {
                this.bodyUsed = this.bodyUsed;
                this._bodyInit = body;
                if (!body) {
                  this._bodyText = "";
                } else if (typeof body === "string") {
                  this._bodyText = body;
                } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                  this._bodyBlob = body;
                } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                  this._bodyFormData = body;
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                  this._bodyText = body.toString();
                } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                  this._bodyArrayBuffer = bufferClone(body.buffer);
                  this._bodyInit = new Blob([this._bodyArrayBuffer]);
                } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                  this._bodyArrayBuffer = bufferClone(body);
                } else {
                  this._bodyText = body = Object.prototype.toString.call(body);
                }
                if (!this.headers.get("content-type")) {
                  if (typeof body === "string") {
                    this.headers.set("content-type", "text/plain;charset=UTF-8");
                  } else if (this._bodyBlob && this._bodyBlob.type) {
                    this.headers.set("content-type", this._bodyBlob.type);
                  } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                    this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
                  }
                }
              };
              if (support.blob) {
                this.blob = function() {
                  var rejected = consumed(this);
                  if (rejected) {
                    return rejected;
                  }
                  if (this._bodyBlob) {
                    return Promise2.resolve(this._bodyBlob);
                  } else if (this._bodyArrayBuffer) {
                    return Promise2.resolve(new Blob([this._bodyArrayBuffer]));
                  } else if (this._bodyFormData) {
                    throw new Error("could not read FormData body as blob");
                  } else {
                    return Promise2.resolve(new Blob([this._bodyText]));
                  }
                };
                this.arrayBuffer = function() {
                  if (this._bodyArrayBuffer) {
                    var isConsumed = consumed(this);
                    if (isConsumed) {
                      return isConsumed;
                    }
                    if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                      return Promise2.resolve(
                        this._bodyArrayBuffer.buffer.slice(
                          this._bodyArrayBuffer.byteOffset,
                          this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                        )
                      );
                    } else {
                      return Promise2.resolve(this._bodyArrayBuffer);
                    }
                  } else {
                    return this.blob().then(readBlobAsArrayBuffer);
                  }
                };
              }
              this.text = function() {
                var rejected = consumed(this);
                if (rejected) {
                  return rejected;
                }
                if (this._bodyBlob) {
                  return readBlobAsText(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                  return Promise2.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
                } else if (this._bodyFormData) {
                  throw new Error("could not read FormData body as text");
                } else {
                  return Promise2.resolve(this._bodyText);
                }
              };
              if (support.formData) {
                this.formData = function() {
                  return this.text().then(decode);
                };
              }
              this.json = function() {
                return this.text().then(JSON.parse);
              };
              return this;
            }
            var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
            function normalizeMethod(method) {
              var upcased = method.toUpperCase();
              return methods.indexOf(upcased) > -1 ? upcased : method;
            }
            function Request(input, options2) {
              if (!(this instanceof Request)) {
                throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
              }
              options2 = options2 || {};
              var body = options2.body;
              if (input instanceof Request) {
                if (input.bodyUsed) {
                  throw new TypeError("Already read");
                }
                this.url = input.url;
                this.credentials = input.credentials;
                if (!options2.headers) {
                  this.headers = new Headers(input.headers);
                }
                this.method = input.method;
                this.mode = input.mode;
                this.signal = input.signal;
                if (!body && input._bodyInit != null) {
                  body = input._bodyInit;
                  input.bodyUsed = true;
                }
              } else {
                this.url = String(input);
              }
              this.credentials = options2.credentials || this.credentials || "same-origin";
              if (options2.headers || !this.headers) {
                this.headers = new Headers(options2.headers);
              }
              this.method = normalizeMethod(options2.method || this.method || "GET");
              this.mode = options2.mode || this.mode || null;
              this.signal = options2.signal || this.signal;
              this.referrer = null;
              if ((this.method === "GET" || this.method === "HEAD") && body) {
                throw new TypeError("Body not allowed for GET or HEAD requests");
              }
              this._initBody(body);
              if (this.method === "GET" || this.method === "HEAD") {
                if (options2.cache === "no-store" || options2.cache === "no-cache") {
                  var reParamSearch = /([?&])_=[^&]*/;
                  if (reParamSearch.test(this.url)) {
                    this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
                  } else {
                    var reQueryString = /\?/;
                    this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
                  }
                }
              }
            }
            Request.prototype.clone = function() {
              return new Request(this, { body: this._bodyInit });
            };
            function decode(body) {
              var form = new FormData();
              body.trim().split("&").forEach(function(bytes) {
                if (bytes) {
                  var split = bytes.split("=");
                  var name = split.shift().replace(/\+/g, " ");
                  var value = split.join("=").replace(/\+/g, " ");
                  form.append(decodeURIComponent(name), decodeURIComponent(value));
                }
              });
              return form;
            }
            function parseHeaders(rawHeaders) {
              var headers = new Headers();
              var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
              preProcessedHeaders.split("\r").map(function(header) {
                return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
              }).forEach(function(line) {
                var parts = line.split(":");
                var key = parts.shift().trim();
                if (key) {
                  var value = parts.join(":").trim();
                  headers.append(key, value);
                }
              });
              return headers;
            }
            Body.call(Request.prototype);
            function Response(bodyInit, options2) {
              if (!(this instanceof Response)) {
                throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
              }
              if (!options2) {
                options2 = {};
              }
              this.type = "default";
              this.status = options2.status === void 0 ? 200 : options2.status;
              this.ok = this.status >= 200 && this.status < 300;
              this.statusText = "statusText" in options2 ? options2.statusText : "";
              this.headers = new Headers(options2.headers);
              this.url = options2.url || "";
              this._initBody(bodyInit);
            }
            Body.call(Response.prototype);
            Response.prototype.clone = function() {
              return new Response(this._bodyInit, {
                status: this.status,
                statusText: this.statusText,
                headers: new Headers(this.headers),
                url: this.url
              });
            };
            Response.error = function() {
              var response = new Response(null, { status: 0, statusText: "" });
              response.type = "error";
              return response;
            };
            var redirectStatuses = [301, 302, 303, 307, 308];
            Response.redirect = function(url, status) {
              if (redirectStatuses.indexOf(status) === -1) {
                throw new RangeError("Invalid status code");
              }
              return new Response(null, { status, headers: { location: url } });
            };
            exports2.DOMException = global3.DOMException;
            try {
              new exports2.DOMException();
            } catch (err) {
              exports2.DOMException = function(message, name) {
                this.message = message;
                this.name = name;
                var error = Error(message);
                this.stack = error.stack;
              };
              exports2.DOMException.prototype = Object.create(Error.prototype);
              exports2.DOMException.prototype.constructor = exports2.DOMException;
            }
            function fetch(input, init) {
              return new Promise2(function(resolve, reject) {
                var request = new Request(input, init);
                if (request.signal && request.signal.aborted) {
                  return reject(new exports2.DOMException("Aborted", "AbortError"));
                }
                var xhr = new XMLHttpRequest2();
                function abortXhr() {
                  xhr.abort();
                }
                xhr.onload = function() {
                  var options2 = {
                    status: xhr.status,
                    statusText: xhr.statusText,
                    headers: parseHeaders(xhr.getAllResponseHeaders() || "")
                  };
                  options2.url = "responseURL" in xhr ? xhr.responseURL : options2.headers.get("X-Request-URL");
                  var body = "response" in xhr ? xhr.response : xhr.responseText;
                  setTimeout(function() {
                    resolve(new Response(body, options2));
                  }, 0);
                };
                xhr.onerror = function() {
                  setTimeout(function() {
                    reject(new TypeError("Network request failed"));
                  }, 0);
                };
                xhr.ontimeout = function() {
                  setTimeout(function() {
                    reject(new TypeError("Network request failed"));
                  }, 0);
                };
                xhr.onabort = function() {
                  setTimeout(function() {
                    reject(new exports2.DOMException("Aborted", "AbortError"));
                  }, 0);
                };
                function fixUrl(url) {
                  try {
                    return url === "" && global3.location.href ? global3.location.href : url;
                  } catch (e) {
                    return url;
                  }
                }
                xhr.open(request.method, fixUrl(request.url), true);
                if (request.credentials === "include") {
                  xhr.withCredentials = true;
                } else if (request.credentials === "omit") {
                  xhr.withCredentials = false;
                }
                if ("responseType" in xhr) {
                  if (support.blob) {
                    xhr.responseType = "blob";
                  } else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
                    xhr.responseType = "arraybuffer";
                  }
                }
                if (init && typeof init.headers === "object" && !(init.headers instanceof Headers)) {
                  Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                    xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
                  });
                } else {
                  request.headers.forEach(function(value, name) {
                    xhr.setRequestHeader(name, value);
                  });
                }
                if (request.signal) {
                  request.signal.addEventListener("abort", abortXhr);
                  xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                      request.signal.removeEventListener("abort", abortXhr);
                    }
                  };
                }
                xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
              });
            }
            fetch.polyfill = true;
            if (!global3.fetch) {
              global3.fetch = fetch;
              global3.Headers = Headers;
              global3.Request = Request;
              global3.Response = Response;
            }
            exports2.Headers = Headers;
            exports2.Request = Request;
            exports2.Response = Response;
            exports2.fetch = fetch;
            Object.defineProperty(exports2, "__esModule", { value: true });
          });
          return {
            fetch: globalThis2.fetch,
            Headers: globalThis2.Headers,
            Request: globalThis2.Request,
            Response: globalThis2.Response,
            DOMException: globalThis2.DOMException
          };
        }();
      }
      if (typeof define === "function" && define.amd) {
        define(function() {
          return fetchPonyfill;
        });
      } else if (typeof exports === "object") {
        module.exports = fetchPonyfill;
      } else {
        global2.fetchPonyfill = fetchPonyfill;
      }
    })(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : exports);
  }
});

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet;
var init_url_alphabet = __esm({
  "node_modules/nanoid/url-alphabet/index.js"() {
    urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  }
});

// node_modules/nanoid/index.browser.js
var index_browser_exports = {};
__export(index_browser_exports, {
  customAlphabet: () => customAlphabet,
  customRandom: () => customRandom,
  nanoid: () => nanoid,
  random: () => random,
  urlAlphabet: () => urlAlphabet
});
var random, customRandom, customAlphabet, nanoid;
var init_index_browser = __esm({
  "node_modules/nanoid/index.browser.js"() {
    init_url_alphabet();
    random = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
    customRandom = (alphabet, defaultSize, getRandom) => {
      let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
      let step = -~(1.6 * mask * defaultSize / alphabet.length);
      return (size = defaultSize) => {
        let id = "";
        while (true) {
          let bytes = getRandom(step);
          let j = step | 0;
          while (j--) {
            id += alphabet[bytes[j] & mask] || "";
            if (id.length === size) return id;
          }
        }
      };
    };
    customAlphabet = (alphabet, size = 21) => customRandom(alphabet, size, random);
    nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
      byte &= 63;
      if (byte < 36) {
        id += byte.toString(36);
      } else if (byte < 62) {
        id += (byte - 26).toString(36).toUpperCase();
      } else if (byte > 62) {
        id += "-";
      } else {
        id += "_";
      }
      return id;
    }, "");
  }
});

// node_modules/snack-sdk/build/utils.js
var require_utils = __commonJS({
  "node_modules/snack-sdk/build/utils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createUserHeader = exports.createError = exports.createURL = exports.createChannel = exports.fetch = void 0;
    var fetch_ponyfill_1 = __importDefault(require_fetch_browser());
    var nanoid_1 = (init_index_browser(), __toCommonJS(index_browser_exports));
    var snack_content_1 = require_build();
    var fetch = fetch_ponyfill_1.default().fetch;
    exports.fetch = fetch;
    var VALID_CHANNEL_CHARS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    var generateChannel = nanoid_1.customAlphabet(VALID_CHANNEL_CHARS, 10);
    function createChannel(channel) {
      channel = channel !== null && channel !== void 0 ? channel : generateChannel();
      if (channel.length < 6) {
        throw new Error("Please use a channel id with more characters (entropy)");
      }
      if (channel.length > 128) {
        throw new Error("Channel id too long, use a channel id thats shorter than 128 characters");
      }
      for (var _i = 0, channel_1 = channel; _i < channel_1.length; _i++) {
        var char = channel_1[_i];
        if (VALID_CHANNEL_CHARS.indexOf(char) < 0) {
          throw new Error('Channel id contains an invalid character "' + char + '", only "[0-9a-zA-Z]" are allowed');
        }
      }
      return channel;
    }
    exports.createChannel = createChannel;
    function createURL(endpoint, sdkVersion, channel, id) {
      return snack_content_1.createRuntimeUrl({ endpoint, channel, sdkVersion, snack: id });
    }
    exports.createURL = createURL;
    function createError(config) {
      var error = new Error(config.message);
      if (config.name)
        error.name = config.name;
      if (config.fileName)
        error.fileName = config.fileName;
      if (config.lineNumber)
        error.lineNumber = config.lineNumber;
      if (config.columnNumber)
        error.columnNumber = config.columnNumber;
      if (config.stack)
        error.stack = config.stack;
      return error;
    }
    exports.createError = createError;
    function createUserHeader(user) {
      if (user === null || user === void 0 ? void 0 : user.sessionSecret) {
        return { "Expo-Session": user.sessionSecret };
      }
      if (user === null || user === void 0 ? void 0 : user.accessToken) {
        return { Authorization: "Bearer " + user.accessToken };
      }
      return {};
    }
    exports.createUserHeader = createUserHeader;
  }
});

// node_modules/snack-sdk/build/DependencyResolver.js
var require_DependencyResolver = __commonJS({
  "node_modules/snack-sdk/build/DependencyResolver.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __spreadArrays = exports && exports.__spreadArrays || function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPackageName = exports.verifyDependency = exports.getMissingDependencies = void 0;
    var semver_1 = __importDefault(require_semver4());
    var snack_content_1 = require_build();
    var validate_npm_package_name_1 = __importDefault(require_validate_npm_package_name());
    var utils_1 = require_utils();
    function getKey(name, version) {
      return version ? name + "@" + version : name;
    }
    var DependencyResolver = (
      /** @class */
      function() {
        function DependencyResolver2(options) {
          this.status = {};
          this.snackagerURL = options.snackagerURL;
          this.logger = options.logger;
          this.callback = options.callback;
        }
        DependencyResolver2.prototype.add = function(name, version, sdkVersion) {
          var key = getKey(name, version);
          this.status[key] = this.status[key] || this.resolve(key, name, version, sdkVersion);
          return this.status[key];
        };
        DependencyResolver2.prototype.remove = function(name, version, _sdkVersion) {
          delete this.status[getKey(name, version)];
        };
        DependencyResolver2.prototype.waitForCompletion = function() {
          return __awaiter(this, void 0, void 0, function() {
            var promises;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  promises = Object.values(this.status);
                  _a.label = 1;
                case 1:
                  if (!promises.length) return [3, 3];
                  return [4, Promise.all(promises)];
                case 2:
                  _a.sent();
                  promises = Object.values(this.status);
                  return [3, 1];
                case 3:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        DependencyResolver2.prototype.resolve = function(key, name, version, sdkVersion) {
          var _a, _b, _c, _d;
          return __awaiter(this, void 0, void 0, function() {
            var versionSnackager, url, i, res, data, error, e_1, error, promiseExists;
            return __generator(this, function(_e) {
              switch (_e.label) {
                case 0:
                  versionSnackager = sdkVersion >= "37.0.0" ? "version_snackager=true&" : "";
                  url = this.snackagerURL + "/bundle/" + key + "?" + versionSnackager + "sdkVersion=" + sdkVersion + "&platforms=ios,android,web";
                  (_a = this.logger) === null || _a === void 0 ? void 0 : _a.module("Resolving dependency", key, "...");
                  _e.label = 1;
                case 1:
                  _e.trys.push([1, 12, , 13]);
                  i = 0;
                  _e.label = 2;
                case 2:
                  if (!(i < 30)) return [3, 11];
                  return [4, utils_1.fetch(url)];
                case 3:
                  res = _e.sent();
                  if (!this.status[key]) {
                    return [
                      2
                      /*return*/
                    ];
                  }
                  if (!(res.status === 200)) return [3, 8];
                  return [4, res.json()];
                case 4:
                  data = _e.sent();
                  if (!data.pending) return [3, 6];
                  (_b = this.logger) === null || _b === void 0 ? void 0 : _b.module("Dependency is still being bundled", key, "trying again shortly");
                  return [4, new Promise(function(resolve) {
                    return setTimeout(resolve, 5e3);
                  })];
                case 5:
                  _e.sent();
                  if (!this.status[key]) {
                    return [
                      2
                      /*return*/
                    ];
                  }
                  return [3, 7];
                case 6:
                  (_c = this.logger) === null || _c === void 0 ? void 0 : _c.module("Resolved dependency", key, data);
                  delete this.status[key];
                  try {
                    this.callback({
                      name,
                      version,
                      sdkVersion
                    }, data);
                    return [
                      2
                      /*return*/
                    ];
                  } catch (e) {
                    return [2, Promise.reject(e)];
                  }
                  _e.label = 7;
                case 7:
                  return [3, 10];
                case 8:
                  return [4, res.text()];
                case 9:
                  error = _e.sent();
                  throw new Error(error);
                case 10:
                  i++;
                  return [3, 2];
                case 11:
                  return [3, 13];
                case 12:
                  e_1 = _e.sent();
                  error = utils_1.createError({
                    message: "Failed to resolve dependency '" + key + "' (" + e_1.message + ")",
                    fileName: key
                  });
                  (_d = this.logger) === null || _d === void 0 ? void 0 : _d.error(error);
                  promiseExists = !!this.status[key];
                  if (promiseExists) {
                    delete this.status[key];
                    this.callback({
                      name,
                      version,
                      sdkVersion
                    }, void 0, error);
                  }
                  return [3, 13];
                case 13:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        return DependencyResolver2;
      }()
    );
    exports.default = DependencyResolver;
    function getMissingDependencies(dependencies, sdkVersion, wantedDependencyVersions) {
      var _a, _b;
      var result = {};
      for (var name_1 in dependencies) {
        var dep = dependencies[name_1];
        if (dep.peerDependencies) {
          for (var peerName in dep.peerDependencies) {
            if (!snack_content_1.isModulePreloaded(peerName, sdkVersion, true) && !dependencies[peerName]) {
              if (!result[peerName]) {
                result[peerName] = {
                  dependents: [name_1],
                  wantedVersion: (_b = (_a = wantedDependencyVersions === null || wantedDependencyVersions === void 0 ? void 0 : wantedDependencyVersions[peerName]) !== null && _a !== void 0 ? _a : dep.peerDependencies[peerName]) !== null && _b !== void 0 ? _b : "*"
                };
              } else {
                var wantedVersion = wantedDependencyVersions === null || wantedDependencyVersions === void 0 ? void 0 : wantedDependencyVersions[peerName];
                if (!wantedVersion) {
                  wantedVersion = result[peerName].wantedVersion;
                  var version = dep.peerDependencies[peerName] || "*";
                  if (wantedVersion === "*" || version === "latest" && wantedVersion === "latest" || version !== "*" && version !== "latest" && (wantedVersion === "latest" || semver_1.default.gt(semver_1.default.coerce(version), semver_1.default.coerce(wantedVersion)))) {
                    wantedVersion = version;
                  }
                }
                result[peerName] = {
                  dependents: __spreadArrays(result[peerName].dependents, [name_1]),
                  wantedVersion
                };
              }
            }
          }
        }
      }
      return result;
    }
    exports.getMissingDependencies = getMissingDependencies;
    function verifyDependency(name, version) {
      var _a = validate_npm_package_name_1.default(name), validForOldPackages = _a.validForOldPackages, errors = _a.errors;
      if (!validForOldPackages) {
        var names = name.split("/");
        if (names.length >= 2 && !name.startsWith("@")) {
          var result = validate_npm_package_name_1.default(names[0]);
          validForOldPackages = result.validForNewPackages;
          errors = result.errors;
        } else if (names.length >= 2 && name.startsWith("@")) {
          var result = validate_npm_package_name_1.default(names[0] + "/" + names[1]);
          validForOldPackages = result.validForNewPackages;
          errors = result.errors;
        }
        if (!validForOldPackages) {
          return utils_1.createError({
            message: "Invalid dependency '" + name + "' " + ((errors === null || errors === void 0 ? void 0 : errors.length) ? "(" + errors[0] + ")" : ""),
            fileName: name
          });
        }
      }
      if (!snack_content_1.isValidSemver(version)) {
        return utils_1.createError({
          message: "Invalid dependency '" + name + "' (version '" + version + "' is not a valid semver)",
          fileName: name
        });
      }
      return void 0;
    }
    exports.verifyDependency = verifyDependency;
    function getPackageName(name) {
      var names = name.split("/");
      if (names[0].startsWith("@") && names.length >= 2) {
        return names[0] + "/" + names[1];
      } else {
        return names[0];
      }
    }
    exports.getPackageName = getPackageName;
  }
});

// node_modules/snack-sdk/build/DevSession.js
var require_DevSession = __commonJS({
  "node_modules/snack-sdk/build/DevSession.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils();
    var DevSession = (
      /** @class */
      function() {
        function DevSession2(options) {
          this.apiURL = options.apiURL;
          this.logger = options.logger;
          this.onSendBeaconCloseRequest = options.onSendBeaconCloseRequest;
        }
        DevSession2.prototype.setState = function(state, prevState) {
          var isCloseUser = prevState.user && (!state.online || state.url !== prevState.url || state.user !== prevState.user);
          var isCloseDevice = prevState.deviceId && (!state.online || state.url !== prevState.url || state.deviceId !== prevState.deviceId);
          if (prevState.online && (isCloseUser || isCloseDevice)) {
            this.close(prevState.url, isCloseUser ? prevState.user : void 0, isCloseDevice ? prevState.deviceId : void 0);
          }
          if (state.user !== prevState.user || state.online !== prevState.online || state.url !== prevState.url || state.deviceId !== prevState.deviceId || state.onlineName !== prevState.onlineName) {
            this.notify(state);
          }
        };
        DevSession2.prototype.setFocus = function(state) {
          this.notify(state, true);
        };
        DevSession2.prototype.getRequest = function(close, user, deviceId) {
          var suffix = deviceId ? "?deviceId=" + deviceId : "";
          var endpoint = close ? "notify-close" : "notify-alive";
          var url = this.apiURL + "/--/api/v2/development-sessions/" + endpoint + suffix;
          return {
            url,
            method: "post",
            headers: __assign({ "Content-Type": "application/json" }, utils_1.createUserHeader(user))
          };
        };
        DevSession2.prototype.notify = function(state, setFocus) {
          var _a, _b;
          return __awaiter(this, void 0, void 0, function() {
            var user, online, onlineURL, deviceId, onlineName, _c, url, data, response, json, e_1;
            return __generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  user = state.user, online = state.online, onlineURL = state.url, deviceId = state.deviceId, onlineName = state.onlineName;
                  if (!online || !user && !deviceId) {
                    this.focusedAt = void 0;
                    return [
                      2
                      /*return*/
                    ];
                  }
                  if (!this.focusedAt || setFocus) {
                    this.focusedAt = Date.now();
                  }
                  _d.label = 1;
                case 1:
                  _d.trys.push([1, 4, , 5]);
                  _c = this.getRequest(false, user, deviceId), url = _c.url, data = __rest(_c, ["url"]);
                  return [4, utils_1.fetch(url, __assign(__assign({}, data), { body: JSON.stringify({
                    data: {
                      session: {
                        description: onlineName,
                        hostname: "snack",
                        config: {},
                        url: onlineURL,
                        source: "snack",
                        openedAt: this.focusedAt
                      }
                    }
                  }) }))];
                case 2:
                  response = _d.sent();
                  if (!response.ok) {
                    throw Error(response.statusText);
                  }
                  return [4, response.json()];
                case 3:
                  json = _d.sent();
                  this.onSendBeaconCloseRequest({
                    url: this.getRequest(true, void 0, deviceId).url,
                    data: new Blob([
                      JSON.stringify(__assign({ session: {
                        url: onlineURL
                      } }, ((_a = json.data) === null || _a === void 0 ? void 0 : _a.auth) ? {
                        auth: json.data.auth
                      } : {}))
                    ], { type: "text/plain" })
                  });
                  return [3, 5];
                case 4:
                  e_1 = _d.sent();
                  (_b = this.logger) === null || _b === void 0 ? void 0 : _b.error("Failed to advertise", e_1);
                  return [3, 5];
                case 5:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        DevSession2.prototype.close = function(onlineURL, user, deviceId) {
          var _a;
          return __awaiter(this, void 0, void 0, function() {
            var _b, url, data, response, e_2;
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  _c.trys.push([0, 2, , 3]);
                  _b = this.getRequest(true, user, deviceId), url = _b.url, data = __rest(_b, ["url"]);
                  return [4, utils_1.fetch(url, __assign(__assign({}, data), { body: JSON.stringify({
                    session: {
                      url: onlineURL
                    }
                  }) }))];
                case 1:
                  response = _c.sent();
                  if (!response.ok) {
                    throw Error(response.statusText);
                  }
                  return [3, 3];
                case 2:
                  e_2 = _c.sent();
                  (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error("Failed to advertise close", e_2);
                  return [3, 3];
                case 3:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        return DevSession2;
      }()
    );
    exports.default = DevSession;
  }
});

// node_modules/snack-sdk/build/FileUploader.js
var require_FileUploader = __commonJS({
  "node_modules/snack-sdk/build/FileUploader.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils();
    var FileUploader = (
      /** @class */
      function() {
        function FileUploader2(options) {
          this.status = {};
          this.apiURL = options.apiURL;
          this.callback = options.callback;
          this.logger = options.logger;
        }
        FileUploader2.prototype.add = function(path, file) {
          var status = this.status[path];
          if (status && status.file === file) {
            return status.promise;
          }
          this.status[path] = {
            file,
            promise: this.upload(path, file)
          };
          return this.status[path].promise;
        };
        FileUploader2.prototype.remove = function(path, file) {
          var _a;
          if (!file || ((_a = this.status[path]) === null || _a === void 0 ? void 0 : _a.file) === file) {
            delete this.status[path];
          }
        };
        FileUploader2.prototype.waitForCompletion = function() {
          return __awaiter(this, void 0, void 0, function() {
            var promises;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  promises = Object.values(this.status).map(function(status) {
                    return status.promise;
                  });
                  _a.label = 1;
                case 1:
                  if (!promises.length) return [3, 3];
                  return [4, Promise.all(promises)];
                case 2:
                  _a.sent();
                  promises = Object.values(this.status).map(function(status) {
                    return status.promise;
                  });
                  return [3, 1];
                case 3:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        FileUploader2.prototype.upload = function(path, file) {
          var _a, _b, _c, _d, _e, _f, _g;
          return __awaiter(this, void 0, void 0, function() {
            var url, input, formData, response, text, result, resultURL, e_1, error;
            return __generator(this, function(_h) {
              switch (_h.label) {
                case 0:
                  _h.trys.push([0, 5, , 6]);
                  (_a = this.logger) === null || _a === void 0 ? void 0 : _a.module("Uploading file", path, "...");
                  url = void 0;
                  input = void 0;
                  switch (file.type) {
                    case "CODE":
                      url = this.apiURL + "/--/api/v2/snack/uploadCode";
                      input = {
                        method: "POST",
                        body: JSON.stringify({ code: file.contents }),
                        headers: { "Content-Type": "application/json" }
                      };
                      break;
                    case "ASSET":
                      url = this.apiURL + "/--/api/v2/snack/uploadAsset";
                      if (typeof FormData !== "undefined" && file.contents instanceof FormData || typeof file.contents === "object" && ((_b = file.contents.constructor) === null || _b === void 0 ? void 0 : _b.name) === "FormData") {
                        input = {
                          method: "POST",
                          body: file.contents
                        };
                      } else if (typeof FormData !== "undefined") {
                        formData = new FormData();
                        formData.append("asset", file.contents, ((_c = file.contents) === null || _c === void 0 ? void 0 : _c.name) || path);
                        input = {
                          method: "POST",
                          body: formData
                        };
                      } else {
                        throw new Error("Uploading assets is not supported in this environment. Make sure FormData is polyfilled or provide the data as a FormData object");
                      }
                      break;
                    default:
                      throw new Error("Invalid file type " + file.type);
                  }
                  return [4, utils_1.fetch(url, input)];
                case 1:
                  response = _h.sent();
                  if (!!response.ok) return [3, 3];
                  return [4, response.text()];
                case 2:
                  text = _h.sent();
                  throw new Error(text);
                case 3:
                  return [4, response.json()];
                case 4:
                  result = _h.sent();
                  resultURL = result.url;
                  if (((_d = this.status[path]) === null || _d === void 0 ? void 0 : _d.file) === file) {
                    (_e = this.logger) === null || _e === void 0 ? void 0 : _e.module("Uploaded file", path, resultURL);
                    delete this.status[path];
                    try {
                      this.callback({ path, file }, resultURL);
                    } catch (e) {
                      return [2, Promise.reject(e)];
                    }
                  }
                  return [3, 6];
                case 5:
                  e_1 = _h.sent();
                  error = utils_1.createError({
                    message: "Failed to upload file " + path + " (" + e_1.message + ")",
                    fileName: path
                  });
                  (_f = this.logger) === null || _f === void 0 ? void 0 : _f.error(error);
                  if (((_g = this.status[path]) === null || _g === void 0 ? void 0 : _g.file) === file) {
                    delete this.status[path];
                    this.callback({ path, file }, void 0, error);
                  }
                  return [3, 6];
                case 6:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        return FileUploader2;
      }()
    );
    exports.default = FileUploader;
  }
});

// node_modules/snack-sdk/build/Logger.js
var require_Logger = __commonJS({
  "node_modules/snack-sdk/build/Logger.js"(exports) {
    "use strict";
    var __spreadArrays = exports && exports.__spreadArrays || function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createLogger = void 0;
    function logFn(isEnabled, type, color, textColor) {
      return function() {
        var messages = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          messages[_i] = arguments[_i];
        }
        if (isEnabled) {
          console.log.apply(console, __spreadArrays([
            "%c " + type.toUpperCase() + " ",
            "background: " + color + "; color: " + (textColor !== null && textColor !== void 0 ? textColor : "#fff")
          ], messages));
        }
      };
    }
    function createLogger(isEnabled) {
      return {
        info: logFn(isEnabled, "info", "#2196f3"),
        warn: logFn(isEnabled, "warn", "#FF9800"),
        error: logFn(isEnabled, "error", "#f44336"),
        comm: logFn(isEnabled, "comm", "#DBD64E"),
        comm_recv: logFn(isEnabled, "comm", "#DBD64E", "#000"),
        module: logFn(isEnabled, "module", "#DB14C7")
      };
    }
    exports.createLogger = createLogger;
  }
});

// node_modules/lodash/isEqual.js
var require_isEqual = __commonJS({
  "node_modules/lodash/isEqual.js"(exports, module) {
    var baseIsEqual = require_baseIsEqual();
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    module.exports = isEqual;
  }
});

// node_modules/snack-sdk/build/State.js
var require_State = __commonJS({
  "node_modules/snack-sdk/build/State.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isUnsaved = exports.isCodeChanged = exports.isBusy = exports.updateObjects = exports.removeObject = exports.removeObjects = exports.addObject = exports.addObjects = void 0;
    var isEqual_1 = __importDefault(require_isEqual());
    var snack_content_1 = require_build();
    function addObjects(state, content, filter) {
      var newState = null;
      for (var key in content) {
        if (filter ? filter(content[key], state[key]) : !isEqual_1.default(content[key], state[key])) {
          newState = newState !== null && newState !== void 0 ? newState : __assign({}, state);
          newState[key] = content[key];
        }
      }
      return newState !== null && newState !== void 0 ? newState : state;
    }
    exports.addObjects = addObjects;
    function addObject(state, key, content, filter) {
      var _a;
      return addObjects(state, (_a = {}, _a[key] = content, _a), filter);
    }
    exports.addObject = addObject;
    function removeObjects(state, keys) {
      if (!keys.length)
        return state;
      var newState = null;
      keys.forEach(function(key) {
        if (state[key]) {
          newState = newState !== null && newState !== void 0 ? newState : __assign({}, state);
          delete newState[key];
        }
      });
      return newState !== null && newState !== void 0 ? newState : state;
    }
    exports.removeObjects = removeObjects;
    function removeObject(state, key) {
      return removeObjects(state, [key]);
    }
    exports.removeObject = removeObject;
    function updateObjects(state, content, compareFn) {
      if (compareFn === void 0) {
        compareFn = isEqual_1.default;
      }
      var newState = null;
      for (var key in content) {
        var val = content[key];
        if (val === null) {
          if (state[key]) {
            newState = newState !== null && newState !== void 0 ? newState : __assign({}, state);
            delete newState[key];
          }
        } else if (!compareFn(val, state[key])) {
          newState = newState !== null && newState !== void 0 ? newState : __assign({}, state);
          newState[key] = val;
        }
      }
      return newState !== null && newState !== void 0 ? newState : state;
    }
    exports.updateObjects = updateObjects;
    function isBusy(state) {
      return !!Object.keys(state.dependencies).find(function(name) {
        return !state.dependencies[name].handle && !snack_content_1.isModulePreloaded(name, state.sdkVersion);
      }) || !!Object.values(state.files).find(function(file) {
        return file.type === "ASSET" && typeof file.contents !== "string";
      });
    }
    exports.isBusy = isBusy;
    function isCodeChanged(state, prevState) {
      return state.dependencies !== prevState.dependencies || state.files !== prevState.files || state.sdkVersion !== prevState.sdkVersion;
    }
    exports.isCodeChanged = isCodeChanged;
    function isUnsaved(state, prevState) {
      return state.dependencies !== prevState.dependencies || state.files !== prevState.files || state.sdkVersion !== prevState.sdkVersion || state.name !== prevState.name || state.description !== prevState.description;
    }
    exports.isUnsaved = isUnsaved;
  }
});

// node_modules/snack-sdk/build/WantedVersions.js
var require_WantedVersions = __commonJS({
  "node_modules/snack-sdk/build/WantedVersions.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WantedDependencyVersions = void 0;
    var snack_content_1 = require_build();
    var utils_1 = require_utils();
    var WantedDependencyVersions = (
      /** @class */
      function() {
        function WantedDependencyVersions2(options) {
          this.apiUrl = options.apiUrl;
          this.logger = options.logger;
          this.callback = options.callback;
          this.promise = Promise.resolve();
        }
        WantedDependencyVersions2.prototype.setSDKVersion = function(sdkVersion) {
          if (this.sdkVersion !== sdkVersion) {
            this.sdkVersion = sdkVersion;
            this.promise = this.fetchModules(sdkVersion);
          }
        };
        WantedDependencyVersions2.prototype.waitForCompletion = function() {
          return this.promise;
        };
        WantedDependencyVersions2.prototype.fetchModules = function(sdkVersion) {
          var _a, _b, _c, _d;
          return __awaiter(this, void 0, void 0, function() {
            var sdkVersionString, _e, remoteVersions, bundledVersions, versions, error_1;
            return __generator(this, function(_f) {
              switch (_f.label) {
                case 0:
                  if (this.sdkVersion !== sdkVersion) {
                    return [
                      2
                      /*return*/
                    ];
                  }
                  _f.label = 1;
                case 1:
                  _f.trys.push([1, 3, , 4]);
                  (_a = this.logger) === null || _a === void 0 ? void 0 : _a.module("fetching versioned modules for SDK", sdkVersion, "...");
                  sdkVersionString = ((_b = snack_content_1.sdks[sdkVersion]) === null || _b === void 0 ? void 0 : _b.version) || sdkVersion;
                  return [4, Promise.all([
                    this.fetchRemoteVersionedModules(sdkVersionString),
                    this.fetchBundledNativeModules(sdkVersionString)
                  ])];
                case 2:
                  _e = _f.sent(), remoteVersions = _e[0], bundledVersions = _e[1];
                  versions = __assign(__assign({}, remoteVersions), bundledVersions);
                  if (this.sdkVersion === sdkVersion) {
                    (_c = this.logger) === null || _c === void 0 ? void 0 : _c.module("fetched versioned modules for SDK", sdkVersion, versions);
                    this.callback(sdkVersion, versions);
                  }
                  return [3, 4];
                case 3:
                  error_1 = _f.sent();
                  if (this.sdkVersion === sdkVersion) {
                    (_d = this.logger) === null || _d === void 0 ? void 0 : _d.error(error_1);
                    this.callback(sdkVersion, void 0, error_1);
                  }
                  return [3, 4];
                case 4:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        WantedDependencyVersions2.prototype.fetchBundledNativeModules = function(sdkVersion) {
          var urlVersion = encodeURIComponent(sdkVersion);
          return utils_1.fetch("https://cdn.jsdelivr.net/npm/expo@" + urlVersion + "/bundledNativeModules.json").then(function(response) {
            return response.json();
          }).then(function(data) {
            return data || {};
          });
        };
        WantedDependencyVersions2.prototype.fetchRemoteVersionedModules = function(sdkVersion) {
          var _this = this;
          return utils_1.fetch(this.apiUrl + "/--/api/v2/versions/latest").then(function(response) {
            return response.json();
          }).then(function(data) {
            return _this.normalizeRemoteVersionResponse(sdkVersion, data);
          });
        };
        WantedDependencyVersions2.prototype.normalizeRemoteVersionResponse = function(sdkVersion, response) {
          var _a, _b;
          if (response === void 0) {
            response = {};
          }
          var sdkVersionSettings = (_b = (_a = response === null || response === void 0 ? void 0 : response.data) === null || _a === void 0 ? void 0 : _a.sdkVersions) === null || _b === void 0 ? void 0 : _b[sdkVersion];
          if (!sdkVersionSettings) {
            return {};
          }
          var relatedPackages = sdkVersionSettings.relatedPackages, facebookReactVersion = sdkVersionSettings.facebookReactVersion, facebookReactNativeVersion = sdkVersionSettings.facebookReactNativeVersion;
          var reactVersion = facebookReactVersion ? {
            react: facebookReactVersion,
            "react-dom": facebookReactVersion
          } : void 0;
          return __assign(__assign(__assign({}, relatedPackages), reactVersion), { "react-native": facebookReactNativeVersion });
        };
        return WantedDependencyVersions2;
      }()
    );
    exports.WantedDependencyVersions = WantedDependencyVersions;
  }
});

// node_modules/snack-sdk/build/defaultConfig.js
var require_defaultConfig = __commonJS({
  "node_modules/snack-sdk/build/defaultConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SnackIdentityState = exports.webPlayerURL = exports.snackpubURL = exports.snackagerURL = exports.apiURL = void 0;
    var snack_content_1 = require_build();
    exports.apiURL = "https://exp.host";
    exports.snackagerURL = "https://snackager.expo.io";
    exports.snackpubURL = "https://snackpub.expo.dev";
    exports.webPlayerURL = "https://snack-web-player.s3.us-west-1.amazonaws.com/v2/%%SDK_VERSION%%";
    exports.SnackIdentityState = {
      sdkVersion: snack_content_1.defaultSdkVersion,
      name: "",
      description: "",
      dependencies: {},
      missingDependencies: {},
      files: {},
      connectedClients: {},
      transports: {},
      disabled: false,
      unsaved: false,
      online: false,
      url: "",
      channel: ""
    };
    var defaultConfig = {
      apiURL: exports.apiURL,
      snackagerURL: exports.snackagerURL,
      snackpubURL: exports.snackpubURL,
      sdkVersion: snack_content_1.defaultSdkVersion,
      webPlayerURL: exports.webPlayerURL
    };
    exports.default = defaultConfig;
  }
});

// node_modules/pubnub/dist/web/pubnub.min.js
var require_pubnub_min = __commonJS({
  "node_modules/pubnub/dist/web/pubnub.min.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).PubNub = t();
    }(exports, function() {
      "use strict";
      var e = function(t2, n2) {
        return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e2, t3) {
          e2.__proto__ = t3;
        } || function(e2, t3) {
          for (var n3 in t3) Object.prototype.hasOwnProperty.call(t3, n3) && (e2[n3] = t3[n3]);
        }, e(t2, n2);
      };
      function t(t2, n2) {
        if ("function" != typeof n2 && null !== n2) throw new TypeError("Class extends value " + String(n2) + " is not a constructor or null");
        function r2() {
          this.constructor = t2;
        }
        e(t2, n2), t2.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      }
      var n = function() {
        return n = Object.assign || function(e2) {
          for (var t2, n2 = 1, r2 = arguments.length; n2 < r2; n2++) for (var o2 in t2 = arguments[n2]) Object.prototype.hasOwnProperty.call(t2, o2) && (e2[o2] = t2[o2]);
          return e2;
        }, n.apply(this, arguments);
      };
      function r(e2, t2) {
        var n2 = {};
        for (var r2 in e2) Object.prototype.hasOwnProperty.call(e2, r2) && t2.indexOf(r2) < 0 && (n2[r2] = e2[r2]);
        if (null != e2 && "function" == typeof Object.getOwnPropertySymbols) {
          var o2 = 0;
          for (r2 = Object.getOwnPropertySymbols(e2); o2 < r2.length; o2++) t2.indexOf(r2[o2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, r2[o2]) && (n2[r2[o2]] = e2[r2[o2]]);
        }
        return n2;
      }
      function o(e2, t2, n2, r2) {
        return new (n2 || (n2 = Promise))(function(o2, i2) {
          function s2(e3) {
            try {
              u2(r2.next(e3));
            } catch (e4) {
              i2(e4);
            }
          }
          function a2(e3) {
            try {
              u2(r2.throw(e3));
            } catch (e4) {
              i2(e4);
            }
          }
          function u2(e3) {
            var t3;
            e3.done ? o2(e3.value) : (t3 = e3.value, t3 instanceof n2 ? t3 : new n2(function(e4) {
              e4(t3);
            })).then(s2, a2);
          }
          u2((r2 = r2.apply(e2, t2 || [])).next());
        });
      }
      function i(e2, t2) {
        var n2, r2, o2, i2, s2 = { label: 0, sent: function() {
          if (1 & o2[0]) throw o2[1];
          return o2[1];
        }, trys: [], ops: [] };
        return i2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (i2[Symbol.iterator] = function() {
          return this;
        }), i2;
        function a2(i3) {
          return function(a3) {
            return function(i4) {
              if (n2) throw new TypeError("Generator is already executing.");
              for (; s2; ) try {
                if (n2 = 1, r2 && (o2 = 2 & i4[0] ? r2.return : i4[0] ? r2.throw || ((o2 = r2.return) && o2.call(r2), 0) : r2.next) && !(o2 = o2.call(r2, i4[1])).done) return o2;
                switch (r2 = 0, o2 && (i4 = [2 & i4[0], o2.value]), i4[0]) {
                  case 0:
                  case 1:
                    o2 = i4;
                    break;
                  case 4:
                    return s2.label++, { value: i4[1], done: false };
                  case 5:
                    s2.label++, r2 = i4[1], i4 = [0];
                    continue;
                  case 7:
                    i4 = s2.ops.pop(), s2.trys.pop();
                    continue;
                  default:
                    if (!(o2 = s2.trys, (o2 = o2.length > 0 && o2[o2.length - 1]) || 6 !== i4[0] && 2 !== i4[0])) {
                      s2 = 0;
                      continue;
                    }
                    if (3 === i4[0] && (!o2 || i4[1] > o2[0] && i4[1] < o2[3])) {
                      s2.label = i4[1];
                      break;
                    }
                    if (6 === i4[0] && s2.label < o2[1]) {
                      s2.label = o2[1], o2 = i4;
                      break;
                    }
                    if (o2 && s2.label < o2[2]) {
                      s2.label = o2[2], s2.ops.push(i4);
                      break;
                    }
                    o2[2] && s2.ops.pop(), s2.trys.pop();
                    continue;
                }
                i4 = t2.call(e2, s2);
              } catch (e3) {
                i4 = [6, e3], r2 = 0;
              } finally {
                n2 = o2 = 0;
              }
              if (5 & i4[0]) throw i4[1];
              return { value: i4[0] ? i4[1] : void 0, done: true };
            }([i3, a3]);
          };
        }
      }
      function s(e2) {
        var t2 = "function" == typeof Symbol && Symbol.iterator, n2 = t2 && e2[t2], r2 = 0;
        if (n2) return n2.call(e2);
        if (e2 && "number" == typeof e2.length) return { next: function() {
          return e2 && r2 >= e2.length && (e2 = void 0), { value: e2 && e2[r2++], done: !e2 };
        } };
        throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }
      function a(e2, t2) {
        var n2 = "function" == typeof Symbol && e2[Symbol.iterator];
        if (!n2) return e2;
        var r2, o2, i2 = n2.call(e2), s2 = [];
        try {
          for (; (void 0 === t2 || t2-- > 0) && !(r2 = i2.next()).done; ) s2.push(r2.value);
        } catch (e3) {
          o2 = { error: e3 };
        } finally {
          try {
            r2 && !r2.done && (n2 = i2.return) && n2.call(i2);
          } finally {
            if (o2) throw o2.error;
          }
        }
        return s2;
      }
      function u(e2, t2, n2) {
        if (n2 || 2 === arguments.length) for (var r2, o2 = 0, i2 = t2.length; o2 < i2; o2++) !r2 && o2 in t2 || (r2 || (r2 = Array.prototype.slice.call(t2, 0, o2)), r2[o2] = t2[o2]);
        return e2.concat(r2 || Array.prototype.slice.call(t2));
      }
      var c = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
      function l(e2) {
        if (e2.__esModule) return e2;
        var t2 = Object.defineProperty({}, "__esModule", { value: true });
        return Object.keys(e2).forEach(function(n2) {
          var r2 = Object.getOwnPropertyDescriptor(e2, n2);
          Object.defineProperty(t2, n2, r2.get ? r2 : { enumerable: true, get: function() {
            return e2[n2];
          } });
        }), t2;
      }
      var p = { exports: {} };
      !function(e2) {
        !function(t2, n2) {
          var r2 = Math.pow(2, -24), o2 = Math.pow(2, 32), i2 = Math.pow(2, 53);
          var s2 = { encode: function(e3) {
            var t3, r3 = new ArrayBuffer(256), s3 = new DataView(r3), a2 = 0;
            function u2(e4) {
              for (var n3 = r3.byteLength, o3 = a2 + e4; n3 < o3; ) n3 *= 2;
              if (n3 !== r3.byteLength) {
                var i3 = s3;
                r3 = new ArrayBuffer(n3), s3 = new DataView(r3);
                for (var u3 = a2 + 3 >> 2, c3 = 0; c3 < u3; ++c3) s3.setUint32(4 * c3, i3.getUint32(4 * c3));
              }
              return t3 = e4, s3;
            }
            function c2() {
              a2 += t3;
            }
            function l2(e4) {
              c2(u2(1).setUint8(a2, e4));
            }
            function p2(e4) {
              for (var t4 = u2(e4.length), n3 = 0; n3 < e4.length; ++n3) t4.setUint8(a2 + n3, e4[n3]);
              c2();
            }
            function h2(e4, t4) {
              t4 < 24 ? l2(e4 << 5 | t4) : t4 < 256 ? (l2(e4 << 5 | 24), l2(t4)) : t4 < 65536 ? (l2(e4 << 5 | 25), function(e5) {
                c2(u2(2).setUint16(a2, e5));
              }(t4)) : t4 < 4294967296 ? (l2(e4 << 5 | 26), function(e5) {
                c2(u2(4).setUint32(a2, e5));
              }(t4)) : (l2(e4 << 5 | 27), function(e5) {
                var t5 = e5 % o2, n3 = (e5 - t5) / o2, r4 = u2(8);
                r4.setUint32(a2, n3), r4.setUint32(a2 + 4, t5), c2();
              }(t4));
            }
            if (function e4(t4) {
              var r4;
              if (false === t4) return l2(244);
              if (true === t4) return l2(245);
              if (null === t4) return l2(246);
              if (t4 === n2) return l2(247);
              switch (typeof t4) {
                case "number":
                  if (Math.floor(t4) === t4) {
                    if (0 <= t4 && t4 <= i2) return h2(0, t4);
                    if (-i2 <= t4 && t4 < 0) return h2(1, -(t4 + 1));
                  }
                  return l2(251), function(e5) {
                    c2(u2(8).setFloat64(a2, e5));
                  }(t4);
                case "string":
                  var o3 = [];
                  for (r4 = 0; r4 < t4.length; ++r4) {
                    var s4 = t4.charCodeAt(r4);
                    s4 < 128 ? o3.push(s4) : s4 < 2048 ? (o3.push(192 | s4 >> 6), o3.push(128 | 63 & s4)) : s4 < 55296 ? (o3.push(224 | s4 >> 12), o3.push(128 | s4 >> 6 & 63), o3.push(128 | 63 & s4)) : (s4 = (1023 & s4) << 10, s4 |= 1023 & t4.charCodeAt(++r4), s4 += 65536, o3.push(240 | s4 >> 18), o3.push(128 | s4 >> 12 & 63), o3.push(128 | s4 >> 6 & 63), o3.push(128 | 63 & s4));
                  }
                  return h2(3, o3.length), p2(o3);
                default:
                  var f3;
                  if (Array.isArray(t4)) for (h2(4, f3 = t4.length), r4 = 0; r4 < f3; ++r4) e4(t4[r4]);
                  else if (t4 instanceof Uint8Array) h2(2, t4.length), p2(t4);
                  else {
                    var d3 = Object.keys(t4);
                    for (h2(5, f3 = d3.length), r4 = 0; r4 < f3; ++r4) {
                      var y3 = d3[r4];
                      e4(y3), e4(t4[y3]);
                    }
                  }
              }
            }(e3), "slice" in r3) return r3.slice(0, a2);
            for (var f2 = new ArrayBuffer(a2), d2 = new DataView(f2), y2 = 0; y2 < a2; ++y2) d2.setUint8(y2, s3.getUint8(y2));
            return f2;
          }, decode: function(e3, t3, i3) {
            var s3 = new DataView(e3), a2 = 0;
            function u2(e4, t4) {
              return a2 += t4, e4;
            }
            function c2(t4) {
              return u2(new Uint8Array(e3, a2, t4), t4);
            }
            function l2() {
              return u2(s3.getUint8(a2), 1);
            }
            function p2() {
              return u2(s3.getUint16(a2), 2);
            }
            function h2() {
              return u2(s3.getUint32(a2), 4);
            }
            function f2() {
              return 255 === s3.getUint8(a2) && (a2 += 1, true);
            }
            function d2(e4) {
              if (e4 < 24) return e4;
              if (24 === e4) return l2();
              if (25 === e4) return p2();
              if (26 === e4) return h2();
              if (27 === e4) return h2() * o2 + h2();
              if (31 === e4) return -1;
              throw "Invalid length encoding";
            }
            function y2(e4) {
              var t4 = l2();
              if (255 === t4) return -1;
              var n3 = d2(31 & t4);
              if (n3 < 0 || t4 >> 5 !== e4) throw "Invalid indefinite length element";
              return n3;
            }
            function g2(e4, t4) {
              for (var n3 = 0; n3 < t4; ++n3) {
                var r3 = l2();
                128 & r3 && (r3 < 224 ? (r3 = (31 & r3) << 6 | 63 & l2(), t4 -= 1) : r3 < 240 ? (r3 = (15 & r3) << 12 | (63 & l2()) << 6 | 63 & l2(), t4 -= 2) : (r3 = (15 & r3) << 18 | (63 & l2()) << 12 | (63 & l2()) << 6 | 63 & l2(), t4 -= 3)), r3 < 65536 ? e4.push(r3) : (r3 -= 65536, e4.push(55296 | r3 >> 10), e4.push(56320 | 1023 & r3));
              }
            }
            "function" != typeof t3 && (t3 = function(e4) {
              return e4;
            }), "function" != typeof i3 && (i3 = function() {
              return n2;
            });
            var m2 = function e4() {
              var o3, h3, m3 = l2(), b2 = m3 >> 5, v2 = 31 & m3;
              if (7 === b2) switch (v2) {
                case 25:
                  return function() {
                    var e5 = new ArrayBuffer(4), t4 = new DataView(e5), n3 = p2(), o4 = 32768 & n3, i4 = 31744 & n3, s4 = 1023 & n3;
                    if (31744 === i4) i4 = 261120;
                    else if (0 !== i4) i4 += 114688;
                    else if (0 !== s4) return s4 * r2;
                    return t4.setUint32(0, o4 << 16 | i4 << 13 | s4 << 13), t4.getFloat32(0);
                  }();
                case 26:
                  return u2(s3.getFloat32(a2), 4);
                case 27:
                  return u2(s3.getFloat64(a2), 8);
              }
              if ((h3 = d2(v2)) < 0 && (b2 < 2 || 6 < b2)) throw "Invalid length";
              switch (b2) {
                case 0:
                  return h3;
                case 1:
                  return -1 - h3;
                case 2:
                  if (h3 < 0) {
                    for (var _2 = [], S2 = 0; (h3 = y2(b2)) >= 0; ) S2 += h3, _2.push(c2(h3));
                    var w2 = new Uint8Array(S2), O2 = 0;
                    for (o3 = 0; o3 < _2.length; ++o3) w2.set(_2[o3], O2), O2 += _2[o3].length;
                    return w2;
                  }
                  return c2(h3);
                case 3:
                  var P2 = [];
                  if (h3 < 0) for (; (h3 = y2(b2)) >= 0; ) g2(P2, h3);
                  else g2(P2, h3);
                  return String.fromCharCode.apply(null, P2);
                case 4:
                  var E2;
                  if (h3 < 0) for (E2 = []; !f2(); ) E2.push(e4());
                  else for (E2 = new Array(h3), o3 = 0; o3 < h3; ++o3) E2[o3] = e4();
                  return E2;
                case 5:
                  var A2 = {};
                  for (o3 = 0; o3 < h3 || h3 < 0 && !f2(); ++o3) {
                    A2[e4()] = e4();
                  }
                  return A2;
                case 6:
                  return t3(e4(), h3);
                case 7:
                  switch (h3) {
                    case 20:
                      return false;
                    case 21:
                      return true;
                    case 22:
                      return null;
                    case 23:
                      return n2;
                    default:
                      return i3(h3);
                  }
              }
            }();
            if (a2 !== e3.byteLength) throw "Remaining bytes";
            return m2;
          } };
          e2.exports ? e2.exports = s2 : t2.CBOR || (t2.CBOR = s2);
        }(c);
      }(p);
      var h = p.exports, f = { exports: {} };
      !function(e2, t2) {
        !function(e3) {
          var t3 = "0.1.0", n2 = { 3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i, 4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i, 5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i, all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i };
          function r2() {
            var e4, t4, n3 = "";
            for (e4 = 0; e4 < 32; e4++) t4 = 16 * Math.random() | 0, 8 !== e4 && 12 !== e4 && 16 !== e4 && 20 !== e4 || (n3 += "-"), n3 += (12 === e4 ? 4 : 16 === e4 ? 3 & t4 | 8 : t4).toString(16);
            return n3;
          }
          function o2(e4, t4) {
            var r3 = n2[t4 || "all"];
            return r3 && r3.test(e4) || false;
          }
          r2.isUUID = o2, r2.VERSION = t3, e3.uuid = r2, e3.isUUID = o2;
        }(t2), null !== e2 && (e2.exports = t2.uuid);
      }(f, f.exports);
      var d = f.exports, y = function() {
        return d.uuid ? d.uuid() : d();
      }, g = function() {
        function e2(e3) {
          var t2, n2, r2, o2, i2 = e3.setup;
          if (this._PNSDKSuffix = {}, this.instanceId = "pn-".concat(y()), this.secretKey = i2.secretKey || i2.secret_key, this.subscribeKey = i2.subscribeKey || i2.subscribe_key, this.publishKey = i2.publishKey || i2.publish_key, this.sdkName = i2.sdkName, this.sdkFamily = i2.sdkFamily, this.partnerId = i2.partnerId, this.setAuthKey(i2.authKey), this.cryptoModule = i2.cryptoModule, this.setFilterExpression(i2.filterExpression), "string" != typeof i2.origin && !Array.isArray(i2.origin) && void 0 !== i2.origin) throw new Error("Origin must be either undefined, a string or a list of strings.");
          if (this.origin = i2.origin || Array.from({ length: 20 }, function(e4, t3) {
            return "ps".concat(t3 + 1, ".pndsn.com");
          }), this.secure = i2.ssl || false, this.restore = i2.restore || false, this.proxy = i2.proxy, this.keepAlive = i2.keepAlive, this.keepAliveSettings = i2.keepAliveSettings, this.autoNetworkDetection = i2.autoNetworkDetection || false, this.dedupeOnSubscribe = i2.dedupeOnSubscribe || false, this.maximumCacheSize = i2.maximumCacheSize || 100, this.customEncrypt = i2.customEncrypt, this.customDecrypt = i2.customDecrypt, this.fileUploadPublishRetryLimit = null !== (t2 = i2.fileUploadPublishRetryLimit) && void 0 !== t2 ? t2 : 5, this.useRandomIVs = null === (n2 = i2.useRandomIVs) || void 0 === n2 || n2, this.enableEventEngine = null !== (r2 = i2.enableEventEngine) && void 0 !== r2 && r2, this.maintainPresenceState = null === (o2 = i2.maintainPresenceState) || void 0 === o2 || o2, "undefined" != typeof location && "https:" === location.protocol && (this.secure = true), this.logVerbosity = i2.logVerbosity || false, this.suppressLeaveEvents = i2.suppressLeaveEvents || false, this.announceFailedHeartbeats = i2.announceFailedHeartbeats || true, this.announceSuccessfulHeartbeats = i2.announceSuccessfulHeartbeats || false, this.useInstanceId = i2.useInstanceId || false, this.useRequestId = i2.useRequestId || false, this.requestMessageCountThreshold = i2.requestMessageCountThreshold, i2.retryConfiguration && this._setRetryConfiguration(i2.retryConfiguration), this.setTransactionTimeout(i2.transactionalRequestTimeout || 15e3), this.setSubscribeTimeout(i2.subscribeRequestTimeout || 31e4), this.setSendBeaconConfig(i2.useSendBeacon || true), i2.presenceTimeout ? this.setPresenceTimeout(i2.presenceTimeout) : this._presenceTimeout = 300, null != i2.heartbeatInterval && this.setHeartbeatInterval(i2.heartbeatInterval), "string" == typeof i2.userId) {
            if ("string" == typeof i2.uuid) throw new Error("Only one of the following configuration options has to be provided: `uuid` or `userId`");
            this.setUserId(i2.userId);
          } else {
            if ("string" != typeof i2.uuid) throw new Error("One of the following configuration options has to be provided: `uuid` or `userId`");
            this.setUUID(i2.uuid);
          }
          this.setCipherKey(i2.cipherKey, i2);
        }
        return e2.prototype.getAuthKey = function() {
          return this.authKey;
        }, e2.prototype.setAuthKey = function(e3) {
          return this.authKey = e3, this;
        }, e2.prototype.setCipherKey = function(e3, t2, n2) {
          var r2;
          return this.cipherKey = e3, this.cipherKey && (this.cryptoModule = null !== (r2 = t2.cryptoModule) && void 0 !== r2 ? r2 : t2.initCryptoModule({ cipherKey: this.cipherKey, useRandomIVs: this.useRandomIVs }), n2 && (n2.cryptoModule = this.cryptoModule)), this;
        }, e2.prototype.getUUID = function() {
          return this.UUID;
        }, e2.prototype.setUUID = function(e3) {
          if (!e3 || "string" != typeof e3 || 0 === e3.trim().length) throw new Error("Missing uuid parameter. Provide a valid string uuid");
          return this.UUID = e3, this;
        }, e2.prototype.getUserId = function() {
          return this.UUID;
        }, e2.prototype.setUserId = function(e3) {
          if (!e3 || "string" != typeof e3 || 0 === e3.trim().length) throw new Error("Missing or invalid userId parameter. Provide a valid string userId");
          return this.UUID = e3, this;
        }, e2.prototype.getFilterExpression = function() {
          return this.filterExpression;
        }, e2.prototype.setFilterExpression = function(e3) {
          return this.filterExpression = e3, this;
        }, e2.prototype.getPresenceTimeout = function() {
          return this._presenceTimeout;
        }, e2.prototype.setPresenceTimeout = function(e3) {
          return e3 >= 20 ? this._presenceTimeout = e3 : (this._presenceTimeout = 20, console.log("WARNING: Presence timeout is less than the minimum. Using minimum value: ", this._presenceTimeout)), this.setHeartbeatInterval(this._presenceTimeout / 2 - 1), this;
        }, e2.prototype.setProxy = function(e3) {
          this.proxy = e3;
        }, e2.prototype.getHeartbeatInterval = function() {
          return this._heartbeatInterval;
        }, e2.prototype.setHeartbeatInterval = function(e3) {
          return this._heartbeatInterval = e3, this;
        }, e2.prototype.getSubscribeTimeout = function() {
          return this._subscribeRequestTimeout;
        }, e2.prototype.setSubscribeTimeout = function(e3) {
          return this._subscribeRequestTimeout = e3, this;
        }, e2.prototype.getTransactionTimeout = function() {
          return this._transactionalRequestTimeout;
        }, e2.prototype.setTransactionTimeout = function(e3) {
          return this._transactionalRequestTimeout = e3, this;
        }, e2.prototype.isSendBeaconEnabled = function() {
          return this._useSendBeacon;
        }, e2.prototype.setSendBeaconConfig = function(e3) {
          return this._useSendBeacon = e3, this;
        }, e2.prototype.getVersion = function() {
          return "7.6.3";
        }, e2.prototype._setRetryConfiguration = function(e3) {
          if (e3.minimumdelay < 2) throw new Error("Minimum delay can not be set less than 2 seconds for retry");
          if (e3.maximumDelay > 150) throw new Error("Maximum delay can not be set more than 150 seconds for retry");
          if (e3.maximumDelay && maximumRetry > 6) throw new Error("Maximum retry for exponential retry policy can not be more than 6");
          if (e3.maximumRetry > 10) throw new Error("Maximum retry for linear retry policy can not be more than 10");
          this.retryConfiguration = e3;
        }, e2.prototype._addPnsdkSuffix = function(e3, t2) {
          this._PNSDKSuffix[e3] = t2;
        }, e2.prototype._getPnsdkSuffix = function(e3) {
          var t2 = this;
          return Object.keys(this._PNSDKSuffix).reduce(function(n2, r2) {
            return n2 + e3 + t2._PNSDKSuffix[r2];
          }, "");
        }, e2;
      }();
      function m(e2) {
        var t2 = e2.replace(/==?$/, ""), n2 = Math.floor(t2.length / 4 * 3), r2 = new ArrayBuffer(n2), o2 = new Uint8Array(r2), i2 = 0;
        function s2() {
          var e3 = t2.charAt(i2++), n3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(e3);
          if (-1 === n3) throw new Error("Illegal character at ".concat(i2, ": ").concat(t2.charAt(i2 - 1)));
          return n3;
        }
        for (var a2 = 0; a2 < n2; a2 += 3) {
          var u2 = s2(), c2 = s2(), l2 = s2(), p2 = s2(), h2 = (63 & u2) << 2 | c2 >> 4, f2 = (15 & c2) << 4 | l2 >> 2, d2 = (3 & l2) << 6 | p2 >> 0;
          o2[a2] = h2, 64 != l2 && (o2[a2 + 1] = f2), 64 != p2 && (o2[a2 + 2] = d2);
        }
        return r2;
      }
      function b(e2) {
        for (var t2, n2 = "", r2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o2 = new Uint8Array(e2), i2 = o2.byteLength, s2 = i2 % 3, a2 = i2 - s2, u2 = 0; u2 < a2; u2 += 3) n2 += r2[(16515072 & (t2 = o2[u2] << 16 | o2[u2 + 1] << 8 | o2[u2 + 2])) >> 18] + r2[(258048 & t2) >> 12] + r2[(4032 & t2) >> 6] + r2[63 & t2];
        return 1 == s2 ? n2 += r2[(252 & (t2 = o2[a2])) >> 2] + r2[(3 & t2) << 4] + "==" : 2 == s2 && (n2 += r2[(64512 & (t2 = o2[a2] << 8 | o2[a2 + 1])) >> 10] + r2[(1008 & t2) >> 4] + r2[(15 & t2) << 2] + "="), n2;
      }
      var v, _, S, w, O, P = P || function(e2, t2) {
        var n2 = {}, r2 = n2.lib = {}, o2 = function() {
        }, i2 = r2.Base = { extend: function(e3) {
          o2.prototype = this;
          var t3 = new o2();
          return e3 && t3.mixIn(e3), t3.hasOwnProperty("init") || (t3.init = function() {
            t3.$super.init.apply(this, arguments);
          }), t3.init.prototype = t3, t3.$super = this, t3;
        }, create: function() {
          var e3 = this.extend();
          return e3.init.apply(e3, arguments), e3;
        }, init: function() {
        }, mixIn: function(e3) {
          for (var t3 in e3) e3.hasOwnProperty(t3) && (this[t3] = e3[t3]);
          e3.hasOwnProperty("toString") && (this.toString = e3.toString);
        }, clone: function() {
          return this.init.prototype.extend(this);
        } }, s2 = r2.WordArray = i2.extend({ init: function(e3, t3) {
          e3 = this.words = e3 || [], this.sigBytes = null != t3 ? t3 : 4 * e3.length;
        }, toString: function(e3) {
          return (e3 || u2).stringify(this);
        }, concat: function(e3) {
          var t3 = this.words, n3 = e3.words, r3 = this.sigBytes;
          if (e3 = e3.sigBytes, this.clamp(), r3 % 4) for (var o3 = 0; o3 < e3; o3++) t3[r3 + o3 >>> 2] |= (n3[o3 >>> 2] >>> 24 - o3 % 4 * 8 & 255) << 24 - (r3 + o3) % 4 * 8;
          else if (65535 < n3.length) for (o3 = 0; o3 < e3; o3 += 4) t3[r3 + o3 >>> 2] = n3[o3 >>> 2];
          else t3.push.apply(t3, n3);
          return this.sigBytes += e3, this;
        }, clamp: function() {
          var t3 = this.words, n3 = this.sigBytes;
          t3[n3 >>> 2] &= 4294967295 << 32 - n3 % 4 * 8, t3.length = e2.ceil(n3 / 4);
        }, clone: function() {
          var e3 = i2.clone.call(this);
          return e3.words = this.words.slice(0), e3;
        }, random: function(t3) {
          for (var n3 = [], r3 = 0; r3 < t3; r3 += 4) n3.push(4294967296 * e2.random() | 0);
          return new s2.init(n3, t3);
        } }), a2 = n2.enc = {}, u2 = a2.Hex = { stringify: function(e3) {
          var t3 = e3.words;
          e3 = e3.sigBytes;
          for (var n3 = [], r3 = 0; r3 < e3; r3++) {
            var o3 = t3[r3 >>> 2] >>> 24 - r3 % 4 * 8 & 255;
            n3.push((o3 >>> 4).toString(16)), n3.push((15 & o3).toString(16));
          }
          return n3.join("");
        }, parse: function(e3) {
          for (var t3 = e3.length, n3 = [], r3 = 0; r3 < t3; r3 += 2) n3[r3 >>> 3] |= parseInt(e3.substr(r3, 2), 16) << 24 - r3 % 8 * 4;
          return new s2.init(n3, t3 / 2);
        } }, c2 = a2.Latin1 = { stringify: function(e3) {
          var t3 = e3.words;
          e3 = e3.sigBytes;
          for (var n3 = [], r3 = 0; r3 < e3; r3++) n3.push(String.fromCharCode(t3[r3 >>> 2] >>> 24 - r3 % 4 * 8 & 255));
          return n3.join("");
        }, parse: function(e3) {
          for (var t3 = e3.length, n3 = [], r3 = 0; r3 < t3; r3++) n3[r3 >>> 2] |= (255 & e3.charCodeAt(r3)) << 24 - r3 % 4 * 8;
          return new s2.init(n3, t3);
        } }, l2 = a2.Utf8 = { stringify: function(e3) {
          try {
            return decodeURIComponent(escape(c2.stringify(e3)));
          } catch (e4) {
            throw Error("Malformed UTF-8 data");
          }
        }, parse: function(e3) {
          return c2.parse(unescape(encodeURIComponent(e3)));
        } }, p2 = r2.BufferedBlockAlgorithm = i2.extend({ reset: function() {
          this._data = new s2.init(), this._nDataBytes = 0;
        }, _append: function(e3) {
          "string" == typeof e3 && (e3 = l2.parse(e3)), this._data.concat(e3), this._nDataBytes += e3.sigBytes;
        }, _process: function(t3) {
          var n3 = this._data, r3 = n3.words, o3 = n3.sigBytes, i3 = this.blockSize, a3 = o3 / (4 * i3);
          if (t3 = (a3 = t3 ? e2.ceil(a3) : e2.max((0 | a3) - this._minBufferSize, 0)) * i3, o3 = e2.min(4 * t3, o3), t3) {
            for (var u3 = 0; u3 < t3; u3 += i3) this._doProcessBlock(r3, u3);
            u3 = r3.splice(0, t3), n3.sigBytes -= o3;
          }
          return new s2.init(u3, o3);
        }, clone: function() {
          var e3 = i2.clone.call(this);
          return e3._data = this._data.clone(), e3;
        }, _minBufferSize: 0 });
        r2.Hasher = p2.extend({ cfg: i2.extend(), init: function(e3) {
          this.cfg = this.cfg.extend(e3), this.reset();
        }, reset: function() {
          p2.reset.call(this), this._doReset();
        }, update: function(e3) {
          return this._append(e3), this._process(), this;
        }, finalize: function(e3) {
          return e3 && this._append(e3), this._doFinalize();
        }, blockSize: 16, _createHelper: function(e3) {
          return function(t3, n3) {
            return new e3.init(n3).finalize(t3);
          };
        }, _createHmacHelper: function(e3) {
          return function(t3, n3) {
            return new h2.HMAC.init(e3, n3).finalize(t3);
          };
        } });
        var h2 = n2.algo = {};
        return n2;
      }(Math);
      !function(e2) {
        for (var t2 = P, n2 = (o2 = t2.lib).WordArray, r2 = o2.Hasher, o2 = t2.algo, i2 = [], s2 = [], a2 = function(e3) {
          return 4294967296 * (e3 - (0 | e3)) | 0;
        }, u2 = 2, c2 = 0; 64 > c2; ) {
          var l2;
          e: {
            l2 = u2;
            for (var p2 = e2.sqrt(l2), h2 = 2; h2 <= p2; h2++) if (!(l2 % h2)) {
              l2 = false;
              break e;
            }
            l2 = true;
          }
          l2 && (8 > c2 && (i2[c2] = a2(e2.pow(u2, 0.5))), s2[c2] = a2(e2.pow(u2, 1 / 3)), c2++), u2++;
        }
        var f2 = [];
        o2 = o2.SHA256 = r2.extend({ _doReset: function() {
          this._hash = new n2.init(i2.slice(0));
        }, _doProcessBlock: function(e3, t3) {
          for (var n3 = this._hash.words, r3 = n3[0], o3 = n3[1], i3 = n3[2], a3 = n3[3], u3 = n3[4], c3 = n3[5], l3 = n3[6], p3 = n3[7], h3 = 0; 64 > h3; h3++) {
            if (16 > h3) f2[h3] = 0 | e3[t3 + h3];
            else {
              var d2 = f2[h3 - 15], y2 = f2[h3 - 2];
              f2[h3] = ((d2 << 25 | d2 >>> 7) ^ (d2 << 14 | d2 >>> 18) ^ d2 >>> 3) + f2[h3 - 7] + ((y2 << 15 | y2 >>> 17) ^ (y2 << 13 | y2 >>> 19) ^ y2 >>> 10) + f2[h3 - 16];
            }
            d2 = p3 + ((u3 << 26 | u3 >>> 6) ^ (u3 << 21 | u3 >>> 11) ^ (u3 << 7 | u3 >>> 25)) + (u3 & c3 ^ ~u3 & l3) + s2[h3] + f2[h3], y2 = ((r3 << 30 | r3 >>> 2) ^ (r3 << 19 | r3 >>> 13) ^ (r3 << 10 | r3 >>> 22)) + (r3 & o3 ^ r3 & i3 ^ o3 & i3), p3 = l3, l3 = c3, c3 = u3, u3 = a3 + d2 | 0, a3 = i3, i3 = o3, o3 = r3, r3 = d2 + y2 | 0;
          }
          n3[0] = n3[0] + r3 | 0, n3[1] = n3[1] + o3 | 0, n3[2] = n3[2] + i3 | 0, n3[3] = n3[3] + a3 | 0, n3[4] = n3[4] + u3 | 0, n3[5] = n3[5] + c3 | 0, n3[6] = n3[6] + l3 | 0, n3[7] = n3[7] + p3 | 0;
        }, _doFinalize: function() {
          var t3 = this._data, n3 = t3.words, r3 = 8 * this._nDataBytes, o3 = 8 * t3.sigBytes;
          return n3[o3 >>> 5] |= 128 << 24 - o3 % 32, n3[14 + (o3 + 64 >>> 9 << 4)] = e2.floor(r3 / 4294967296), n3[15 + (o3 + 64 >>> 9 << 4)] = r3, t3.sigBytes = 4 * n3.length, this._process(), this._hash;
        }, clone: function() {
          var e3 = r2.clone.call(this);
          return e3._hash = this._hash.clone(), e3;
        } });
        t2.SHA256 = r2._createHelper(o2), t2.HmacSHA256 = r2._createHmacHelper(o2);
      }(Math), _ = (v = P).enc.Utf8, v.algo.HMAC = v.lib.Base.extend({ init: function(e2, t2) {
        e2 = this._hasher = new e2.init(), "string" == typeof t2 && (t2 = _.parse(t2));
        var n2 = e2.blockSize, r2 = 4 * n2;
        t2.sigBytes > r2 && (t2 = e2.finalize(t2)), t2.clamp();
        for (var o2 = this._oKey = t2.clone(), i2 = this._iKey = t2.clone(), s2 = o2.words, a2 = i2.words, u2 = 0; u2 < n2; u2++) s2[u2] ^= 1549556828, a2[u2] ^= 909522486;
        o2.sigBytes = i2.sigBytes = r2, this.reset();
      }, reset: function() {
        var e2 = this._hasher;
        e2.reset(), e2.update(this._iKey);
      }, update: function(e2) {
        return this._hasher.update(e2), this;
      }, finalize: function(e2) {
        var t2 = this._hasher;
        return e2 = t2.finalize(e2), t2.reset(), t2.finalize(this._oKey.clone().concat(e2));
      } }), w = (S = P).lib.WordArray, S.enc.Base64 = { stringify: function(e2) {
        var t2 = e2.words, n2 = e2.sigBytes, r2 = this._map;
        e2.clamp(), e2 = [];
        for (var o2 = 0; o2 < n2; o2 += 3) for (var i2 = (t2[o2 >>> 2] >>> 24 - o2 % 4 * 8 & 255) << 16 | (t2[o2 + 1 >>> 2] >>> 24 - (o2 + 1) % 4 * 8 & 255) << 8 | t2[o2 + 2 >>> 2] >>> 24 - (o2 + 2) % 4 * 8 & 255, s2 = 0; 4 > s2 && o2 + 0.75 * s2 < n2; s2++) e2.push(r2.charAt(i2 >>> 6 * (3 - s2) & 63));
        if (t2 = r2.charAt(64)) for (; e2.length % 4; ) e2.push(t2);
        return e2.join("");
      }, parse: function(e2) {
        var t2 = e2.length, n2 = this._map;
        (r2 = n2.charAt(64)) && -1 != (r2 = e2.indexOf(r2)) && (t2 = r2);
        for (var r2 = [], o2 = 0, i2 = 0; i2 < t2; i2++) if (i2 % 4) {
          var s2 = n2.indexOf(e2.charAt(i2 - 1)) << i2 % 4 * 2, a2 = n2.indexOf(e2.charAt(i2)) >>> 6 - i2 % 4 * 2;
          r2[o2 >>> 2] |= (s2 | a2) << 24 - o2 % 4 * 8, o2++;
        }
        return w.create(r2, o2);
      }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" }, function(e2) {
        function t2(e3, t3, n3, r3, o3, i3, s3) {
          return ((e3 = e3 + (t3 & n3 | ~t3 & r3) + o3 + s3) << i3 | e3 >>> 32 - i3) + t3;
        }
        function n2(e3, t3, n3, r3, o3, i3, s3) {
          return ((e3 = e3 + (t3 & r3 | n3 & ~r3) + o3 + s3) << i3 | e3 >>> 32 - i3) + t3;
        }
        function r2(e3, t3, n3, r3, o3, i3, s3) {
          return ((e3 = e3 + (t3 ^ n3 ^ r3) + o3 + s3) << i3 | e3 >>> 32 - i3) + t3;
        }
        function o2(e3, t3, n3, r3, o3, i3, s3) {
          return ((e3 = e3 + (n3 ^ (t3 | ~r3)) + o3 + s3) << i3 | e3 >>> 32 - i3) + t3;
        }
        for (var i2 = P, s2 = (u2 = i2.lib).WordArray, a2 = u2.Hasher, u2 = i2.algo, c2 = [], l2 = 0; 64 > l2; l2++) c2[l2] = 4294967296 * e2.abs(e2.sin(l2 + 1)) | 0;
        u2 = u2.MD5 = a2.extend({ _doReset: function() {
          this._hash = new s2.init([1732584193, 4023233417, 2562383102, 271733878]);
        }, _doProcessBlock: function(e3, i3) {
          for (var s3 = 0; 16 > s3; s3++) {
            var a3 = e3[u3 = i3 + s3];
            e3[u3] = 16711935 & (a3 << 8 | a3 >>> 24) | 4278255360 & (a3 << 24 | a3 >>> 8);
          }
          s3 = this._hash.words;
          var u3 = e3[i3 + 0], l3 = (a3 = e3[i3 + 1], e3[i3 + 2]), p2 = e3[i3 + 3], h2 = e3[i3 + 4], f2 = e3[i3 + 5], d2 = e3[i3 + 6], y2 = e3[i3 + 7], g2 = e3[i3 + 8], m2 = e3[i3 + 9], b2 = e3[i3 + 10], v2 = e3[i3 + 11], _2 = e3[i3 + 12], S2 = e3[i3 + 13], w2 = e3[i3 + 14], O2 = e3[i3 + 15], P2 = t2(P2 = s3[0], T2 = s3[1], A2 = s3[2], E2 = s3[3], u3, 7, c2[0]), E2 = t2(E2, P2, T2, A2, a3, 12, c2[1]), A2 = t2(A2, E2, P2, T2, l3, 17, c2[2]), T2 = t2(T2, A2, E2, P2, p2, 22, c2[3]);
          P2 = t2(P2, T2, A2, E2, h2, 7, c2[4]), E2 = t2(E2, P2, T2, A2, f2, 12, c2[5]), A2 = t2(A2, E2, P2, T2, d2, 17, c2[6]), T2 = t2(T2, A2, E2, P2, y2, 22, c2[7]), P2 = t2(P2, T2, A2, E2, g2, 7, c2[8]), E2 = t2(E2, P2, T2, A2, m2, 12, c2[9]), A2 = t2(A2, E2, P2, T2, b2, 17, c2[10]), T2 = t2(T2, A2, E2, P2, v2, 22, c2[11]), P2 = t2(P2, T2, A2, E2, _2, 7, c2[12]), E2 = t2(E2, P2, T2, A2, S2, 12, c2[13]), A2 = t2(A2, E2, P2, T2, w2, 17, c2[14]), P2 = n2(P2, T2 = t2(T2, A2, E2, P2, O2, 22, c2[15]), A2, E2, a3, 5, c2[16]), E2 = n2(E2, P2, T2, A2, d2, 9, c2[17]), A2 = n2(A2, E2, P2, T2, v2, 14, c2[18]), T2 = n2(T2, A2, E2, P2, u3, 20, c2[19]), P2 = n2(P2, T2, A2, E2, f2, 5, c2[20]), E2 = n2(E2, P2, T2, A2, b2, 9, c2[21]), A2 = n2(A2, E2, P2, T2, O2, 14, c2[22]), T2 = n2(T2, A2, E2, P2, h2, 20, c2[23]), P2 = n2(P2, T2, A2, E2, m2, 5, c2[24]), E2 = n2(E2, P2, T2, A2, w2, 9, c2[25]), A2 = n2(A2, E2, P2, T2, p2, 14, c2[26]), T2 = n2(T2, A2, E2, P2, g2, 20, c2[27]), P2 = n2(P2, T2, A2, E2, S2, 5, c2[28]), E2 = n2(E2, P2, T2, A2, l3, 9, c2[29]), A2 = n2(A2, E2, P2, T2, y2, 14, c2[30]), P2 = r2(P2, T2 = n2(T2, A2, E2, P2, _2, 20, c2[31]), A2, E2, f2, 4, c2[32]), E2 = r2(E2, P2, T2, A2, g2, 11, c2[33]), A2 = r2(A2, E2, P2, T2, v2, 16, c2[34]), T2 = r2(T2, A2, E2, P2, w2, 23, c2[35]), P2 = r2(P2, T2, A2, E2, a3, 4, c2[36]), E2 = r2(E2, P2, T2, A2, h2, 11, c2[37]), A2 = r2(A2, E2, P2, T2, y2, 16, c2[38]), T2 = r2(T2, A2, E2, P2, b2, 23, c2[39]), P2 = r2(P2, T2, A2, E2, S2, 4, c2[40]), E2 = r2(E2, P2, T2, A2, u3, 11, c2[41]), A2 = r2(A2, E2, P2, T2, p2, 16, c2[42]), T2 = r2(T2, A2, E2, P2, d2, 23, c2[43]), P2 = r2(P2, T2, A2, E2, m2, 4, c2[44]), E2 = r2(E2, P2, T2, A2, _2, 11, c2[45]), A2 = r2(A2, E2, P2, T2, O2, 16, c2[46]), P2 = o2(P2, T2 = r2(T2, A2, E2, P2, l3, 23, c2[47]), A2, E2, u3, 6, c2[48]), E2 = o2(E2, P2, T2, A2, y2, 10, c2[49]), A2 = o2(A2, E2, P2, T2, w2, 15, c2[50]), T2 = o2(T2, A2, E2, P2, f2, 21, c2[51]), P2 = o2(P2, T2, A2, E2, _2, 6, c2[52]), E2 = o2(E2, P2, T2, A2, p2, 10, c2[53]), A2 = o2(A2, E2, P2, T2, b2, 15, c2[54]), T2 = o2(T2, A2, E2, P2, a3, 21, c2[55]), P2 = o2(P2, T2, A2, E2, g2, 6, c2[56]), E2 = o2(E2, P2, T2, A2, O2, 10, c2[57]), A2 = o2(A2, E2, P2, T2, d2, 15, c2[58]), T2 = o2(T2, A2, E2, P2, S2, 21, c2[59]), P2 = o2(P2, T2, A2, E2, h2, 6, c2[60]), E2 = o2(E2, P2, T2, A2, v2, 10, c2[61]), A2 = o2(A2, E2, P2, T2, l3, 15, c2[62]), T2 = o2(T2, A2, E2, P2, m2, 21, c2[63]);
          s3[0] = s3[0] + P2 | 0, s3[1] = s3[1] + T2 | 0, s3[2] = s3[2] + A2 | 0, s3[3] = s3[3] + E2 | 0;
        }, _doFinalize: function() {
          var t3 = this._data, n3 = t3.words, r3 = 8 * this._nDataBytes, o3 = 8 * t3.sigBytes;
          n3[o3 >>> 5] |= 128 << 24 - o3 % 32;
          var i3 = e2.floor(r3 / 4294967296);
          for (n3[15 + (o3 + 64 >>> 9 << 4)] = 16711935 & (i3 << 8 | i3 >>> 24) | 4278255360 & (i3 << 24 | i3 >>> 8), n3[14 + (o3 + 64 >>> 9 << 4)] = 16711935 & (r3 << 8 | r3 >>> 24) | 4278255360 & (r3 << 24 | r3 >>> 8), t3.sigBytes = 4 * (n3.length + 1), this._process(), n3 = (t3 = this._hash).words, r3 = 0; 4 > r3; r3++) o3 = n3[r3], n3[r3] = 16711935 & (o3 << 8 | o3 >>> 24) | 4278255360 & (o3 << 24 | o3 >>> 8);
          return t3;
        }, clone: function() {
          var e3 = a2.clone.call(this);
          return e3._hash = this._hash.clone(), e3;
        } }), i2.MD5 = a2._createHelper(u2), i2.HmacMD5 = a2._createHmacHelper(u2);
      }(Math), function() {
        var e2, t2 = P, n2 = (e2 = t2.lib).Base, r2 = e2.WordArray, o2 = (e2 = t2.algo).EvpKDF = n2.extend({ cfg: n2.extend({ keySize: 4, hasher: e2.MD5, iterations: 1 }), init: function(e3) {
          this.cfg = this.cfg.extend(e3);
        }, compute: function(e3, t3) {
          for (var n3 = (a2 = this.cfg).hasher.create(), o3 = r2.create(), i2 = o3.words, s2 = a2.keySize, a2 = a2.iterations; i2.length < s2; ) {
            u2 && n3.update(u2);
            var u2 = n3.update(e3).finalize(t3);
            n3.reset();
            for (var c2 = 1; c2 < a2; c2++) u2 = n3.finalize(u2), n3.reset();
            o3.concat(u2);
          }
          return o3.sigBytes = 4 * s2, o3;
        } });
        t2.EvpKDF = function(e3, t3, n3) {
          return o2.create(n3).compute(e3, t3);
        };
      }(), P.lib.Cipher || function(e2) {
        var t2 = (f2 = P).lib, n2 = t2.Base, r2 = t2.WordArray, o2 = t2.BufferedBlockAlgorithm, i2 = f2.enc.Base64, s2 = f2.algo.EvpKDF, a2 = t2.Cipher = o2.extend({ cfg: n2.extend(), createEncryptor: function(e3, t3) {
          return this.create(this._ENC_XFORM_MODE, e3, t3);
        }, createDecryptor: function(e3, t3) {
          return this.create(this._DEC_XFORM_MODE, e3, t3);
        }, init: function(e3, t3, n3) {
          this.cfg = this.cfg.extend(n3), this._xformMode = e3, this._key = t3, this.reset();
        }, reset: function() {
          o2.reset.call(this), this._doReset();
        }, process: function(e3) {
          return this._append(e3), this._process();
        }, finalize: function(e3) {
          return e3 && this._append(e3), this._doFinalize();
        }, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: function(e3) {
          return { encrypt: function(t3, n3, r3) {
            return ("string" == typeof n3 ? d2 : h2).encrypt(e3, t3, n3, r3);
          }, decrypt: function(t3, n3, r3) {
            return ("string" == typeof n3 ? d2 : h2).decrypt(e3, t3, n3, r3);
          } };
        } });
        t2.StreamCipher = a2.extend({ _doFinalize: function() {
          return this._process(true);
        }, blockSize: 1 });
        var u2 = f2.mode = {}, c2 = function(e3, t3, n3) {
          var r3 = this._iv;
          r3 ? this._iv = void 0 : r3 = this._prevBlock;
          for (var o3 = 0; o3 < n3; o3++) e3[t3 + o3] ^= r3[o3];
        }, l2 = (t2.BlockCipherMode = n2.extend({ createEncryptor: function(e3, t3) {
          return this.Encryptor.create(e3, t3);
        }, createDecryptor: function(e3, t3) {
          return this.Decryptor.create(e3, t3);
        }, init: function(e3, t3) {
          this._cipher = e3, this._iv = t3;
        } })).extend();
        l2.Encryptor = l2.extend({ processBlock: function(e3, t3) {
          var n3 = this._cipher, r3 = n3.blockSize;
          c2.call(this, e3, t3, r3), n3.encryptBlock(e3, t3), this._prevBlock = e3.slice(t3, t3 + r3);
        } }), l2.Decryptor = l2.extend({ processBlock: function(e3, t3) {
          var n3 = this._cipher, r3 = n3.blockSize, o3 = e3.slice(t3, t3 + r3);
          n3.decryptBlock(e3, t3), c2.call(this, e3, t3, r3), this._prevBlock = o3;
        } }), u2 = u2.CBC = l2, l2 = (f2.pad = {}).Pkcs7 = { pad: function(e3, t3) {
          for (var n3, o3 = (n3 = (n3 = 4 * t3) - e3.sigBytes % n3) << 24 | n3 << 16 | n3 << 8 | n3, i3 = [], s3 = 0; s3 < n3; s3 += 4) i3.push(o3);
          n3 = r2.create(i3, n3), e3.concat(n3);
        }, unpad: function(e3) {
          e3.sigBytes -= 255 & e3.words[e3.sigBytes - 1 >>> 2];
        } }, t2.BlockCipher = a2.extend({ cfg: a2.cfg.extend({ mode: u2, padding: l2 }), reset: function() {
          a2.reset.call(this);
          var e3 = (t3 = this.cfg).iv, t3 = t3.mode;
          if (this._xformMode == this._ENC_XFORM_MODE) var n3 = t3.createEncryptor;
          else n3 = t3.createDecryptor, this._minBufferSize = 1;
          this._mode = n3.call(t3, this, e3 && e3.words);
        }, _doProcessBlock: function(e3, t3) {
          this._mode.processBlock(e3, t3);
        }, _doFinalize: function() {
          var e3 = this.cfg.padding;
          if (this._xformMode == this._ENC_XFORM_MODE) {
            e3.pad(this._data, this.blockSize);
            var t3 = this._process(true);
          } else t3 = this._process(true), e3.unpad(t3);
          return t3;
        }, blockSize: 4 });
        var p2 = t2.CipherParams = n2.extend({ init: function(e3) {
          this.mixIn(e3);
        }, toString: function(e3) {
          return (e3 || this.formatter).stringify(this);
        } }), h2 = (u2 = (f2.format = {}).OpenSSL = { stringify: function(e3) {
          var t3 = e3.ciphertext;
          return ((e3 = e3.salt) ? r2.create([1398893684, 1701076831]).concat(e3).concat(t3) : t3).toString(i2);
        }, parse: function(e3) {
          var t3 = (e3 = i2.parse(e3)).words;
          if (1398893684 == t3[0] && 1701076831 == t3[1]) {
            var n3 = r2.create(t3.slice(2, 4));
            t3.splice(0, 4), e3.sigBytes -= 16;
          }
          return p2.create({ ciphertext: e3, salt: n3 });
        } }, t2.SerializableCipher = n2.extend({ cfg: n2.extend({ format: u2 }), encrypt: function(e3, t3, n3, r3) {
          r3 = this.cfg.extend(r3);
          var o3 = e3.createEncryptor(n3, r3);
          return t3 = o3.finalize(t3), o3 = o3.cfg, p2.create({ ciphertext: t3, key: n3, iv: o3.iv, algorithm: e3, mode: o3.mode, padding: o3.padding, blockSize: e3.blockSize, formatter: r3.format });
        }, decrypt: function(e3, t3, n3, r3) {
          return r3 = this.cfg.extend(r3), t3 = this._parse(t3, r3.format), e3.createDecryptor(n3, r3).finalize(t3.ciphertext);
        }, _parse: function(e3, t3) {
          return "string" == typeof e3 ? t3.parse(e3, this) : e3;
        } })), f2 = (f2.kdf = {}).OpenSSL = { execute: function(e3, t3, n3, o3) {
          return o3 || (o3 = r2.random(8)), e3 = s2.create({ keySize: t3 + n3 }).compute(e3, o3), n3 = r2.create(e3.words.slice(t3), 4 * n3), e3.sigBytes = 4 * t3, p2.create({ key: e3, iv: n3, salt: o3 });
        } }, d2 = t2.PasswordBasedCipher = h2.extend({ cfg: h2.cfg.extend({ kdf: f2 }), encrypt: function(e3, t3, n3, r3) {
          return n3 = (r3 = this.cfg.extend(r3)).kdf.execute(n3, e3.keySize, e3.ivSize), r3.iv = n3.iv, (e3 = h2.encrypt.call(this, e3, t3, n3.key, r3)).mixIn(n3), e3;
        }, decrypt: function(e3, t3, n3, r3) {
          return r3 = this.cfg.extend(r3), t3 = this._parse(t3, r3.format), n3 = r3.kdf.execute(n3, e3.keySize, e3.ivSize, t3.salt), r3.iv = n3.iv, h2.decrypt.call(this, e3, t3, n3.key, r3);
        } });
      }(), function() {
        for (var e2 = P, t2 = e2.lib.BlockCipher, n2 = e2.algo, r2 = [], o2 = [], i2 = [], s2 = [], a2 = [], u2 = [], c2 = [], l2 = [], p2 = [], h2 = [], f2 = [], d2 = 0; 256 > d2; d2++) f2[d2] = 128 > d2 ? d2 << 1 : d2 << 1 ^ 283;
        var y2 = 0, g2 = 0;
        for (d2 = 0; 256 > d2; d2++) {
          var m2 = (m2 = g2 ^ g2 << 1 ^ g2 << 2 ^ g2 << 3 ^ g2 << 4) >>> 8 ^ 255 & m2 ^ 99;
          r2[y2] = m2, o2[m2] = y2;
          var b2 = f2[y2], v2 = f2[b2], _2 = f2[v2], S2 = 257 * f2[m2] ^ 16843008 * m2;
          i2[y2] = S2 << 24 | S2 >>> 8, s2[y2] = S2 << 16 | S2 >>> 16, a2[y2] = S2 << 8 | S2 >>> 24, u2[y2] = S2, S2 = 16843009 * _2 ^ 65537 * v2 ^ 257 * b2 ^ 16843008 * y2, c2[m2] = S2 << 24 | S2 >>> 8, l2[m2] = S2 << 16 | S2 >>> 16, p2[m2] = S2 << 8 | S2 >>> 24, h2[m2] = S2, y2 ? (y2 = b2 ^ f2[f2[f2[_2 ^ b2]]], g2 ^= f2[f2[g2]]) : y2 = g2 = 1;
        }
        var w2 = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        n2 = n2.AES = t2.extend({ _doReset: function() {
          for (var e3 = (n3 = this._key).words, t3 = n3.sigBytes / 4, n3 = 4 * ((this._nRounds = t3 + 6) + 1), o3 = this._keySchedule = [], i3 = 0; i3 < n3; i3++) if (i3 < t3) o3[i3] = e3[i3];
          else {
            var s3 = o3[i3 - 1];
            i3 % t3 ? 6 < t3 && 4 == i3 % t3 && (s3 = r2[s3 >>> 24] << 24 | r2[s3 >>> 16 & 255] << 16 | r2[s3 >>> 8 & 255] << 8 | r2[255 & s3]) : (s3 = r2[(s3 = s3 << 8 | s3 >>> 24) >>> 24] << 24 | r2[s3 >>> 16 & 255] << 16 | r2[s3 >>> 8 & 255] << 8 | r2[255 & s3], s3 ^= w2[i3 / t3 | 0] << 24), o3[i3] = o3[i3 - t3] ^ s3;
          }
          for (e3 = this._invKeySchedule = [], t3 = 0; t3 < n3; t3++) i3 = n3 - t3, s3 = t3 % 4 ? o3[i3] : o3[i3 - 4], e3[t3] = 4 > t3 || 4 >= i3 ? s3 : c2[r2[s3 >>> 24]] ^ l2[r2[s3 >>> 16 & 255]] ^ p2[r2[s3 >>> 8 & 255]] ^ h2[r2[255 & s3]];
        }, encryptBlock: function(e3, t3) {
          this._doCryptBlock(e3, t3, this._keySchedule, i2, s2, a2, u2, r2);
        }, decryptBlock: function(e3, t3) {
          var n3 = e3[t3 + 1];
          e3[t3 + 1] = e3[t3 + 3], e3[t3 + 3] = n3, this._doCryptBlock(e3, t3, this._invKeySchedule, c2, l2, p2, h2, o2), n3 = e3[t3 + 1], e3[t3 + 1] = e3[t3 + 3], e3[t3 + 3] = n3;
        }, _doCryptBlock: function(e3, t3, n3, r3, o3, i3, s3, a3) {
          for (var u3 = this._nRounds, c3 = e3[t3] ^ n3[0], l3 = e3[t3 + 1] ^ n3[1], p3 = e3[t3 + 2] ^ n3[2], h3 = e3[t3 + 3] ^ n3[3], f3 = 4, d3 = 1; d3 < u3; d3++) {
            var y3 = r3[c3 >>> 24] ^ o3[l3 >>> 16 & 255] ^ i3[p3 >>> 8 & 255] ^ s3[255 & h3] ^ n3[f3++], g3 = r3[l3 >>> 24] ^ o3[p3 >>> 16 & 255] ^ i3[h3 >>> 8 & 255] ^ s3[255 & c3] ^ n3[f3++], m3 = r3[p3 >>> 24] ^ o3[h3 >>> 16 & 255] ^ i3[c3 >>> 8 & 255] ^ s3[255 & l3] ^ n3[f3++];
            h3 = r3[h3 >>> 24] ^ o3[c3 >>> 16 & 255] ^ i3[l3 >>> 8 & 255] ^ s3[255 & p3] ^ n3[f3++], c3 = y3, l3 = g3, p3 = m3;
          }
          y3 = (a3[c3 >>> 24] << 24 | a3[l3 >>> 16 & 255] << 16 | a3[p3 >>> 8 & 255] << 8 | a3[255 & h3]) ^ n3[f3++], g3 = (a3[l3 >>> 24] << 24 | a3[p3 >>> 16 & 255] << 16 | a3[h3 >>> 8 & 255] << 8 | a3[255 & c3]) ^ n3[f3++], m3 = (a3[p3 >>> 24] << 24 | a3[h3 >>> 16 & 255] << 16 | a3[c3 >>> 8 & 255] << 8 | a3[255 & l3]) ^ n3[f3++], h3 = (a3[h3 >>> 24] << 24 | a3[c3 >>> 16 & 255] << 16 | a3[l3 >>> 8 & 255] << 8 | a3[255 & p3]) ^ n3[f3++], e3[t3] = y3, e3[t3 + 1] = g3, e3[t3 + 2] = m3, e3[t3 + 3] = h3;
        }, keySize: 8 });
        e2.AES = t2._createHelper(n2);
      }(), P.mode.ECB = ((O = P.lib.BlockCipherMode.extend()).Encryptor = O.extend({ processBlock: function(e2, t2) {
        this._cipher.encryptBlock(e2, t2);
      } }), O.Decryptor = O.extend({ processBlock: function(e2, t2) {
        this._cipher.decryptBlock(e2, t2);
      } }), O);
      var E = P;
      function A(e2) {
        var t2, n2 = [];
        for (t2 = 0; t2 < e2.length; t2 += 1) n2[t2 / 4 | 0] |= e2[t2] << 24 - 8 * t2;
        return E.lib.WordArray.create(n2, e2.length);
      }
      var T = function() {
        function e2(e3) {
          var t2 = e3.config;
          this._config = t2, this._iv = "0123456789012345", this._allowedKeyEncodings = ["hex", "utf8", "base64", "binary"], this._allowedKeyLengths = [128, 256], this._allowedModes = ["ecb", "cbc"], this._defaultOptions = { encryptKey: true, keyEncoding: "utf8", keyLength: 256, mode: "cbc" };
        }
        return e2.prototype.HMACSHA256 = function(e3) {
          return E.HmacSHA256(e3, this._config.secretKey).toString(E.enc.Base64);
        }, e2.prototype.SHA256 = function(e3) {
          return E.SHA256(e3).toString(E.enc.Hex);
        }, e2.prototype._parseOptions = function(e3) {
          var t2 = e3 || {};
          return t2.hasOwnProperty("encryptKey") || (t2.encryptKey = this._defaultOptions.encryptKey), t2.hasOwnProperty("keyEncoding") || (t2.keyEncoding = this._defaultOptions.keyEncoding), t2.hasOwnProperty("keyLength") || (t2.keyLength = this._defaultOptions.keyLength), t2.hasOwnProperty("mode") || (t2.mode = this._defaultOptions.mode), -1 === this._allowedKeyEncodings.indexOf(t2.keyEncoding.toLowerCase()) && (t2.keyEncoding = this._defaultOptions.keyEncoding), -1 === this._allowedKeyLengths.indexOf(parseInt(t2.keyLength, 10)) && (t2.keyLength = this._defaultOptions.keyLength), -1 === this._allowedModes.indexOf(t2.mode.toLowerCase()) && (t2.mode = this._defaultOptions.mode), t2;
        }, e2.prototype._decodeKey = function(e3, t2) {
          return "base64" === t2.keyEncoding ? E.enc.Base64.parse(e3) : "hex" === t2.keyEncoding ? E.enc.Hex.parse(e3) : e3;
        }, e2.prototype._getPaddedKey = function(e3, t2) {
          return e3 = this._decodeKey(e3, t2), t2.encryptKey ? E.enc.Utf8.parse(this.SHA256(e3).slice(0, 32)) : e3;
        }, e2.prototype._getMode = function(e3) {
          return "ecb" === e3.mode ? E.mode.ECB : E.mode.CBC;
        }, e2.prototype._getIV = function(e3) {
          return "cbc" === e3.mode ? E.enc.Utf8.parse(this._iv) : null;
        }, e2.prototype._getRandomIV = function() {
          return E.lib.WordArray.random(16);
        }, e2.prototype.encrypt = function(e3, t2, n2) {
          return this._config.customEncrypt ? this._config.customEncrypt(e3) : this.pnEncrypt(e3, t2, n2);
        }, e2.prototype.decrypt = function(e3, t2, n2) {
          return this._config.customDecrypt ? this._config.customDecrypt(e3) : this.pnDecrypt(e3, t2, n2);
        }, e2.prototype.pnEncrypt = function(e3, t2, n2) {
          if (!t2 && !this._config.cipherKey) return e3;
          n2 = this._parseOptions(n2);
          var r2 = this._getMode(n2), o2 = this._getPaddedKey(t2 || this._config.cipherKey, n2);
          if (this._config.useRandomIVs) {
            var i2 = this._getRandomIV(), s2 = E.AES.encrypt(e3, o2, { iv: i2, mode: r2 }).ciphertext;
            return i2.clone().concat(s2.clone()).toString(E.enc.Base64);
          }
          var a2 = this._getIV(n2);
          return E.AES.encrypt(e3, o2, { iv: a2, mode: r2 }).ciphertext.toString(E.enc.Base64) || e3;
        }, e2.prototype.pnDecrypt = function(e3, t2, n2) {
          if (!t2 && !this._config.cipherKey) return e3;
          n2 = this._parseOptions(n2);
          var r2 = this._getMode(n2), o2 = this._getPaddedKey(t2 || this._config.cipherKey, n2);
          if (this._config.useRandomIVs) {
            var i2 = A((u2 = new Uint8ClampedArray(m(e3))).slice(0, 16)), s2 = A(u2.slice(16));
            try {
              var a2 = E.AES.decrypt({ ciphertext: s2 }, o2, { iv: i2, mode: r2 }).toString(E.enc.Utf8);
              return JSON.parse(a2);
            } catch (e4) {
              return null;
            }
          } else {
            i2 = this._getIV(n2);
            try {
              var u2 = E.enc.Base64.parse(e3);
              a2 = E.AES.decrypt({ ciphertext: u2 }, o2, { iv: i2, mode: r2 }).toString(E.enc.Utf8);
              return JSON.parse(a2);
            } catch (e4) {
              return null;
            }
          }
        }, e2;
      }(), N = function() {
        function e2(e3) {
          var t2 = e3.timeEndpoint;
          this._timeEndpoint = t2;
        }
        return e2.prototype.onReconnection = function(e3) {
          this._reconnectionCallback = e3;
        }, e2.prototype.startPolling = function() {
          this._timeTimer = setInterval(this._performTimeLoop.bind(this), 3e3);
        }, e2.prototype.stopPolling = function() {
          clearInterval(this._timeTimer);
        }, e2.prototype._performTimeLoop = function() {
          var e3 = this;
          this._timeEndpoint(function(t2) {
            t2.error || (clearInterval(e3._timeTimer), e3._reconnectionCallback());
          });
        }, e2;
      }(), C = function() {
        function e2(e3) {
          var t2 = e3.config;
          this.hashHistory = [], this._config = t2;
        }
        return e2.prototype.getKey = function(e3) {
          var t2 = function(e4) {
            var t3 = 0;
            if (0 === e4.length) return t3;
            for (var n3 = 0; n3 < e4.length; n3 += 1) t3 = (t3 << 5) - t3 + e4.charCodeAt(n3), t3 &= t3;
            return t3;
          }(JSON.stringify(e3.payload)).toString(), n2 = e3.publishMetaData.publishTimetoken;
          return "".concat(n2, "-").concat(t2);
        }, e2.prototype.isDuplicate = function(e3) {
          return this.hashHistory.includes(this.getKey(e3));
        }, e2.prototype.addEntry = function(e3) {
          this.hashHistory.length >= this._config.maximumCacheSize && this.hashHistory.shift(), this.hashHistory.push(this.getKey(e3));
        }, e2.prototype.clearHistory = function() {
          this.hashHistory = [];
        }, e2;
      }(), k = { PNNetworkUpCategory: "PNNetworkUpCategory", PNNetworkDownCategory: "PNNetworkDownCategory", PNNetworkIssuesCategory: "PNNetworkIssuesCategory", PNTimeoutCategory: "PNTimeoutCategory", PNBadRequestCategory: "PNBadRequestCategory", PNAccessDeniedCategory: "PNAccessDeniedCategory", PNUnknownCategory: "PNUnknownCategory", PNReconnectedCategory: "PNReconnectedCategory", PNConnectedCategory: "PNConnectedCategory", PNRequestMessageCountExceededCategory: "PNRequestMessageCountExceededCategory", PNDisconnectedCategory: "PNDisconnectedCategory", PNConnectionErrorCategory: "PNConnectionErrorCategory", PNDisconnectedUnexpectedlyCategory: "PNDisconnectedUnexpectedlyCategory" }, M = function() {
        function e2(e3) {
          var t2 = e3.subscribeEndpoint, n2 = e3.leaveEndpoint, r2 = e3.heartbeatEndpoint, o2 = e3.setStateEndpoint, i2 = e3.timeEndpoint, s2 = e3.getFileUrl, a2 = e3.config, u2 = e3.crypto, c2 = e3.listenerManager, l2 = e3.cryptoModule, p2 = e3.eventEmitter;
          this._listenerManager = c2, this._config = a2, this._leaveEndpoint = n2, this._heartbeatEndpoint = r2, this._setStateEndpoint = o2, this._subscribeEndpoint = t2, this._getFileUrl = s2, this._crypto = u2, this._cryptoModule = l2, this._channels = {}, this._presenceChannels = {}, this._heartbeatChannels = {}, this._heartbeatChannelGroups = {}, this._channelGroups = {}, this._presenceChannelGroups = {}, this._pendingChannelSubscriptions = [], this._pendingChannelGroupSubscriptions = [], this._currentTimetoken = 0, this._lastTimetoken = 0, this._storedTimetoken = null, this._subscriptionStatusAnnounced = false, this._isOnline = true, this._reconnectionManager = new N({ timeEndpoint: i2 }), this._dedupingManager = new C({ config: a2 }), this._cryptoModule && (this._decoder = new TextDecoder()), this._eventEmitter = p2;
        }
        return e2.prototype.adaptStateChange = function(e3, t2) {
          var n2 = this, r2 = e3.state, o2 = e3.channels, i2 = void 0 === o2 ? [] : o2, s2 = e3.channelGroups, a2 = void 0 === s2 ? [] : s2, u2 = e3.withHeartbeat, c2 = void 0 !== u2 && u2;
          if (i2.forEach(function(e4) {
            e4 in n2._channels && (n2._channels[e4].state = r2);
          }), a2.forEach(function(e4) {
            e4 in n2._channelGroups && (n2._channelGroups[e4].state = r2);
          }), c2) {
            var l2 = {};
            return i2.forEach(function(e4) {
              return l2[e4] = r2;
            }), a2.forEach(function(e4) {
              return l2[e4] = r2;
            }), this._heartbeatEndpoint({ channels: i2, channelGroups: a2, state: l2 }, t2);
          }
          return this._setStateEndpoint({ state: r2, channels: i2, channelGroups: a2 }, t2);
        }, e2.prototype.adaptPresenceChange = function(e3) {
          var t2 = this, n2 = e3.connected, r2 = e3.channels, o2 = void 0 === r2 ? [] : r2, i2 = e3.channelGroups, s2 = void 0 === i2 ? [] : i2;
          n2 ? (o2.forEach(function(e4) {
            t2._heartbeatChannels[e4] = { state: {} };
          }), s2.forEach(function(e4) {
            t2._heartbeatChannelGroups[e4] = { state: {} };
          })) : (o2.forEach(function(e4) {
            e4 in t2._heartbeatChannels && delete t2._heartbeatChannels[e4];
          }), s2.forEach(function(e4) {
            e4 in t2._heartbeatChannelGroups && delete t2._heartbeatChannelGroups[e4];
          }), false === this._config.suppressLeaveEvents && this._leaveEndpoint({ channels: o2, channelGroups: s2 }, function(e4) {
            t2._listenerManager.announceStatus(e4);
          })), this.reconnect();
        }, e2.prototype.adaptSubscribeChange = function(e3) {
          var t2 = this, n2 = e3.timetoken, r2 = e3.channels, o2 = void 0 === r2 ? [] : r2, i2 = e3.channelGroups, s2 = void 0 === i2 ? [] : i2, a2 = e3.withPresence, u2 = void 0 !== a2 && a2, c2 = e3.withHeartbeats, l2 = void 0 !== c2 && c2;
          this._config.subscribeKey && "" !== this._config.subscribeKey ? (n2 && (this._lastTimetoken = this._currentTimetoken, this._currentTimetoken = n2), "0" !== this._currentTimetoken && 0 !== this._currentTimetoken && (this._storedTimetoken = this._currentTimetoken, this._currentTimetoken = 0), o2.forEach(function(e4) {
            t2._channels[e4] = { state: {} }, u2 && (t2._presenceChannels[e4] = {}), (l2 || t2._config.getHeartbeatInterval()) && (t2._heartbeatChannels[e4] = {}), t2._pendingChannelSubscriptions.push(e4);
          }), s2.forEach(function(e4) {
            t2._channelGroups[e4] = { state: {} }, u2 && (t2._presenceChannelGroups[e4] = {}), (l2 || t2._config.getHeartbeatInterval()) && (t2._heartbeatChannelGroups[e4] = {}), t2._pendingChannelGroupSubscriptions.push(e4);
          }), this._subscriptionStatusAnnounced = false, this.reconnect()) : console && console.log && console.log("subscribe key missing; aborting subscribe");
        }, e2.prototype.adaptUnsubscribeChange = function(e3, t2) {
          var n2 = this, r2 = e3.channels, o2 = void 0 === r2 ? [] : r2, i2 = e3.channelGroups, s2 = void 0 === i2 ? [] : i2, a2 = [], u2 = [];
          o2.forEach(function(e4) {
            e4 in n2._channels && (delete n2._channels[e4], a2.push(e4), e4 in n2._heartbeatChannels && delete n2._heartbeatChannels[e4]), e4 in n2._presenceChannels && (delete n2._presenceChannels[e4], a2.push(e4));
          }), s2.forEach(function(e4) {
            e4 in n2._channelGroups && (delete n2._channelGroups[e4], u2.push(e4), e4 in n2._heartbeatChannelGroups && delete n2._heartbeatChannelGroups[e4]), e4 in n2._presenceChannelGroups && (delete n2._presenceChannelGroups[e4], u2.push(e4));
          }), 0 === a2.length && 0 === u2.length || (false !== this._config.suppressLeaveEvents || t2 || this._leaveEndpoint({ channels: a2, channelGroups: u2 }, function(e4) {
            e4.affectedChannels = a2, e4.affectedChannelGroups = u2, e4.currentTimetoken = n2._currentTimetoken, e4.lastTimetoken = n2._lastTimetoken, n2._listenerManager.announceStatus(e4);
          }), 0 === Object.keys(this._channels).length && 0 === Object.keys(this._presenceChannels).length && 0 === Object.keys(this._channelGroups).length && 0 === Object.keys(this._presenceChannelGroups).length && (this._lastTimetoken = 0, this._currentTimetoken = 0, this._storedTimetoken = null, this._region = null, this._reconnectionManager.stopPolling()), this.reconnect());
        }, e2.prototype.unsubscribeAll = function(e3) {
          this.adaptUnsubscribeChange({ channels: this.getSubscribedChannels(), channelGroups: this.getSubscribedChannelGroups() }, e3);
        }, e2.prototype.getHeartbeatChannels = function() {
          return Object.keys(this._heartbeatChannels);
        }, e2.prototype.getHeartbeatChannelGroups = function() {
          return Object.keys(this._heartbeatChannelGroups);
        }, e2.prototype.getSubscribedChannels = function() {
          return Object.keys(this._channels);
        }, e2.prototype.getSubscribedChannelGroups = function() {
          return Object.keys(this._channelGroups);
        }, e2.prototype.reconnect = function() {
          this._startSubscribeLoop(), this._registerHeartbeatTimer();
        }, e2.prototype.disconnect = function() {
          this._stopSubscribeLoop(), this._stopHeartbeatTimer(), this._reconnectionManager.stopPolling();
        }, e2.prototype._registerHeartbeatTimer = function() {
          this._stopHeartbeatTimer(), 0 !== this._config.getHeartbeatInterval() && void 0 !== this._config.getHeartbeatInterval() && (this._performHeartbeatLoop(), this._heartbeatTimer = setInterval(this._performHeartbeatLoop.bind(this), 1e3 * this._config.getHeartbeatInterval()));
        }, e2.prototype._stopHeartbeatTimer = function() {
          this._heartbeatTimer && (clearInterval(this._heartbeatTimer), this._heartbeatTimer = null);
        }, e2.prototype._performHeartbeatLoop = function() {
          var e3 = this, t2 = this.getHeartbeatChannels(), n2 = this.getHeartbeatChannelGroups(), r2 = {};
          if (0 !== t2.length || 0 !== n2.length) {
            this.getSubscribedChannels().forEach(function(t3) {
              var n3 = e3._channels[t3].state;
              Object.keys(n3).length && (r2[t3] = n3);
            }), this.getSubscribedChannelGroups().forEach(function(t3) {
              var n3 = e3._channelGroups[t3].state;
              Object.keys(n3).length && (r2[t3] = n3);
            });
            this._heartbeatEndpoint({ channels: t2, channelGroups: n2, state: r2 }, (function(t3) {
              t3.error && e3._config.announceFailedHeartbeats && e3._listenerManager.announceStatus(t3), t3.error && e3._config.autoNetworkDetection && e3._isOnline && (e3._isOnline = false, e3.disconnect(), e3._listenerManager.announceNetworkDown(), e3.reconnect()), !t3.error && e3._config.announceSuccessfulHeartbeats && e3._listenerManager.announceStatus(t3);
            }).bind(this));
          }
        }, e2.prototype._startSubscribeLoop = function() {
          var e3 = this;
          this._stopSubscribeLoop();
          var t2 = {}, n2 = [], r2 = [];
          if (Object.keys(this._channels).forEach(function(r3) {
            var o3 = e3._channels[r3].state;
            Object.keys(o3).length && (t2[r3] = o3), n2.push(r3);
          }), Object.keys(this._presenceChannels).forEach(function(e4) {
            n2.push("".concat(e4, "-pnpres"));
          }), Object.keys(this._channelGroups).forEach(function(n3) {
            var o3 = e3._channelGroups[n3].state;
            Object.keys(o3).length && (t2[n3] = o3), r2.push(n3);
          }), Object.keys(this._presenceChannelGroups).forEach(function(e4) {
            r2.push("".concat(e4, "-pnpres"));
          }), 0 !== n2.length || 0 !== r2.length) {
            var o2 = { channels: n2, channelGroups: r2, state: t2, timetoken: this._currentTimetoken, filterExpression: this._config.filterExpression, region: this._region };
            this._subscribeCall = this._subscribeEndpoint(o2, this._processSubscribeResponse.bind(this));
          }
        }, e2.prototype._processSubscribeResponse = function(e3, t2) {
          var n2 = this;
          if (e3.error) {
            if (e3.errorData && "Aborted" === e3.errorData.message) return;
            e3.category === k.PNTimeoutCategory ? this._startSubscribeLoop() : e3.category === k.PNNetworkIssuesCategory ? (this.disconnect(), e3.error && this._config.autoNetworkDetection && this._isOnline && (this._isOnline = false, this._listenerManager.announceNetworkDown()), this._reconnectionManager.onReconnection(function() {
              n2._config.autoNetworkDetection && !n2._isOnline && (n2._isOnline = true, n2._listenerManager.announceNetworkUp()), n2.reconnect(), n2._subscriptionStatusAnnounced = true;
              var t3 = { category: k.PNReconnectedCategory, operation: e3.operation, lastTimetoken: n2._lastTimetoken, currentTimetoken: n2._currentTimetoken };
              n2._listenerManager.announceStatus(t3);
            }), this._reconnectionManager.startPolling(), this._listenerManager.announceStatus(e3)) : e3.category === k.PNBadRequestCategory ? (this._stopHeartbeatTimer(), this._listenerManager.announceStatus(e3)) : this._listenerManager.announceStatus(e3);
          } else {
            if (this._storedTimetoken ? (this._currentTimetoken = this._storedTimetoken, this._storedTimetoken = null) : (this._lastTimetoken = this._currentTimetoken, this._currentTimetoken = t2.metadata.timetoken), !this._subscriptionStatusAnnounced) {
              var r2 = {};
              r2.category = k.PNConnectedCategory, r2.operation = e3.operation, r2.affectedChannels = this._pendingChannelSubscriptions, r2.subscribedChannels = this.getSubscribedChannels(), r2.affectedChannelGroups = this._pendingChannelGroupSubscriptions, r2.lastTimetoken = this._lastTimetoken, r2.currentTimetoken = this._currentTimetoken, this._subscriptionStatusAnnounced = true, this._listenerManager.announceStatus(r2), this._pendingChannelSubscriptions = [], this._pendingChannelGroupSubscriptions = [];
            }
            var o2 = t2.messages || [], i2 = this._config, s2 = i2.requestMessageCountThreshold, a2 = i2.dedupeOnSubscribe;
            if (s2 && o2.length >= s2) {
              var u2 = {};
              u2.category = k.PNRequestMessageCountExceededCategory, u2.operation = e3.operation, this._listenerManager.announceStatus(u2);
            }
            o2.forEach(function(e4) {
              if (e4.channel, e4.subscriptionMatch, a2) {
                if (n2._dedupingManager.isDuplicate(e4)) return;
                n2._dedupingManager.addEntry(e4);
              }
              n2._eventEmitter.emitEvent(e4);
            }), this._region = t2.metadata.region, this._startSubscribeLoop();
          }
        }, e2.prototype._stopSubscribeLoop = function() {
          this._subscribeCall && ("function" == typeof this._subscribeCall.abort && this._subscribeCall.abort(), this._subscribeCall = null);
        }, e2.prototype._renameEvent = function(e3) {
          return "set" === e3 ? "updated" : "removed";
        }, e2.prototype._renameChannelField = function(e3) {
          var t2 = e3.channel, n2 = r(e3, ["channel"]);
          return n2.spaceId = t2, n2;
        }, e2;
      }(), j = { PNTimeOperation: "PNTimeOperation", PNHistoryOperation: "PNHistoryOperation", PNDeleteMessagesOperation: "PNDeleteMessagesOperation", PNFetchMessagesOperation: "PNFetchMessagesOperation", PNMessageCounts: "PNMessageCountsOperation", PNSubscribeOperation: "PNSubscribeOperation", PNUnsubscribeOperation: "PNUnsubscribeOperation", PNPublishOperation: "PNPublishOperation", PNSignalOperation: "PNSignalOperation", PNAddMessageActionOperation: "PNAddActionOperation", PNRemoveMessageActionOperation: "PNRemoveMessageActionOperation", PNGetMessageActionsOperation: "PNGetMessageActionsOperation", PNCreateUserOperation: "PNCreateUserOperation", PNUpdateUserOperation: "PNUpdateUserOperation", PNDeleteUserOperation: "PNDeleteUserOperation", PNGetUserOperation: "PNGetUsersOperation", PNGetUsersOperation: "PNGetUsersOperation", PNCreateSpaceOperation: "PNCreateSpaceOperation", PNUpdateSpaceOperation: "PNUpdateSpaceOperation", PNDeleteSpaceOperation: "PNDeleteSpaceOperation", PNGetSpaceOperation: "PNGetSpacesOperation", PNGetSpacesOperation: "PNGetSpacesOperation", PNGetMembersOperation: "PNGetMembersOperation", PNUpdateMembersOperation: "PNUpdateMembersOperation", PNGetMembershipsOperation: "PNGetMembershipsOperation", PNUpdateMembershipsOperation: "PNUpdateMembershipsOperation", PNListFilesOperation: "PNListFilesOperation", PNGenerateUploadUrlOperation: "PNGenerateUploadUrlOperation", PNPublishFileOperation: "PNPublishFileOperation", PNGetFileUrlOperation: "PNGetFileUrlOperation", PNDownloadFileOperation: "PNDownloadFileOperation", PNGetAllUUIDMetadataOperation: "PNGetAllUUIDMetadataOperation", PNGetUUIDMetadataOperation: "PNGetUUIDMetadataOperation", PNSetUUIDMetadataOperation: "PNSetUUIDMetadataOperation", PNRemoveUUIDMetadataOperation: "PNRemoveUUIDMetadataOperation", PNGetAllChannelMetadataOperation: "PNGetAllChannelMetadataOperation", PNGetChannelMetadataOperation: "PNGetChannelMetadataOperation", PNSetChannelMetadataOperation: "PNSetChannelMetadataOperation", PNRemoveChannelMetadataOperation: "PNRemoveChannelMetadataOperation", PNSetMembersOperation: "PNSetMembersOperation", PNSetMembershipsOperation: "PNSetMembershipsOperation", PNPushNotificationEnabledChannelsOperation: "PNPushNotificationEnabledChannelsOperation", PNRemoveAllPushNotificationsOperation: "PNRemoveAllPushNotificationsOperation", PNWhereNowOperation: "PNWhereNowOperation", PNSetStateOperation: "PNSetStateOperation", PNHereNowOperation: "PNHereNowOperation", PNGetStateOperation: "PNGetStateOperation", PNHeartbeatOperation: "PNHeartbeatOperation", PNChannelGroupsOperation: "PNChannelGroupsOperation", PNRemoveGroupOperation: "PNRemoveGroupOperation", PNChannelsForGroupOperation: "PNChannelsForGroupOperation", PNAddChannelsToGroupOperation: "PNAddChannelsToGroupOperation", PNRemoveChannelsFromGroupOperation: "PNRemoveChannelsFromGroupOperation", PNAccessManagerGrant: "PNAccessManagerGrant", PNAccessManagerGrantToken: "PNAccessManagerGrantToken", PNAccessManagerAudit: "PNAccessManagerAudit", PNAccessManagerRevokeToken: "PNAccessManagerRevokeToken", PNHandshakeOperation: "PNHandshakeOperation", PNReceiveMessagesOperation: "PNReceiveMessagesOperation" }, R = function() {
        function e2(e3) {
          this._maximumSamplesCount = 100, this._trackedLatencies = {}, this._latencies = {}, this._telemetryExcludeOperations = [j.PNSubscribeOperation, j.PNReceiveMessagesOperation, j.PNHandshakeOperation], this._maximumSamplesCount = e3.maximumSamplesCount || this._maximumSamplesCount;
        }
        return e2.prototype.operationsLatencyForRequest = function() {
          var e3 = this, t2 = {};
          return Object.keys(this._latencies).forEach(function(n2) {
            var r2 = e3._latencies[n2], o2 = e3._averageLatency(r2);
            o2 > 0 && (t2["l_".concat(n2)] = o2);
          }), t2;
        }, e2.prototype.startLatencyMeasure = function(e3, t2) {
          !this._telemetryExcludeOperations.includes(e3) && t2 && (this._trackedLatencies[t2] = Date.now());
        }, e2.prototype.stopLatencyMeasure = function(e3, t2) {
          if (!this._telemetryExcludeOperations.includes(e3) && t2) {
            var n2 = this._endpointName(e3), r2 = this._latencies[n2], o2 = this._trackedLatencies[t2];
            r2 || (this._latencies[n2] = [], r2 = this._latencies[n2]), r2.push(Date.now() - o2), r2.length > this._maximumSamplesCount && r2.splice(0, r2.length - this._maximumSamplesCount), delete this._trackedLatencies[t2];
          }
        }, e2.prototype._averageLatency = function(e3) {
          return Math.floor(e3.reduce(function(e4, t2) {
            return e4 + t2;
          }, 0) / e3.length);
        }, e2.prototype._endpointName = function(e3) {
          var t2 = null;
          switch (e3) {
            case j.PNPublishOperation:
              t2 = "pub";
              break;
            case j.PNSignalOperation:
              t2 = "sig";
              break;
            case j.PNHistoryOperation:
            case j.PNFetchMessagesOperation:
            case j.PNDeleteMessagesOperation:
            case j.PNMessageCounts:
              t2 = "hist";
              break;
            case j.PNUnsubscribeOperation:
            case j.PNWhereNowOperation:
            case j.PNHereNowOperation:
            case j.PNHeartbeatOperation:
            case j.PNSetStateOperation:
            case j.PNGetStateOperation:
              t2 = "pres";
              break;
            case j.PNAddChannelsToGroupOperation:
            case j.PNRemoveChannelsFromGroupOperation:
            case j.PNChannelGroupsOperation:
            case j.PNRemoveGroupOperation:
            case j.PNChannelsForGroupOperation:
              t2 = "cg";
              break;
            case j.PNPushNotificationEnabledChannelsOperation:
            case j.PNRemoveAllPushNotificationsOperation:
              t2 = "push";
              break;
            case j.PNCreateUserOperation:
            case j.PNUpdateUserOperation:
            case j.PNDeleteUserOperation:
            case j.PNGetUserOperation:
            case j.PNGetUsersOperation:
            case j.PNCreateSpaceOperation:
            case j.PNUpdateSpaceOperation:
            case j.PNDeleteSpaceOperation:
            case j.PNGetSpaceOperation:
            case j.PNGetSpacesOperation:
            case j.PNGetMembersOperation:
            case j.PNUpdateMembersOperation:
            case j.PNGetMembershipsOperation:
            case j.PNUpdateMembershipsOperation:
              t2 = "obj";
              break;
            case j.PNAddMessageActionOperation:
            case j.PNRemoveMessageActionOperation:
            case j.PNGetMessageActionsOperation:
              t2 = "msga";
              break;
            case j.PNAccessManagerGrant:
            case j.PNAccessManagerAudit:
              t2 = "pam";
              break;
            case j.PNAccessManagerGrantToken:
            case j.PNAccessManagerRevokeToken:
              t2 = "pamv3";
              break;
            default:
              t2 = "time";
          }
          return t2;
        }, e2;
      }(), x = function() {
        function e2(e3, t2, n2) {
          this._payload = e3, this._setDefaultPayloadStructure(), this.title = t2, this.body = n2;
        }
        return Object.defineProperty(e2.prototype, "payload", { get: function() {
          return this._payload;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "title", { set: function(e3) {
          this._title = e3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "subtitle", { set: function(e3) {
          this._subtitle = e3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "body", { set: function(e3) {
          this._body = e3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "badge", { set: function(e3) {
          this._badge = e3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "sound", { set: function(e3) {
          this._sound = e3;
        }, enumerable: false, configurable: true }), e2.prototype._setDefaultPayloadStructure = function() {
        }, e2.prototype.toObject = function() {
          return {};
        }, e2;
      }(), U = function(e2) {
        function r2() {
          return null !== e2 && e2.apply(this, arguments) || this;
        }
        return t(r2, e2), Object.defineProperty(r2.prototype, "configurations", { set: function(e3) {
          e3 && e3.length && (this._configurations = e3);
        }, enumerable: false, configurable: true }), Object.defineProperty(r2.prototype, "notification", { get: function() {
          return this._payload.aps;
        }, enumerable: false, configurable: true }), Object.defineProperty(r2.prototype, "title", { get: function() {
          return this._title;
        }, set: function(e3) {
          e3 && e3.length && (this._payload.aps.alert.title = e3, this._title = e3);
        }, enumerable: false, configurable: true }), Object.defineProperty(r2.prototype, "subtitle", { get: function() {
          return this._subtitle;
        }, set: function(e3) {
          e3 && e3.length && (this._payload.aps.alert.subtitle = e3, this._subtitle = e3);
        }, enumerable: false, configurable: true }), Object.defineProperty(r2.prototype, "body", { get: function() {
          return this._body;
        }, set: function(e3) {
          e3 && e3.length && (this._payload.aps.alert.body = e3, this._body = e3);
        }, enumerable: false, configurable: true }), Object.defineProperty(r2.prototype, "badge", { get: function() {
          return this._badge;
        }, set: function(e3) {
          null != e3 && (this._payload.aps.badge = e3, this._badge = e3);
        }, enumerable: false, configurable: true }), Object.defineProperty(r2.prototype, "sound", { get: function() {
          return this._sound;
        }, set: function(e3) {
          e3 && e3.length && (this._payload.aps.sound = e3, this._sound = e3);
        }, enumerable: false, configurable: true }), Object.defineProperty(r2.prototype, "silent", { set: function(e3) {
          this._isSilent = e3;
        }, enumerable: false, configurable: true }), r2.prototype._setDefaultPayloadStructure = function() {
          this._payload.aps = { alert: {} };
        }, r2.prototype.toObject = function() {
          var e3 = this, t2 = n({}, this._payload), r3 = t2.aps, o2 = r3.alert;
          if (this._isSilent && (r3["content-available"] = 1), "apns2" === this._apnsPushType) {
            if (!this._configurations || !this._configurations.length) throw new ReferenceError("APNS2 configuration is missing");
            var i2 = [];
            this._configurations.forEach(function(t3) {
              i2.push(e3._objectFromAPNS2Configuration(t3));
            }), i2.length && (t2.pn_push = i2);
          }
          return o2 && Object.keys(o2).length || delete r3.alert, this._isSilent && (delete r3.alert, delete r3.badge, delete r3.sound, o2 = {}), this._isSilent || Object.keys(o2).length ? t2 : null;
        }, r2.prototype._objectFromAPNS2Configuration = function(e3) {
          var t2 = this;
          if (!e3.targets || !e3.targets.length) throw new ReferenceError("At least one APNS2 target should be provided");
          var n2 = [];
          e3.targets.forEach(function(e4) {
            n2.push(t2._objectFromAPNSTarget(e4));
          });
          var r3 = e3.collapseId, o2 = e3.expirationDate, i2 = { auth_method: "token", targets: n2, version: "v2" };
          return r3 && r3.length && (i2.collapse_id = r3), o2 && (i2.expiration = o2.toISOString()), i2;
        }, r2.prototype._objectFromAPNSTarget = function(e3) {
          if (!e3.topic || !e3.topic.length) throw new TypeError("Target 'topic' undefined.");
          var t2 = e3.topic, n2 = e3.environment, r3 = void 0 === n2 ? "development" : n2, o2 = e3.excludedDevices, i2 = void 0 === o2 ? [] : o2, s2 = { topic: t2, environment: r3 };
          return i2.length && (s2.excluded_devices = i2), s2;
        }, r2;
      }(x), I = function(e2) {
        function r2() {
          return null !== e2 && e2.apply(this, arguments) || this;
        }
        return t(r2, e2), Object.defineProperty(r2.prototype, "backContent", { get: function() {
          return this._backContent;
        }, set: function(e3) {
          e3 && e3.length && (this._payload.back_content = e3, this._backContent = e3);
        }, enumerable: false, configurable: true }), Object.defineProperty(r2.prototype, "backTitle", { get: function() {
          return this._backTitle;
        }, set: function(e3) {
          e3 && e3.length && (this._payload.back_title = e3, this._backTitle = e3);
        }, enumerable: false, configurable: true }), Object.defineProperty(r2.prototype, "count", { get: function() {
          return this._count;
        }, set: function(e3) {
          null != e3 && (this._payload.count = e3, this._count = e3);
        }, enumerable: false, configurable: true }), Object.defineProperty(r2.prototype, "title", { get: function() {
          return this._title;
        }, set: function(e3) {
          e3 && e3.length && (this._payload.title = e3, this._title = e3);
        }, enumerable: false, configurable: true }), Object.defineProperty(r2.prototype, "type", { get: function() {
          return this._type;
        }, set: function(e3) {
          e3 && e3.length && (this._payload.type = e3, this._type = e3);
        }, enumerable: false, configurable: true }), Object.defineProperty(r2.prototype, "subtitle", { get: function() {
          return this.backTitle;
        }, set: function(e3) {
          this.backTitle = e3;
        }, enumerable: false, configurable: true }), Object.defineProperty(r2.prototype, "body", { get: function() {
          return this.backContent;
        }, set: function(e3) {
          this.backContent = e3;
        }, enumerable: false, configurable: true }), Object.defineProperty(r2.prototype, "badge", { get: function() {
          return this.count;
        }, set: function(e3) {
          this.count = e3;
        }, enumerable: false, configurable: true }), r2.prototype.toObject = function() {
          return Object.keys(this._payload).length ? n({}, this._payload) : null;
        }, r2;
      }(x), D = function(e2) {
        function o2() {
          return null !== e2 && e2.apply(this, arguments) || this;
        }
        return t(o2, e2), Object.defineProperty(o2.prototype, "notification", { get: function() {
          return this._payload.notification;
        }, enumerable: false, configurable: true }), Object.defineProperty(o2.prototype, "data", { get: function() {
          return this._payload.data;
        }, enumerable: false, configurable: true }), Object.defineProperty(o2.prototype, "title", { get: function() {
          return this._title;
        }, set: function(e3) {
          e3 && e3.length && (this._payload.notification.title = e3, this._title = e3);
        }, enumerable: false, configurable: true }), Object.defineProperty(o2.prototype, "body", { get: function() {
          return this._body;
        }, set: function(e3) {
          e3 && e3.length && (this._payload.notification.body = e3, this._body = e3);
        }, enumerable: false, configurable: true }), Object.defineProperty(o2.prototype, "sound", { get: function() {
          return this._sound;
        }, set: function(e3) {
          e3 && e3.length && (this._payload.notification.sound = e3, this._sound = e3);
        }, enumerable: false, configurable: true }), Object.defineProperty(o2.prototype, "icon", { get: function() {
          return this._icon;
        }, set: function(e3) {
          e3 && e3.length && (this._payload.notification.icon = e3, this._icon = e3);
        }, enumerable: false, configurable: true }), Object.defineProperty(o2.prototype, "tag", { get: function() {
          return this._tag;
        }, set: function(e3) {
          e3 && e3.length && (this._payload.notification.tag = e3, this._tag = e3);
        }, enumerable: false, configurable: true }), Object.defineProperty(o2.prototype, "silent", { set: function(e3) {
          this._isSilent = e3;
        }, enumerable: false, configurable: true }), o2.prototype._setDefaultPayloadStructure = function() {
          this._payload.notification = {}, this._payload.data = {};
        }, o2.prototype.toObject = function() {
          var e3 = n({}, this._payload.data), t2 = null, o3 = {};
          if (Object.keys(this._payload).length > 2) {
            var i2 = this._payload;
            i2.notification, i2.data;
            var s2 = r(i2, ["notification", "data"]);
            e3 = n(n({}, e3), s2);
          }
          return this._isSilent ? e3.notification = this._payload.notification : t2 = this._payload.notification, Object.keys(e3).length && (o3.data = e3), t2 && Object.keys(t2).length && (o3.notification = t2), Object.keys(o3).length ? o3 : null;
        }, o2;
      }(x), F = function() {
        function e2(e3, t2) {
          this._payload = { apns: {}, mpns: {}, fcm: {} }, this._title = e3, this._body = t2, this.apns = new U(this._payload.apns, e3, t2), this.mpns = new I(this._payload.mpns, e3, t2), this.fcm = new D(this._payload.fcm, e3, t2);
        }
        return Object.defineProperty(e2.prototype, "debugging", { set: function(e3) {
          this._debugging = e3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "title", { get: function() {
          return this._title;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "body", { get: function() {
          return this._body;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "subtitle", { get: function() {
          return this._subtitle;
        }, set: function(e3) {
          this._subtitle = e3, this.apns.subtitle = e3, this.mpns.subtitle = e3, this.fcm.subtitle = e3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "badge", { get: function() {
          return this._badge;
        }, set: function(e3) {
          this._badge = e3, this.apns.badge = e3, this.mpns.badge = e3, this.fcm.badge = e3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "sound", { get: function() {
          return this._sound;
        }, set: function(e3) {
          this._sound = e3, this.apns.sound = e3, this.mpns.sound = e3, this.fcm.sound = e3;
        }, enumerable: false, configurable: true }), e2.prototype.buildPayload = function(e3) {
          var t2 = {};
          if (e3.includes("apns") || e3.includes("apns2")) {
            this.apns._apnsPushType = e3.includes("apns") ? "apns" : "apns2";
            var n2 = this.apns.toObject();
            n2 && Object.keys(n2).length && (t2.pn_apns = n2);
          }
          if (e3.includes("mpns")) {
            var r2 = this.mpns.toObject();
            r2 && Object.keys(r2).length && (t2.pn_mpns = r2);
          }
          if (e3.includes("fcm")) {
            var o2 = this.fcm.toObject();
            o2 && Object.keys(o2).length && (t2.pn_gcm = o2);
          }
          return Object.keys(t2).length && this._debugging && (t2.pn_debug = true), t2;
        }, e2;
      }(), L = function() {
        function e2() {
          this._listeners = [];
        }
        return e2.prototype.addListener = function(e3) {
          this._listeners.includes(e3) || this._listeners.push(e3);
        }, e2.prototype.removeListener = function(e3) {
          var t2 = [];
          this._listeners.forEach(function(n2) {
            n2 !== e3 && t2.push(n2);
          }), this._listeners = t2;
        }, e2.prototype.removeAllListeners = function() {
          this._listeners = [];
        }, e2.prototype.announcePresence = function(e3) {
          this._listeners.forEach(function(t2) {
            t2.presence && t2.presence(e3);
          });
        }, e2.prototype.announceStatus = function(e3) {
          this._listeners.forEach(function(t2) {
            t2.status && t2.status(e3);
          });
        }, e2.prototype.announceMessage = function(e3) {
          this._listeners.forEach(function(t2) {
            t2.message && t2.message(e3);
          });
        }, e2.prototype.announceSignal = function(e3) {
          this._listeners.forEach(function(t2) {
            t2.signal && t2.signal(e3);
          });
        }, e2.prototype.announceMessageAction = function(e3) {
          this._listeners.forEach(function(t2) {
            t2.messageAction && t2.messageAction(e3);
          });
        }, e2.prototype.announceFile = function(e3) {
          this._listeners.forEach(function(t2) {
            t2.file && t2.file(e3);
          });
        }, e2.prototype.announceObjects = function(e3) {
          this._listeners.forEach(function(t2) {
            t2.objects && t2.objects(e3);
          });
        }, e2.prototype.announceUser = function(e3) {
          this._listeners.forEach(function(t2) {
            t2.user && t2.user(e3);
          });
        }, e2.prototype.announceSpace = function(e3) {
          this._listeners.forEach(function(t2) {
            t2.space && t2.space(e3);
          });
        }, e2.prototype.announceMembership = function(e3) {
          this._listeners.forEach(function(t2) {
            t2.membership && t2.membership(e3);
          });
        }, e2.prototype.announceNetworkUp = function() {
          var e3 = {};
          e3.category = k.PNNetworkUpCategory, this.announceStatus(e3);
        }, e2.prototype.announceNetworkDown = function() {
          var e3 = {};
          e3.category = k.PNNetworkDownCategory, this.announceStatus(e3);
        }, e2;
      }(), G = function() {
        function e2(e3, t2) {
          this._config = e3, this._cbor = t2;
        }
        return e2.prototype.setToken = function(e3) {
          e3 && e3.length > 0 ? this._token = e3 : this._token = void 0;
        }, e2.prototype.getToken = function() {
          return this._token;
        }, e2.prototype.extractPermissions = function(e3) {
          var t2 = { read: false, write: false, manage: false, delete: false, get: false, update: false, join: false };
          return 128 == (128 & e3) && (t2.join = true), 64 == (64 & e3) && (t2.update = true), 32 == (32 & e3) && (t2.get = true), 8 == (8 & e3) && (t2.delete = true), 4 == (4 & e3) && (t2.manage = true), 2 == (2 & e3) && (t2.write = true), 1 == (1 & e3) && (t2.read = true), t2;
        }, e2.prototype.parseToken = function(e3) {
          var t2 = this, n2 = this._cbor.decodeToken(e3);
          if (void 0 !== n2) {
            var r2 = n2.res.uuid ? Object.keys(n2.res.uuid) : [], o2 = Object.keys(n2.res.chan), i2 = Object.keys(n2.res.grp), s2 = n2.pat.uuid ? Object.keys(n2.pat.uuid) : [], a2 = Object.keys(n2.pat.chan), u2 = Object.keys(n2.pat.grp), c2 = { version: n2.v, timestamp: n2.t, ttl: n2.ttl, authorized_uuid: n2.uuid }, l2 = r2.length > 0, p2 = o2.length > 0, h2 = i2.length > 0;
            (l2 || p2 || h2) && (c2.resources = {}, l2 && (c2.resources.uuids = {}, r2.forEach(function(e4) {
              c2.resources.uuids[e4] = t2.extractPermissions(n2.res.uuid[e4]);
            })), p2 && (c2.resources.channels = {}, o2.forEach(function(e4) {
              c2.resources.channels[e4] = t2.extractPermissions(n2.res.chan[e4]);
            })), h2 && (c2.resources.groups = {}, i2.forEach(function(e4) {
              c2.resources.groups[e4] = t2.extractPermissions(n2.res.grp[e4]);
            })));
            var f2 = s2.length > 0, d2 = a2.length > 0, y2 = u2.length > 0;
            return (f2 || d2 || y2) && (c2.patterns = {}, f2 && (c2.patterns.uuids = {}, s2.forEach(function(e4) {
              c2.patterns.uuids[e4] = t2.extractPermissions(n2.pat.uuid[e4]);
            })), d2 && (c2.patterns.channels = {}, a2.forEach(function(e4) {
              c2.patterns.channels[e4] = t2.extractPermissions(n2.pat.chan[e4]);
            })), y2 && (c2.patterns.groups = {}, u2.forEach(function(e4) {
              c2.patterns.groups[e4] = t2.extractPermissions(n2.pat.grp[e4]);
            }))), Object.keys(n2.meta).length > 0 && (c2.meta = n2.meta), c2.signature = n2.sig, c2;
          }
        }, e2;
      }();
      function K(e2) {
        return encodeURIComponent(e2).replace(/[!~*'()]/g, function(e3) {
          return "%".concat(e3.charCodeAt(0).toString(16).toUpperCase());
        });
      }
      function B(e2) {
        return function(e3) {
          var t2 = [];
          return Object.keys(e3).forEach(function(e4) {
            return t2.push(e4);
          }), t2;
        }(e2).sort();
      }
      var H = { signPamFromParams: function(e2) {
        return B(e2).map(function(t2) {
          return "".concat(t2, "=").concat(K(e2[t2]));
        }).join("&");
      }, endsWith: function(e2, t2) {
        return -1 !== e2.indexOf(t2, this.length - t2.length);
      }, createPromise: function() {
        var e2, t2;
        return { promise: new Promise(function(n2, r2) {
          e2 = n2, t2 = r2;
        }), reject: t2, fulfill: e2 };
      }, encodeString: K, stringToArrayBuffer: function(e2) {
        for (var t2 = new ArrayBuffer(2 * e2.length), n2 = new Uint16Array(t2), r2 = 0, o2 = e2.length; r2 < o2; r2++) n2[r2] = e2.charCodeAt(r2);
        return t2;
      }, removeSingleOccurance: function(e2, t2) {
        var n2 = Object.fromEntries(t2.map(function(e3) {
          return [e3, false];
        }));
        return e2.filter(function(e3) {
          return !(t2.includes(e3) && !n2[e3]) || (n2[e3] = true, false);
        });
      }, findUniqueCommonElements: function(e2, t2) {
        return __spreadArray([], __read(e2), false).filter(function(n2) {
          return t2.includes(n2) && e2.indexOf(n2) === e2.lastIndexOf(n2) && t2.indexOf(n2) === t2.lastIndexOf(n2);
        });
      } }, q = function(e2) {
        function n2(t2, n3) {
          var r2 = this.constructor, o2 = e2.call(this, t2) || this;
          return o2.name = o2.constructor.name, o2.status = n3, o2.message = t2, Object.setPrototypeOf(o2, r2.prototype), o2;
        }
        return t(n2, e2), n2;
      }(Error);
      function z(e2) {
        return (t2 = { message: e2 }).type = "validationError", t2.error = true, t2;
        var t2;
      }
      function V(e2, t2, n2) {
        return e2.usePost && e2.usePost(t2, n2) ? e2.postURL(t2, n2) : e2.usePatch && e2.usePatch(t2, n2) ? e2.patchURL(t2, n2) : e2.useGetFile && e2.useGetFile(t2, n2) ? e2.getFileURL(t2, n2) : e2.getURL(t2, n2);
      }
      function W(e2) {
        if (e2.sdkName) return e2.sdkName;
        var t2 = "PubNub-JS-".concat(e2.sdkFamily);
        e2.partnerId && (t2 += "-".concat(e2.partnerId)), t2 += "/".concat(e2.getVersion());
        var n2 = e2._getPnsdkSuffix(" ");
        return n2.length > 0 && (t2 += n2), t2;
      }
      function J(e2, t2, n2) {
        return t2.usePost && t2.usePost(e2, n2) ? "POST" : t2.usePatch && t2.usePatch(e2, n2) ? "PATCH" : t2.useDelete && t2.useDelete(e2, n2) ? "DELETE" : t2.useGetFile && t2.useGetFile(e2, n2) ? "GETFILE" : "GET";
      }
      function $(e2, t2, n2, r2, o2) {
        var i2 = e2.config, s2 = e2.crypto, a2 = J(e2, o2, r2);
        n2.timestamp = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3), "PNPublishOperation" === o2.getOperation() && o2.usePost && o2.usePost(e2, r2) && (a2 = "GET"), "GETFILE" === a2 && (a2 = "GET");
        var u2 = "".concat(a2, "\n").concat(i2.publishKey, "\n").concat(t2, "\n").concat(H.signPamFromParams(n2), "\n");
        if ("POST" === a2) u2 += "string" == typeof (c2 = o2.postPayload(e2, r2)) ? c2 : JSON.stringify(c2);
        else if ("PATCH" === a2) {
          var c2;
          u2 += "string" == typeof (c2 = o2.patchPayload(e2, r2)) ? c2 : JSON.stringify(c2);
        }
        var l2 = "v2.".concat(s2.HMACSHA256(u2));
        l2 = (l2 = (l2 = l2.replace(/\+/g, "-")).replace(/\//g, "_")).replace(/=+$/, ""), n2.signature = l2;
      }
      function Q(e2, t2) {
        for (var r2 = [], o2 = 2; o2 < arguments.length; o2++) r2[o2 - 2] = arguments[o2];
        var i2 = e2.networking, s2 = e2.config, a2 = e2.telemetryManager, u2 = e2.tokenManager, c2 = y(), l2 = null, p2 = null, h2 = {};
        t2.getOperation() === j.PNTimeOperation || t2.getOperation() === j.PNChannelGroupsOperation ? l2 = r2[0] : (h2 = r2[0], l2 = r2[1]), "undefined" == typeof Promise || l2 || (p2 = H.createPromise());
        var f2 = t2.validateParams(e2, h2);
        if (f2) return l2 ? l2(z(f2)) : p2 ? (p2.reject(new q("Validation failed, check status for details", z(f2))), p2.promise) : void 0;
        var d2, g2 = t2.prepareParams(e2, h2), m2 = V(t2, e2, h2), b2 = { url: m2, operation: t2.getOperation(), timeout: t2.getRequestTimeout(e2), headers: t2.getRequestHeaders ? t2.getRequestHeaders() : {}, ignoreBody: "function" == typeof t2.ignoreBody && t2.ignoreBody(e2), forceBuffered: "function" == typeof t2.forceBuffered ? t2.forceBuffered(e2, h2) : null, abortSignal: "function" == typeof t2.getAbortSignal ? t2.getAbortSignal(e2, h2) : null };
        g2.uuid = s2.UUID, g2.pnsdk = W(s2);
        var v2 = a2.operationsLatencyForRequest();
        if (Object.keys(v2).length && (g2 = n(n({}, g2), v2)), s2.useInstanceId && (g2.instanceid = s2.instanceId), s2.useRequestId && (g2.requestid = c2), t2.isAuthSupported()) {
          var _2 = u2.getToken() || s2.getAuthKey();
          _2 && (g2.auth = _2);
        }
        s2.secretKey && $(e2, m2, g2, h2, t2);
        var S2 = function(n2, r3) {
          if (n2.error) return t2.handleError && t2.handleError(e2, h2, n2), void (l2 ? l2(n2) : p2 && p2.reject(new q("PubNub call failed, check status for details", n2)));
          a2.stopLatencyMeasure(t2.getOperation(), c2);
          var o3 = t2.handleResponse(e2, r3, h2);
          "function" != typeof (null == o3 ? void 0 : o3.then) && (o3 = Promise.resolve(o3)), o3.then(function(e3) {
            l2 ? l2(n2, e3) : p2 && p2.fulfill(e3);
          }).catch(function(e3) {
            if (l2) {
              var n3 = e3;
              t2.getOperation() === j.PNSubscribeOperation && (n3 = { statusCode: 400, error: true, operation: t2.getOperation(), errorData: e3, category: k.PNUnknownCategory }), l2(n3, null);
            } else p2 && p2.reject(new q("PubNub call failed, check status for details", e3));
          });
        };
        if (a2.startLatencyMeasure(t2.getOperation(), c2), "POST" === J(e2, t2, h2)) {
          var w2 = t2.postPayload(e2, h2);
          d2 = i2.POST(g2, w2, b2, S2);
        } else if ("PATCH" === J(e2, t2, h2)) {
          w2 = t2.patchPayload(e2, h2);
          d2 = i2.PATCH(g2, w2, b2, S2);
        } else d2 = "DELETE" === J(e2, t2, h2) ? i2.DELETE(g2, b2, S2) : "GETFILE" === J(e2, t2, h2) ? i2.GETFILE(g2, b2, S2) : i2.GET(g2, b2, S2);
        return t2.getOperation() === j.PNSubscribeOperation ? d2 : p2 ? p2.promise : void 0;
      }
      var X = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNAddChannelsToGroupOperation;
      }, validateParams: function(e2, t2) {
        var n2 = t2.channels, r2 = t2.channelGroup, o2 = e2.config;
        return r2 ? n2 && 0 !== n2.length ? o2.subscribeKey ? void 0 : "Missing Subscribe Key" : "Missing Channels" : "Missing Channel Group";
      }, getURL: function(e2, t2) {
        var n2 = t2.channelGroup, r2 = e2.config;
        return "/v1/channel-registration/sub-key/".concat(r2.subscribeKey, "/channel-group/").concat(H.encodeString(n2));
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2 = t2.channels;
        return { add: (void 0 === n2 ? [] : n2).join(",") };
      }, handleResponse: function() {
        return {};
      } });
      var Y = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNRemoveChannelsFromGroupOperation;
      }, validateParams: function(e2, t2) {
        var n2 = t2.channels, r2 = t2.channelGroup, o2 = e2.config;
        return r2 ? n2 && 0 !== n2.length ? o2.subscribeKey ? void 0 : "Missing Subscribe Key" : "Missing Channels" : "Missing Channel Group";
      }, getURL: function(e2, t2) {
        var n2 = t2.channelGroup, r2 = e2.config;
        return "/v1/channel-registration/sub-key/".concat(r2.subscribeKey, "/channel-group/").concat(H.encodeString(n2));
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2 = t2.channels;
        return { remove: (void 0 === n2 ? [] : n2).join(",") };
      }, handleResponse: function() {
        return {};
      } });
      var Z = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNRemoveGroupOperation;
      }, validateParams: function(e2, t2) {
        var n2 = t2.channelGroup, r2 = e2.config;
        return n2 ? r2.subscribeKey ? void 0 : "Missing Subscribe Key" : "Missing Channel Group";
      }, getURL: function(e2, t2) {
        var n2 = t2.channelGroup, r2 = e2.config;
        return "/v1/channel-registration/sub-key/".concat(r2.subscribeKey, "/channel-group/").concat(H.encodeString(n2), "/remove");
      }, isAuthSupported: function() {
        return true;
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, prepareParams: function() {
        return {};
      }, handleResponse: function() {
        return {};
      } });
      var ee = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNChannelGroupsOperation;
      }, validateParams: function(e2) {
        if (!e2.config.subscribeKey) return "Missing Subscribe Key";
      }, getURL: function(e2) {
        var t2 = e2.config;
        return "/v1/channel-registration/sub-key/".concat(t2.subscribeKey, "/channel-group");
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function() {
        return {};
      }, handleResponse: function(e2, t2) {
        return { groups: t2.payload.groups };
      } });
      var te = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNChannelsForGroupOperation;
      }, validateParams: function(e2, t2) {
        var n2 = t2.channelGroup, r2 = e2.config;
        return n2 ? r2.subscribeKey ? void 0 : "Missing Subscribe Key" : "Missing Channel Group";
      }, getURL: function(e2, t2) {
        var n2 = t2.channelGroup, r2 = e2.config;
        return "/v1/channel-registration/sub-key/".concat(r2.subscribeKey, "/channel-group/").concat(H.encodeString(n2));
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function() {
        return {};
      }, handleResponse: function(e2, t2) {
        return { channels: t2.payload.channels };
      } });
      var ne = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNPushNotificationEnabledChannelsOperation;
      }, validateParams: function(e2, t2) {
        var n2 = t2.device, r2 = t2.pushGateway, o2 = t2.channels, i2 = t2.topic, s2 = e2.config;
        return n2 ? r2 ? "apns2" !== r2 || i2 ? o2 && 0 !== o2.length ? s2.subscribeKey ? void 0 : "Missing Subscribe Key" : "Missing Channels" : "Missing APNS2 topic" : "Missing GW Type (pushGateway: gcm, apns or apns2)" : "Missing Device ID (device)";
      }, getURL: function(e2, t2) {
        var n2 = t2.device, r2 = t2.pushGateway, o2 = e2.config;
        return "apns2" === r2 ? "/v2/push/sub-key/".concat(o2.subscribeKey, "/devices-apns2/").concat(n2) : "/v1/push/sub-key/".concat(o2.subscribeKey, "/devices/").concat(n2);
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var r2 = t2.pushGateway, o2 = t2.channels, i2 = void 0 === o2 ? [] : o2, s2 = t2.environment, a2 = void 0 === s2 ? "development" : s2, u2 = t2.topic, c2 = { type: r2, add: i2.join(",") };
        return "apns2" === r2 && delete (c2 = n(n({}, c2), { environment: a2, topic: u2 })).type, c2;
      }, handleResponse: function() {
        return {};
      } });
      var re = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNPushNotificationEnabledChannelsOperation;
      }, validateParams: function(e2, t2) {
        var n2 = t2.device, r2 = t2.pushGateway, o2 = t2.channels, i2 = t2.topic, s2 = e2.config;
        return n2 ? r2 ? "apns2" !== r2 || i2 ? o2 && 0 !== o2.length ? s2.subscribeKey ? void 0 : "Missing Subscribe Key" : "Missing Channels" : "Missing APNS2 topic" : "Missing GW Type (pushGateway: gcm, apns or apns2)" : "Missing Device ID (device)";
      }, getURL: function(e2, t2) {
        var n2 = t2.device, r2 = t2.pushGateway, o2 = e2.config;
        return "apns2" === r2 ? "/v2/push/sub-key/".concat(o2.subscribeKey, "/devices-apns2/").concat(n2) : "/v1/push/sub-key/".concat(o2.subscribeKey, "/devices/").concat(n2);
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var r2 = t2.pushGateway, o2 = t2.channels, i2 = void 0 === o2 ? [] : o2, s2 = t2.environment, a2 = void 0 === s2 ? "development" : s2, u2 = t2.topic, c2 = { type: r2, remove: i2.join(",") };
        return "apns2" === r2 && delete (c2 = n(n({}, c2), { environment: a2, topic: u2 })).type, c2;
      }, handleResponse: function() {
        return {};
      } });
      var oe = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNPushNotificationEnabledChannelsOperation;
      }, validateParams: function(e2, t2) {
        var n2 = t2.device, r2 = t2.pushGateway, o2 = t2.topic, i2 = e2.config;
        return n2 ? r2 ? "apns2" !== r2 || o2 ? i2.subscribeKey ? void 0 : "Missing Subscribe Key" : "Missing APNS2 topic" : "Missing GW Type (pushGateway: gcm, apns or apns2)" : "Missing Device ID (device)";
      }, getURL: function(e2, t2) {
        var n2 = t2.device, r2 = t2.pushGateway, o2 = e2.config;
        return "apns2" === r2 ? "/v2/push/sub-key/".concat(o2.subscribeKey, "/devices-apns2/").concat(n2) : "/v1/push/sub-key/".concat(o2.subscribeKey, "/devices/").concat(n2);
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var r2 = t2.pushGateway, o2 = t2.environment, i2 = void 0 === o2 ? "development" : o2, s2 = t2.topic, a2 = t2.start, u2 = t2.count, c2 = { type: r2 };
        return "apns2" === r2 && delete (c2 = n(n({}, c2), { environment: i2, topic: s2 })).type, a2 && (c2.start = a2), u2 && u2 > 0 && (c2.count = u2), c2;
      }, handleResponse: function(e2, t2) {
        return { channels: t2 };
      } });
      var ie = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNRemoveAllPushNotificationsOperation;
      }, validateParams: function(e2, t2) {
        var n2 = t2.device, r2 = t2.pushGateway, o2 = t2.topic, i2 = e2.config;
        return n2 ? r2 ? "apns2" !== r2 || o2 ? i2.subscribeKey ? void 0 : "Missing Subscribe Key" : "Missing APNS2 topic" : "Missing GW Type (pushGateway: gcm, apns or apns2)" : "Missing Device ID (device)";
      }, getURL: function(e2, t2) {
        var n2 = t2.device, r2 = t2.pushGateway, o2 = e2.config;
        return "apns2" === r2 ? "/v2/push/sub-key/".concat(o2.subscribeKey, "/devices-apns2/").concat(n2, "/remove") : "/v1/push/sub-key/".concat(o2.subscribeKey, "/devices/").concat(n2, "/remove");
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var r2 = t2.pushGateway, o2 = t2.environment, i2 = void 0 === o2 ? "development" : o2, s2 = t2.topic, a2 = { type: r2 };
        return "apns2" === r2 && delete (a2 = n(n({}, a2), { environment: i2, topic: s2 })).type, a2;
      }, handleResponse: function() {
        return {};
      } });
      var se = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNUnsubscribeOperation;
      }, validateParams: function(e2) {
        if (!e2.config.subscribeKey) return "Missing Subscribe Key";
      }, getURL: function(e2, t2) {
        var n2 = e2.config, r2 = t2.channels, o2 = void 0 === r2 ? [] : r2, i2 = o2.length > 0 ? o2.join(",") : ",";
        return "/v2/presence/sub-key/".concat(n2.subscribeKey, "/channel/").concat(H.encodeString(i2), "/leave");
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2 = t2.channelGroups, r2 = void 0 === n2 ? [] : n2, o2 = {};
        return r2.length > 0 && (o2["channel-group"] = r2.join(",")), o2;
      }, handleResponse: function() {
        return {};
      } });
      var ae = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNWhereNowOperation;
      }, validateParams: function(e2) {
        if (!e2.config.subscribeKey) return "Missing Subscribe Key";
      }, getURL: function(e2, t2) {
        var n2 = e2.config, r2 = t2.uuid, o2 = void 0 === r2 ? n2.UUID : r2;
        return "/v2/presence/sub-key/".concat(n2.subscribeKey, "/uuid/").concat(H.encodeString(o2));
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function() {
        return {};
      }, handleResponse: function(e2, t2) {
        return t2.payload ? { channels: t2.payload.channels } : { channels: [] };
      } });
      var ue = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNHeartbeatOperation;
      }, validateParams: function(e2) {
        if (!e2.config.subscribeKey) return "Missing Subscribe Key";
      }, getURL: function(e2, t2) {
        var n2 = e2.config, r2 = t2.channels, o2 = void 0 === r2 ? [] : r2, i2 = o2.length > 0 ? o2.join(",") : ",";
        return "/v2/presence/sub-key/".concat(n2.subscribeKey, "/channel/").concat(H.encodeString(i2), "/heartbeat");
      }, isAuthSupported: function() {
        return true;
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, prepareParams: function(e2, t2) {
        var n2 = t2.channelGroups, r2 = void 0 === n2 ? [] : n2, o2 = t2.state, i2 = e2.config, s2 = {};
        return r2.length > 0 && (s2["channel-group"] = r2.join(",")), o2 && (s2.state = JSON.stringify(o2)), s2.heartbeat = i2.getPresenceTimeout(), s2;
      }, handleResponse: function() {
        return {};
      } });
      var ce = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNGetStateOperation;
      }, validateParams: function(e2) {
        if (!e2.config.subscribeKey) return "Missing Subscribe Key";
      }, getURL: function(e2, t2) {
        var n2 = e2.config, r2 = t2.uuid, o2 = void 0 === r2 ? n2.UUID : r2, i2 = t2.channels, s2 = void 0 === i2 ? [] : i2, a2 = s2.length > 0 ? s2.join(",") : ",";
        return "/v2/presence/sub-key/".concat(n2.subscribeKey, "/channel/").concat(H.encodeString(a2), "/uuid/").concat(o2);
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2 = t2.channelGroups, r2 = void 0 === n2 ? [] : n2, o2 = {};
        return r2.length > 0 && (o2["channel-group"] = r2.join(",")), o2;
      }, handleResponse: function(e2, t2, n2) {
        var r2 = n2.channels, o2 = void 0 === r2 ? [] : r2, i2 = n2.channelGroups, s2 = void 0 === i2 ? [] : i2, a2 = {};
        return 1 === o2.length && 0 === s2.length ? a2[o2[0]] = t2.payload : a2 = t2.payload, { channels: a2 };
      } });
      var le = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNSetStateOperation;
      }, validateParams: function(e2, t2) {
        var n2 = e2.config, r2 = t2.state, o2 = t2.channels, i2 = void 0 === o2 ? [] : o2, s2 = t2.channelGroups, a2 = void 0 === s2 ? [] : s2;
        return r2 ? n2.subscribeKey ? 0 === i2.length && 0 === a2.length ? "Please provide a list of channels and/or channel-groups" : void 0 : "Missing Subscribe Key" : "Missing State";
      }, getURL: function(e2, t2) {
        var n2 = e2.config, r2 = t2.channels, o2 = void 0 === r2 ? [] : r2, i2 = o2.length > 0 ? o2.join(",") : ",";
        return "/v2/presence/sub-key/".concat(n2.subscribeKey, "/channel/").concat(H.encodeString(i2), "/uuid/").concat(H.encodeString(n2.UUID), "/data");
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2 = t2.state, r2 = t2.channelGroups, o2 = void 0 === r2 ? [] : r2, i2 = {};
        return i2.state = JSON.stringify(n2), o2.length > 0 && (i2["channel-group"] = o2.join(",")), i2;
      }, handleResponse: function(e2, t2) {
        return { state: t2.payload };
      } });
      var pe = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNHereNowOperation;
      }, validateParams: function(e2) {
        if (!e2.config.subscribeKey) return "Missing Subscribe Key";
      }, getURL: function(e2, t2) {
        var n2 = e2.config, r2 = t2.channels, o2 = void 0 === r2 ? [] : r2, i2 = t2.channelGroups, s2 = void 0 === i2 ? [] : i2, a2 = "/v2/presence/sub-key/".concat(n2.subscribeKey);
        if (o2.length > 0 || s2.length > 0) {
          var u2 = o2.length > 0 ? o2.join(",") : ",";
          a2 += "/channel/".concat(H.encodeString(u2));
        }
        return a2;
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var r2 = t2.channelGroups, o2 = void 0 === r2 ? [] : r2, i2 = t2.includeUUIDs, s2 = void 0 === i2 || i2, a2 = t2.includeState, u2 = void 0 !== a2 && a2, c2 = t2.queryParameters, l2 = void 0 === c2 ? {} : c2, p2 = {};
        return s2 || (p2.disable_uuids = 1), u2 && (p2.state = 1), o2.length > 0 && (p2["channel-group"] = o2.join(",")), p2 = n(n({}, p2), l2);
      }, handleResponse: function(e2, t2, n2) {
        var r2 = n2.channels, o2 = void 0 === r2 ? [] : r2, i2 = n2.channelGroups, s2 = void 0 === i2 ? [] : i2, a2 = n2.includeUUIDs, u2 = void 0 === a2 || a2, c2 = n2.includeState, l2 = void 0 !== c2 && c2;
        return o2.length > 1 || s2.length > 0 || 0 === s2.length && 0 === o2.length ? function() {
          var e3 = {};
          return e3.totalChannels = t2.payload.total_channels, e3.totalOccupancy = t2.payload.total_occupancy, e3.channels = {}, Object.keys(t2.payload.channels).forEach(function(n3) {
            var r3 = t2.payload.channels[n3], o3 = [];
            return e3.channels[n3] = { occupants: o3, name: n3, occupancy: r3.occupancy }, u2 && r3.uuids.forEach(function(e4) {
              l2 ? o3.push({ state: e4.state, uuid: e4.uuid }) : o3.push({ state: null, uuid: e4 });
            }), e3;
          }), e3;
        }() : function() {
          var e3 = {}, n3 = [];
          return e3.totalChannels = 1, e3.totalOccupancy = t2.occupancy, e3.channels = {}, e3.channels[o2[0]] = { occupants: n3, name: o2[0], occupancy: t2.occupancy }, u2 && t2.uuids && t2.uuids.forEach(function(e4) {
            l2 ? n3.push({ state: e4.state, uuid: e4.uuid }) : n3.push({ state: null, uuid: e4 });
          }), e3;
        }();
      }, handleError: function(e2, t2, n2) {
        402 !== n2.statusCode || this.getURL(e2, t2).includes("channel") || (n2.errorData.message = "You have tried to perform a Global Here Now operation, your keyset configuration does not support that. Please provide a channel, or enable the Global Here Now feature from the Portal.");
      } });
      var he = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNAddMessageActionOperation;
      }, validateParams: function(e2, t2) {
        var n2 = e2.config, r2 = t2.action, o2 = t2.channel;
        return t2.messageTimetoken ? n2.subscribeKey ? o2 ? r2 ? r2.value ? r2.type ? r2.type.length > 15 ? "Action.type value exceed maximum length of 15" : void 0 : "Missing Action.type" : "Missing Action.value" : "Missing Action" : "Missing message channel" : "Missing Subscribe Key" : "Missing message timetoken";
      }, usePost: function() {
        return true;
      }, postURL: function(e2, t2) {
        var n2 = e2.config, r2 = t2.channel, o2 = t2.messageTimetoken;
        return "/v1/message-actions/".concat(n2.subscribeKey, "/channel/").concat(H.encodeString(r2), "/message/").concat(o2);
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, getRequestHeaders: function() {
        return { "Content-Type": "application/json" };
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function() {
        return {};
      }, postPayload: function(e2, t2) {
        return t2.action;
      }, handleResponse: function(e2, t2) {
        return { data: t2.data };
      } });
      var fe = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNRemoveMessageActionOperation;
      }, validateParams: function(e2, t2) {
        var n2 = e2.config, r2 = t2.channel, o2 = t2.actionTimetoken;
        return t2.messageTimetoken ? o2 ? n2.subscribeKey ? r2 ? void 0 : "Missing message channel" : "Missing Subscribe Key" : "Missing action timetoken" : "Missing message timetoken";
      }, useDelete: function() {
        return true;
      }, getURL: function(e2, t2) {
        var n2 = e2.config, r2 = t2.channel, o2 = t2.actionTimetoken, i2 = t2.messageTimetoken;
        return "/v1/message-actions/".concat(n2.subscribeKey, "/channel/").concat(H.encodeString(r2), "/message/").concat(i2, "/action/").concat(o2);
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function() {
        return {};
      }, handleResponse: function(e2, t2) {
        return { data: t2.data };
      } });
      var de = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNGetMessageActionsOperation;
      }, validateParams: function(e2, t2) {
        var n2 = e2.config, r2 = t2.channel;
        return n2.subscribeKey ? r2 ? void 0 : "Missing message channel" : "Missing Subscribe Key";
      }, getURL: function(e2, t2) {
        var n2 = e2.config, r2 = t2.channel;
        return "/v1/message-actions/".concat(n2.subscribeKey, "/channel/").concat(H.encodeString(r2));
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2 = t2.limit, r2 = t2.start, o2 = t2.end, i2 = {};
        return n2 && (i2.limit = n2), r2 && (i2.start = r2), o2 && (i2.end = o2), i2;
      }, handleResponse: function(e2, t2) {
        var n2 = { data: t2.data, start: null, end: null };
        return n2.data.length && (n2.end = n2.data[n2.data.length - 1].actionTimetoken, n2.start = n2.data[0].actionTimetoken), n2;
      } }), ye = { getOperation: function() {
        return j.PNListFilesOperation;
      }, validateParams: function(e2, t2) {
        if (!(null == t2 ? void 0 : t2.channel)) return "channel can't be empty";
      }, getURL: function(e2, t2) {
        var n2 = e2.config;
        return "/v1/files/".concat(n2.subscribeKey, "/channels/").concat(H.encodeString(t2.channel), "/files");
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2 = {};
        return t2.limit && (n2.limit = t2.limit), t2.next && (n2.next = t2.next), n2;
      }, handleResponse: function(e2, t2) {
        return { status: t2.status, data: t2.data, next: t2.next, count: t2.count };
      } }, ge = { getOperation: function() {
        return j.PNGenerateUploadUrlOperation;
      }, validateParams: function(e2, t2) {
        return (null == t2 ? void 0 : t2.channel) ? (null == t2 ? void 0 : t2.name) ? void 0 : "name can't be empty" : "channel can't be empty";
      }, usePost: function() {
        return true;
      }, postURL: function(e2, t2) {
        var n2 = e2.config;
        return "/v1/files/".concat(n2.subscribeKey, "/channels/").concat(H.encodeString(t2.channel), "/generate-upload-url");
      }, postPayload: function(e2, t2) {
        return { name: t2.name };
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function() {
        return {};
      }, handleResponse: function(e2, t2) {
        return { status: t2.status, data: t2.data, file_upload_request: t2.file_upload_request };
      } }, me = { getOperation: function() {
        return j.PNPublishFileOperation;
      }, validateParams: function(e2, t2) {
        return (null == t2 ? void 0 : t2.channel) ? (null == t2 ? void 0 : t2.fileId) ? (null == t2 ? void 0 : t2.fileName) ? void 0 : "file name can't be empty" : "file id can't be empty" : "channel can't be empty";
      }, getURL: function(e2, t2) {
        var n2 = e2.config, r2 = n2.publishKey, o2 = n2.subscribeKey, i2 = function(e3, t3) {
          var n3 = JSON.stringify(t3);
          if (e3.cryptoModule) {
            var r3 = e3.cryptoModule.encrypt(n3);
            n3 = "string" == typeof r3 ? r3 : b(r3), n3 = JSON.stringify(n3);
          }
          return n3 || "";
        }(e2, { message: t2.message, file: { name: t2.fileName, id: t2.fileId } });
        return "/v1/files/publish-file/".concat(r2, "/").concat(o2, "/0/").concat(H.encodeString(t2.channel), "/0/").concat(H.encodeString(i2));
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2 = {};
        return t2.ttl && (n2.ttl = t2.ttl), void 0 !== t2.storeInHistory && (n2.store = t2.storeInHistory ? "1" : "0"), t2.meta && "object" == typeof t2.meta && (n2.meta = JSON.stringify(t2.meta)), n2;
      }, handleResponse: function(e2, t2) {
        return { timetoken: t2[2] };
      } }, be = function(e2) {
        var t2 = function(e3) {
          var t3 = this, n2 = e3.generateUploadUrl, r2 = e3.publishFile, s2 = e3.modules, a2 = s2.PubNubFile, u2 = s2.config, c2 = s2.cryptography, l2 = s2.cryptoModule, p2 = s2.networking;
          return function(e4) {
            var s3 = e4.channel, h2 = e4.file, f2 = e4.message, d2 = e4.cipherKey, y2 = e4.meta, g2 = e4.ttl, m2 = e4.storeInHistory;
            return o(t3, void 0, void 0, function() {
              var e5, t4, o2, b2, v2, _2, S2, w2, O2, P2, E2, A2, T2, N2, C2, k2, M2, j2, R2, x2, U2, I2, D2, F2, L2, G2, K2, B2, H2;
              return i(this, function(i2) {
                switch (i2.label) {
                  case 0:
                    if (!s3) throw new q("Validation failed, check status for details", z("channel can't be empty"));
                    if (!h2) throw new q("Validation failed, check status for details", z("file can't be empty"));
                    return e5 = a2.create(h2), [4, n2({ channel: s3, name: e5.name })];
                  case 1:
                    return t4 = i2.sent(), o2 = t4.file_upload_request, b2 = o2.url, v2 = o2.form_fields, _2 = t4.data, S2 = _2.id, w2 = _2.name, a2.supportsEncryptFile && (d2 || l2) ? null != d2 ? [3, 3] : [4, l2.encryptFile(e5, a2)] : [3, 6];
                  case 2:
                    return O2 = i2.sent(), [3, 5];
                  case 3:
                    return [4, c2.encryptFile(d2, e5, a2)];
                  case 4:
                    O2 = i2.sent(), i2.label = 5;
                  case 5:
                    e5 = O2, i2.label = 6;
                  case 6:
                    P2 = v2, e5.mimeType && (P2 = v2.map(function(t5) {
                      return "Content-Type" === t5.key ? { key: t5.key, value: e5.mimeType } : t5;
                    })), i2.label = 7;
                  case 7:
                    return i2.trys.push([7, 21, , 22]), a2.supportsFileUri && h2.uri ? (T2 = (A2 = p2).POSTFILE, N2 = [b2, P2], [4, e5.toFileUri()]) : [3, 10];
                  case 8:
                    return [4, T2.apply(A2, N2.concat([i2.sent()]))];
                  case 9:
                    return E2 = i2.sent(), [3, 20];
                  case 10:
                    return a2.supportsFile ? (k2 = (C2 = p2).POSTFILE, M2 = [b2, P2], [4, e5.toFile()]) : [3, 13];
                  case 11:
                    return [4, k2.apply(C2, M2.concat([i2.sent()]))];
                  case 12:
                    return E2 = i2.sent(), [3, 20];
                  case 13:
                    return a2.supportsBuffer ? (R2 = (j2 = p2).POSTFILE, x2 = [b2, P2], [4, e5.toBuffer()]) : [3, 16];
                  case 14:
                    return [4, R2.apply(j2, x2.concat([i2.sent()]))];
                  case 15:
                    return E2 = i2.sent(), [3, 20];
                  case 16:
                    return a2.supportsBlob ? (I2 = (U2 = p2).POSTFILE, D2 = [b2, P2], [4, e5.toBlob()]) : [3, 19];
                  case 17:
                    return [4, I2.apply(U2, D2.concat([i2.sent()]))];
                  case 18:
                    return E2 = i2.sent(), [3, 20];
                  case 19:
                    throw new Error("Unsupported environment");
                  case 20:
                    return [3, 22];
                  case 21:
                    throw (F2 = i2.sent()).response && "string" == typeof F2.response.text ? (L2 = F2.response.text, G2 = /<Message>(.*)<\/Message>/gi.exec(L2), new q(G2 ? "Upload to bucket failed: ".concat(G2[1]) : "Upload to bucket failed.", F2)) : new q("Upload to bucket failed.", F2);
                  case 22:
                    if (204 !== E2.status) throw new q("Upload to bucket was unsuccessful", E2);
                    K2 = u2.fileUploadPublishRetryLimit, B2 = false, H2 = { timetoken: "0" }, i2.label = 23;
                  case 23:
                    return i2.trys.push([23, 25, , 26]), [4, r2({ channel: s3, message: f2, fileId: S2, fileName: w2, meta: y2, storeInHistory: m2, ttl: g2 })];
                  case 24:
                    return H2 = i2.sent(), B2 = true, [3, 26];
                  case 25:
                    return i2.sent(), K2 -= 1, [3, 26];
                  case 26:
                    if (!B2 && K2 > 0) return [3, 23];
                    i2.label = 27;
                  case 27:
                    if (B2) return [2, { timetoken: H2.timetoken, id: S2, name: w2 }];
                    throw new q("Publish failed. You may want to execute that operation manually using pubnub.publishFile", { channel: s3, id: S2, name: w2 });
                }
              });
            });
          };
        }(e2);
        return function(e3, n2) {
          var r2 = t2(e3);
          return "function" == typeof n2 ? (r2.then(function(e4) {
            return n2(null, e4);
          }).catch(function(e4) {
            return n2(e4, null);
          }), r2) : r2;
        };
      }, ve = function(e2, t2) {
        var n2 = t2.channel, r2 = t2.id, o2 = t2.name, i2 = e2.config, s2 = e2.networking, a2 = e2.tokenManager;
        if (!n2) throw new q("Validation failed, check status for details", z("channel can't be empty"));
        if (!r2) throw new q("Validation failed, check status for details", z("file id can't be empty"));
        if (!o2) throw new q("Validation failed, check status for details", z("file name can't be empty"));
        var u2 = "/v1/files/".concat(i2.subscribeKey, "/channels/").concat(H.encodeString(n2), "/files/").concat(r2, "/").concat(o2), c2 = {};
        c2.uuid = i2.getUUID(), c2.pnsdk = W(i2);
        var l2 = a2.getToken() || i2.getAuthKey();
        l2 && (c2.auth = l2), i2.secretKey && $(e2, u2, c2, {}, { getOperation: function() {
          return "PubNubGetFileUrlOperation";
        } });
        var p2 = Object.keys(c2).map(function(e3) {
          return "".concat(encodeURIComponent(e3), "=").concat(encodeURIComponent(c2[e3]));
        }).join("&");
        return "" !== p2 ? "".concat(s2.getStandardOrigin()).concat(u2, "?").concat(p2) : "".concat(s2.getStandardOrigin()).concat(u2);
      }, _e = { getOperation: function() {
        return j.PNDownloadFileOperation;
      }, validateParams: function(e2, t2) {
        return (null == t2 ? void 0 : t2.channel) ? (null == t2 ? void 0 : t2.name) ? (null == t2 ? void 0 : t2.id) ? void 0 : "id can't be empty" : "name can't be empty" : "channel can't be empty";
      }, useGetFile: function() {
        return true;
      }, getFileURL: function(e2, t2) {
        var n2 = e2.config;
        return "/v1/files/".concat(n2.subscribeKey, "/channels/").concat(H.encodeString(t2.channel), "/files/").concat(t2.id, "/").concat(t2.name);
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, ignoreBody: function() {
        return true;
      }, forceBuffered: function() {
        return true;
      }, prepareParams: function() {
        return {};
      }, handleResponse: function(e2, t2, n2) {
        var r2 = e2.PubNubFile, s2 = e2.config, a2 = e2.cryptography, u2 = e2.cryptoModule;
        return o(void 0, void 0, void 0, function() {
          var e3, o2, c2, l2;
          return i(this, function(i2) {
            switch (i2.label) {
              case 0:
                return e3 = t2.response.body, r2.supportsEncryptFile && (n2.cipherKey || u2) ? null != n2.cipherKey ? [3, 2] : [4, u2.decryptFile(r2.create({ data: e3, name: n2.name }), r2)] : [3, 5];
              case 1:
                return o2 = i2.sent().data, [3, 4];
              case 2:
                return [4, a2.decrypt(null !== (c2 = n2.cipherKey) && void 0 !== c2 ? c2 : s2.cipherKey, e3)];
              case 3:
                o2 = i2.sent(), i2.label = 4;
              case 4:
                e3 = o2, i2.label = 5;
              case 5:
                return [2, r2.create({ data: e3, name: null !== (l2 = t2.response.name) && void 0 !== l2 ? l2 : n2.name, mimeType: t2.response.type })];
            }
          });
        });
      } }, Se = { getOperation: function() {
        return j.PNListFilesOperation;
      }, validateParams: function(e2, t2) {
        return (null == t2 ? void 0 : t2.channel) ? (null == t2 ? void 0 : t2.id) ? (null == t2 ? void 0 : t2.name) ? void 0 : "file name can't be empty" : "file id can't be empty" : "channel can't be empty";
      }, useDelete: function() {
        return true;
      }, getURL: function(e2, t2) {
        var n2 = e2.config;
        return "/v1/files/".concat(n2.subscribeKey, "/channels/").concat(H.encodeString(t2.channel), "/files/").concat(t2.id, "/").concat(t2.name);
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function() {
        return {};
      }, handleResponse: function(e2, t2) {
        return { status: t2.status };
      } }, we = { getOperation: function() {
        return j.PNGetAllUUIDMetadataOperation;
      }, validateParams: function() {
      }, getURL: function(e2) {
        var t2 = e2.config;
        return "/v2/objects/".concat(t2.subscribeKey, "/uuids");
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2, r2, o2, i2, s2, u2, c2, l2, p2, h2 = { include: ["status", "type"] };
        return (null == t2 ? void 0 : t2.include) && (null === (n2 = t2.include) || void 0 === n2 ? void 0 : n2.customFields) && h2.include.push("custom"), h2.include = h2.include.join(","), (null === (r2 = null == t2 ? void 0 : t2.include) || void 0 === r2 ? void 0 : r2.totalCount) && (h2.count = null === (o2 = t2.include) || void 0 === o2 ? void 0 : o2.totalCount), (null === (i2 = null == t2 ? void 0 : t2.page) || void 0 === i2 ? void 0 : i2.next) && (h2.start = null === (s2 = t2.page) || void 0 === s2 ? void 0 : s2.next), (null === (u2 = null == t2 ? void 0 : t2.page) || void 0 === u2 ? void 0 : u2.prev) && (h2.end = null === (c2 = t2.page) || void 0 === c2 ? void 0 : c2.prev), (null == t2 ? void 0 : t2.filter) && (h2.filter = t2.filter), h2.limit = null !== (l2 = null == t2 ? void 0 : t2.limit) && void 0 !== l2 ? l2 : 100, (null == t2 ? void 0 : t2.sort) && (h2.sort = Object.entries(null !== (p2 = t2.sort) && void 0 !== p2 ? p2 : {}).map(function(e3) {
          var t3 = a(e3, 2), n3 = t3[0], r3 = t3[1];
          return "asc" === r3 || "desc" === r3 ? "".concat(n3, ":").concat(r3) : n3;
        })), h2;
      }, handleResponse: function(e2, t2) {
        return { status: t2.status, data: t2.data, totalCount: t2.totalCount, next: t2.next, prev: t2.prev };
      } }, Oe = { getOperation: function() {
        return j.PNGetUUIDMetadataOperation;
      }, validateParams: function() {
      }, getURL: function(e2, t2) {
        var n2, r2 = e2.config;
        return "/v2/objects/".concat(r2.subscribeKey, "/uuids/").concat(H.encodeString(null !== (n2 = null == t2 ? void 0 : t2.uuid) && void 0 !== n2 ? n2 : r2.getUUID()));
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2, r2, o2 = e2.config, i2 = {};
        return i2.uuid = null !== (n2 = null == t2 ? void 0 : t2.uuid) && void 0 !== n2 ? n2 : o2.getUUID(), i2.include = ["status", "type", "custom"], (null == t2 ? void 0 : t2.include) && false === (null === (r2 = t2.include) || void 0 === r2 ? void 0 : r2.customFields) && i2.include.pop(), i2.include = i2.include.join(","), i2;
      }, handleResponse: function(e2, t2) {
        return { status: t2.status, data: t2.data };
      } }, Pe = { getOperation: function() {
        return j.PNSetUUIDMetadataOperation;
      }, validateParams: function(e2, t2) {
        if (!(null == t2 ? void 0 : t2.data)) return "Data cannot be empty";
      }, usePatch: function() {
        return true;
      }, patchURL: function(e2, t2) {
        var n2, r2 = e2.config;
        return "/v2/objects/".concat(r2.subscribeKey, "/uuids/").concat(H.encodeString(null !== (n2 = t2.uuid) && void 0 !== n2 ? n2 : r2.getUUID()));
      }, patchPayload: function(e2, t2) {
        return t2.data;
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2, r2, o2 = e2.config, i2 = {};
        return i2.uuid = null !== (n2 = null == t2 ? void 0 : t2.uuid) && void 0 !== n2 ? n2 : o2.getUUID(), i2.include = ["status", "type", "custom"], (null == t2 ? void 0 : t2.include) && false === (null === (r2 = t2.include) || void 0 === r2 ? void 0 : r2.customFields) && i2.include.pop(), i2.include = i2.include.join(","), i2;
      }, handleResponse: function(e2, t2) {
        return { status: t2.status, data: t2.data };
      } }, Ee = { getOperation: function() {
        return j.PNRemoveUUIDMetadataOperation;
      }, validateParams: function() {
      }, getURL: function(e2, t2) {
        var n2, r2 = e2.config;
        return "/v2/objects/".concat(r2.subscribeKey, "/uuids/").concat(H.encodeString(null !== (n2 = null == t2 ? void 0 : t2.uuid) && void 0 !== n2 ? n2 : r2.getUUID()));
      }, useDelete: function() {
        return true;
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2, r2 = e2.config;
        return { uuid: null !== (n2 = null == t2 ? void 0 : t2.uuid) && void 0 !== n2 ? n2 : r2.getUUID() };
      }, handleResponse: function(e2, t2) {
        return { status: t2.status, data: t2.data };
      } }, Ae = { getOperation: function() {
        return j.PNGetAllChannelMetadataOperation;
      }, validateParams: function() {
      }, getURL: function(e2) {
        var t2 = e2.config;
        return "/v2/objects/".concat(t2.subscribeKey, "/channels");
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2, r2, o2, i2, s2, u2, c2, l2, p2, h2 = { include: ["status", "type"] };
        return (null == t2 ? void 0 : t2.include) && (null === (n2 = t2.include) || void 0 === n2 ? void 0 : n2.customFields) && h2.include.push("custom"), h2.include = h2.include.join(","), (null === (r2 = null == t2 ? void 0 : t2.include) || void 0 === r2 ? void 0 : r2.totalCount) && (h2.count = null === (o2 = t2.include) || void 0 === o2 ? void 0 : o2.totalCount), (null === (i2 = null == t2 ? void 0 : t2.page) || void 0 === i2 ? void 0 : i2.next) && (h2.start = null === (s2 = t2.page) || void 0 === s2 ? void 0 : s2.next), (null === (u2 = null == t2 ? void 0 : t2.page) || void 0 === u2 ? void 0 : u2.prev) && (h2.end = null === (c2 = t2.page) || void 0 === c2 ? void 0 : c2.prev), (null == t2 ? void 0 : t2.filter) && (h2.filter = t2.filter), h2.limit = null !== (l2 = null == t2 ? void 0 : t2.limit) && void 0 !== l2 ? l2 : 100, (null == t2 ? void 0 : t2.sort) && (h2.sort = Object.entries(null !== (p2 = t2.sort) && void 0 !== p2 ? p2 : {}).map(function(e3) {
          var t3 = a(e3, 2), n3 = t3[0], r3 = t3[1];
          return "asc" === r3 || "desc" === r3 ? "".concat(n3, ":").concat(r3) : n3;
        })), h2;
      }, handleResponse: function(e2, t2) {
        return { status: t2.status, data: t2.data, totalCount: t2.totalCount, prev: t2.prev, next: t2.next };
      } }, Te = { getOperation: function() {
        return j.PNGetChannelMetadataOperation;
      }, validateParams: function(e2, t2) {
        if (!(null == t2 ? void 0 : t2.channel)) return "Channel cannot be empty";
      }, getURL: function(e2, t2) {
        var n2 = e2.config;
        return "/v2/objects/".concat(n2.subscribeKey, "/channels/").concat(H.encodeString(t2.channel));
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2, r2 = { include: ["status", "type", "custom"] };
        return (null == t2 ? void 0 : t2.include) && false === (null === (n2 = t2.include) || void 0 === n2 ? void 0 : n2.customFields) && r2.include.pop(), r2.include = r2.include.join(","), r2;
      }, handleResponse: function(e2, t2) {
        return { status: t2.status, data: t2.data };
      } }, Ne = { getOperation: function() {
        return j.PNSetChannelMetadataOperation;
      }, validateParams: function(e2, t2) {
        return (null == t2 ? void 0 : t2.channel) ? (null == t2 ? void 0 : t2.data) ? void 0 : "Data cannot be empty" : "Channel cannot be empty";
      }, usePatch: function() {
        return true;
      }, patchURL: function(e2, t2) {
        var n2 = e2.config;
        return "/v2/objects/".concat(n2.subscribeKey, "/channels/").concat(H.encodeString(t2.channel));
      }, patchPayload: function(e2, t2) {
        return t2.data;
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2, r2 = { include: ["status", "type", "custom"] };
        return (null == t2 ? void 0 : t2.include) && false === (null === (n2 = t2.include) || void 0 === n2 ? void 0 : n2.customFields) && r2.include.pop(), r2.include = r2.include.join(","), r2;
      }, handleResponse: function(e2, t2) {
        return { status: t2.status, data: t2.data };
      } }, Ce = { getOperation: function() {
        return j.PNRemoveChannelMetadataOperation;
      }, validateParams: function(e2, t2) {
        if (!(null == t2 ? void 0 : t2.channel)) return "Channel cannot be empty";
      }, getURL: function(e2, t2) {
        var n2 = e2.config;
        return "/v2/objects/".concat(n2.subscribeKey, "/channels/").concat(H.encodeString(t2.channel));
      }, useDelete: function() {
        return true;
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function() {
        return {};
      }, handleResponse: function(e2, t2) {
        return { status: t2.status, data: t2.data };
      } }, ke = { getOperation: function() {
        return j.PNGetMembersOperation;
      }, validateParams: function(e2, t2) {
        if (!(null == t2 ? void 0 : t2.channel)) return "channel cannot be empty";
      }, getURL: function(e2, t2) {
        var n2 = e2.config;
        return "/v2/objects/".concat(n2.subscribeKey, "/channels/").concat(H.encodeString(t2.channel), "/uuids");
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2, r2, o2, i2, s2, u2, c2, l2, p2, h2, f2, d2, y2, g2, m2 = { include: [] };
        return (null == t2 ? void 0 : t2.include) && ((null === (n2 = t2.include) || void 0 === n2 ? void 0 : n2.statusField) && m2.include.push("status"), (null === (r2 = t2.include) || void 0 === r2 ? void 0 : r2.customFields) && m2.include.push("custom"), (null === (o2 = t2.include) || void 0 === o2 ? void 0 : o2.UUIDFields) && m2.include.push("uuid"), (null === (i2 = t2.include) || void 0 === i2 ? void 0 : i2.customUUIDFields) && m2.include.push("uuid.custom"), (null === (s2 = t2.include) || void 0 === s2 ? void 0 : s2.UUIDStatusField) && m2.include.push("uuid.status"), (null === (u2 = t2.include) || void 0 === u2 ? void 0 : u2.UUIDTypeField) && m2.include.push("uuid.type")), m2.include = m2.include.join(","), (null === (c2 = null == t2 ? void 0 : t2.include) || void 0 === c2 ? void 0 : c2.totalCount) && (m2.count = null === (l2 = t2.include) || void 0 === l2 ? void 0 : l2.totalCount), (null === (p2 = null == t2 ? void 0 : t2.page) || void 0 === p2 ? void 0 : p2.next) && (m2.start = null === (h2 = t2.page) || void 0 === h2 ? void 0 : h2.next), (null === (f2 = null == t2 ? void 0 : t2.page) || void 0 === f2 ? void 0 : f2.prev) && (m2.end = null === (d2 = t2.page) || void 0 === d2 ? void 0 : d2.prev), (null == t2 ? void 0 : t2.filter) && (m2.filter = t2.filter), m2.limit = null !== (y2 = null == t2 ? void 0 : t2.limit) && void 0 !== y2 ? y2 : 100, (null == t2 ? void 0 : t2.sort) && (m2.sort = Object.entries(null !== (g2 = t2.sort) && void 0 !== g2 ? g2 : {}).map(function(e3) {
          var t3 = a(e3, 2), n3 = t3[0], r3 = t3[1];
          return "asc" === r3 || "desc" === r3 ? "".concat(n3, ":").concat(r3) : n3;
        })), m2;
      }, handleResponse: function(e2, t2) {
        return { status: t2.status, data: t2.data, totalCount: t2.totalCount, prev: t2.prev, next: t2.next };
      } }, Me = { getOperation: function() {
        return j.PNSetMembersOperation;
      }, validateParams: function(e2, t2) {
        return (null == t2 ? void 0 : t2.channel) ? (null == t2 ? void 0 : t2.uuids) && 0 !== (null == t2 ? void 0 : t2.uuids.length) ? void 0 : "UUIDs cannot be empty" : "Channel cannot be empty";
      }, usePatch: function() {
        return true;
      }, patchURL: function(e2, t2) {
        var n2 = e2.config;
        return "/v2/objects/".concat(n2.subscribeKey, "/channels/").concat(H.encodeString(t2.channel), "/uuids");
      }, patchPayload: function(e2, t2) {
        var n2;
        return (n2 = { set: [], delete: [] })[t2.type] = t2.uuids.map(function(e3) {
          return "string" == typeof e3 ? { uuid: { id: e3 } } : { uuid: { id: e3.id }, custom: e3.custom, status: e3.status };
        }), n2;
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2, r2, o2, i2, s2, u2, c2, l2, p2, h2 = { include: ["uuid.status", "uuid.type", "type"] };
        return (null == t2 ? void 0 : t2.include) && ((null === (n2 = t2.include) || void 0 === n2 ? void 0 : n2.customFields) && h2.include.push("custom"), (null === (r2 = t2.include) || void 0 === r2 ? void 0 : r2.customUUIDFields) && h2.include.push("uuid.custom"), (null === (o2 = t2.include) || void 0 === o2 ? void 0 : o2.UUIDFields) && h2.include.push("uuid")), h2.include = h2.include.join(","), (null === (i2 = null == t2 ? void 0 : t2.include) || void 0 === i2 ? void 0 : i2.totalCount) && (h2.count = true), (null === (s2 = null == t2 ? void 0 : t2.page) || void 0 === s2 ? void 0 : s2.next) && (h2.start = null === (u2 = t2.page) || void 0 === u2 ? void 0 : u2.next), (null === (c2 = null == t2 ? void 0 : t2.page) || void 0 === c2 ? void 0 : c2.prev) && (h2.end = null === (l2 = t2.page) || void 0 === l2 ? void 0 : l2.prev), (null == t2 ? void 0 : t2.filter) && (h2.filter = t2.filter), null != t2.limit && (h2.limit = t2.limit), (null == t2 ? void 0 : t2.sort) && (h2.sort = Object.entries(null !== (p2 = t2.sort) && void 0 !== p2 ? p2 : {}).map(function(e3) {
          var t3 = a(e3, 2), n3 = t3[0], r3 = t3[1];
          return "asc" === r3 || "desc" === r3 ? "".concat(n3, ":").concat(r3) : n3;
        })), h2;
      }, handleResponse: function(e2, t2) {
        return { status: t2.status, data: t2.data, totalCount: t2.totalCount, prev: t2.prev, next: t2.next };
      } }, je = { getOperation: function() {
        return j.PNGetMembershipsOperation;
      }, validateParams: function() {
      }, getURL: function(e2, t2) {
        var n2, r2 = e2.config;
        return "/v2/objects/".concat(r2.subscribeKey, "/uuids/").concat(H.encodeString(null !== (n2 = null == t2 ? void 0 : t2.uuid) && void 0 !== n2 ? n2 : r2.getUUID()), "/channels");
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2, r2, o2, i2, s2, u2, c2, l2, p2, h2, f2, d2, y2, g2, m2 = { include: [] };
        return (null == t2 ? void 0 : t2.include) && ((null === (n2 = t2.include) || void 0 === n2 ? void 0 : n2.statusField) && m2.include.push("status"), (null === (r2 = t2.include) || void 0 === r2 ? void 0 : r2.customFields) && m2.include.push("custom"), (null === (o2 = t2.include) || void 0 === o2 ? void 0 : o2.channelFields) && m2.include.push("channel"), (null === (i2 = t2.include) || void 0 === i2 ? void 0 : i2.customChannelFields) && m2.include.push("channel.custom"), (null === (s2 = t2.include) || void 0 === s2 ? void 0 : s2.channelStatusField) && m2.include.push("channel.status"), (null === (u2 = t2.include) || void 0 === u2 ? void 0 : u2.channelTypeField) && m2.include.push("channel.type")), m2.include = m2.include.join(","), (null === (c2 = null == t2 ? void 0 : t2.include) || void 0 === c2 ? void 0 : c2.totalCount) && (m2.count = null === (l2 = t2.include) || void 0 === l2 ? void 0 : l2.totalCount), (null === (p2 = null == t2 ? void 0 : t2.page) || void 0 === p2 ? void 0 : p2.next) && (m2.start = null === (h2 = t2.page) || void 0 === h2 ? void 0 : h2.next), (null === (f2 = null == t2 ? void 0 : t2.page) || void 0 === f2 ? void 0 : f2.prev) && (m2.end = null === (d2 = t2.page) || void 0 === d2 ? void 0 : d2.prev), (null == t2 ? void 0 : t2.filter) && (m2.filter = t2.filter), m2.limit = null !== (y2 = null == t2 ? void 0 : t2.limit) && void 0 !== y2 ? y2 : 100, (null == t2 ? void 0 : t2.sort) && (m2.sort = Object.entries(null !== (g2 = t2.sort) && void 0 !== g2 ? g2 : {}).map(function(e3) {
          var t3 = a(e3, 2), n3 = t3[0], r3 = t3[1];
          return "asc" === r3 || "desc" === r3 ? "".concat(n3, ":").concat(r3) : n3;
        })), m2;
      }, handleResponse: function(e2, t2) {
        return { status: t2.status, data: t2.data, totalCount: t2.totalCount, prev: t2.prev, next: t2.next };
      } }, Re = { getOperation: function() {
        return j.PNSetMembershipsOperation;
      }, validateParams: function(e2, t2) {
        if (!(null == t2 ? void 0 : t2.channels) || 0 === (null == t2 ? void 0 : t2.channels.length)) return "Channels cannot be empty";
      }, usePatch: function() {
        return true;
      }, patchURL: function(e2, t2) {
        var n2, r2 = e2.config;
        return "/v2/objects/".concat(r2.subscribeKey, "/uuids/").concat(H.encodeString(null !== (n2 = t2.uuid) && void 0 !== n2 ? n2 : r2.getUUID()), "/channels");
      }, patchPayload: function(e2, t2) {
        var n2;
        return (n2 = { set: [], delete: [] })[t2.type] = t2.channels.map(function(e3) {
          return "string" == typeof e3 ? { channel: { id: e3 } } : { channel: { id: e3.id }, custom: e3.custom, status: e3.status };
        }), n2;
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2, r2, o2, i2, s2, u2, c2, l2, p2, h2 = { include: ["channel.status", "channel.type", "status"] };
        return (null == t2 ? void 0 : t2.include) && ((null === (n2 = t2.include) || void 0 === n2 ? void 0 : n2.customFields) && h2.include.push("custom"), (null === (r2 = t2.include) || void 0 === r2 ? void 0 : r2.customChannelFields) && h2.include.push("channel.custom"), (null === (o2 = t2.include) || void 0 === o2 ? void 0 : o2.channelFields) && h2.include.push("channel")), h2.include = h2.include.join(","), (null === (i2 = null == t2 ? void 0 : t2.include) || void 0 === i2 ? void 0 : i2.totalCount) && (h2.count = true), (null === (s2 = null == t2 ? void 0 : t2.page) || void 0 === s2 ? void 0 : s2.next) && (h2.start = null === (u2 = t2.page) || void 0 === u2 ? void 0 : u2.next), (null === (c2 = null == t2 ? void 0 : t2.page) || void 0 === c2 ? void 0 : c2.prev) && (h2.end = null === (l2 = t2.page) || void 0 === l2 ? void 0 : l2.prev), (null == t2 ? void 0 : t2.filter) && (h2.filter = t2.filter), null != t2.limit && (h2.limit = t2.limit), (null == t2 ? void 0 : t2.sort) && (h2.sort = Object.entries(null !== (p2 = t2.sort) && void 0 !== p2 ? p2 : {}).map(function(e3) {
          var t3 = a(e3, 2), n3 = t3[0], r3 = t3[1];
          return "asc" === r3 || "desc" === r3 ? "".concat(n3, ":").concat(r3) : n3;
        })), h2;
      }, handleResponse: function(e2, t2) {
        return { status: t2.status, data: t2.data, totalCount: t2.totalCount, prev: t2.prev, next: t2.next };
      } };
      var xe = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNAccessManagerAudit;
      }, validateParams: function(e2) {
        if (!e2.config.subscribeKey) return "Missing Subscribe Key";
      }, getURL: function(e2) {
        var t2 = e2.config;
        return "/v2/auth/audit/sub-key/".concat(t2.subscribeKey);
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return false;
      }, prepareParams: function(e2, t2) {
        var n2 = t2.channel, r2 = t2.channelGroup, o2 = t2.authKeys, i2 = void 0 === o2 ? [] : o2, s2 = {};
        return n2 && (s2.channel = n2), r2 && (s2["channel-group"] = r2), i2.length > 0 && (s2.auth = i2.join(",")), s2;
      }, handleResponse: function(e2, t2) {
        return t2.payload;
      } });
      var Ue = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNAccessManagerGrant;
      }, validateParams: function(e2, t2) {
        var n2 = e2.config;
        return n2.subscribeKey ? n2.publishKey ? n2.secretKey ? null == t2.uuids || t2.authKeys ? null == t2.uuids || null == t2.channels && null == t2.channelGroups ? void 0 : "Both channel/channelgroup and uuid cannot be used in the same request" : "authKeys are required for grant request on uuids" : "Missing Secret Key" : "Missing Publish Key" : "Missing Subscribe Key";
      }, getURL: function(e2) {
        var t2 = e2.config;
        return "/v2/auth/grant/sub-key/".concat(t2.subscribeKey);
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return false;
      }, prepareParams: function(e2, t2) {
        var n2 = t2.channels, r2 = void 0 === n2 ? [] : n2, o2 = t2.channelGroups, i2 = void 0 === o2 ? [] : o2, s2 = t2.uuids, a2 = void 0 === s2 ? [] : s2, u2 = t2.ttl, c2 = t2.read, l2 = void 0 !== c2 && c2, p2 = t2.write, h2 = void 0 !== p2 && p2, f2 = t2.manage, d2 = void 0 !== f2 && f2, y2 = t2.get, g2 = void 0 !== y2 && y2, m2 = t2.join, b2 = void 0 !== m2 && m2, v2 = t2.update, _2 = void 0 !== v2 && v2, S2 = t2.authKeys, w2 = void 0 === S2 ? [] : S2, O2 = t2.delete, P2 = {};
        return P2.r = l2 ? "1" : "0", P2.w = h2 ? "1" : "0", P2.m = d2 ? "1" : "0", P2.d = O2 ? "1" : "0", P2.g = g2 ? "1" : "0", P2.j = b2 ? "1" : "0", P2.u = _2 ? "1" : "0", r2.length > 0 && (P2.channel = r2.join(",")), i2.length > 0 && (P2["channel-group"] = i2.join(",")), w2.length > 0 && (P2.auth = w2.join(",")), a2.length > 0 && (P2["target-uuid"] = a2.join(",")), (u2 || 0 === u2) && (P2.ttl = u2), P2;
      }, handleResponse: function() {
        return {};
      } });
      function Ie(e2) {
        var t2, n2, r2, o2, i2 = void 0 !== (null == e2 ? void 0 : e2.authorizedUserId), s2 = void 0 !== (null === (t2 = null == e2 ? void 0 : e2.resources) || void 0 === t2 ? void 0 : t2.users), a2 = void 0 !== (null === (n2 = null == e2 ? void 0 : e2.resources) || void 0 === n2 ? void 0 : n2.spaces), u2 = void 0 !== (null === (r2 = null == e2 ? void 0 : e2.patterns) || void 0 === r2 ? void 0 : r2.users), c2 = void 0 !== (null === (o2 = null == e2 ? void 0 : e2.patterns) || void 0 === o2 ? void 0 : o2.spaces);
        return u2 || s2 || c2 || a2 || i2;
      }
      function De(e2) {
        var t2 = 0;
        return e2.join && (t2 |= 128), e2.update && (t2 |= 64), e2.get && (t2 |= 32), e2.delete && (t2 |= 8), e2.manage && (t2 |= 4), e2.write && (t2 |= 2), e2.read && (t2 |= 1), t2;
      }
      function Fe(e2, t2) {
        if (Ie(t2)) return function(e3, t3) {
          var n3 = t3.ttl, r3 = t3.resources, o3 = t3.patterns, i3 = t3.meta, s3 = t3.authorizedUserId, a3 = { ttl: 0, permissions: { resources: { channels: {}, groups: {}, uuids: {}, users: {}, spaces: {} }, patterns: { channels: {}, groups: {}, uuids: {}, users: {}, spaces: {} }, meta: {} } };
          if (r3) {
            var u3 = r3.users, c3 = r3.spaces, l3 = r3.groups;
            u3 && Object.keys(u3).forEach(function(e4) {
              a3.permissions.resources.uuids[e4] = De(u3[e4]);
            }), c3 && Object.keys(c3).forEach(function(e4) {
              a3.permissions.resources.channels[e4] = De(c3[e4]);
            }), l3 && Object.keys(l3).forEach(function(e4) {
              a3.permissions.resources.groups[e4] = De(l3[e4]);
            });
          }
          if (o3) {
            var p3 = o3.users, h3 = o3.spaces, f3 = o3.groups;
            p3 && Object.keys(p3).forEach(function(e4) {
              a3.permissions.patterns.uuids[e4] = De(p3[e4]);
            }), h3 && Object.keys(h3).forEach(function(e4) {
              a3.permissions.patterns.channels[e4] = De(h3[e4]);
            }), f3 && Object.keys(f3).forEach(function(e4) {
              a3.permissions.patterns.groups[e4] = De(f3[e4]);
            });
          }
          return (n3 || 0 === n3) && (a3.ttl = n3), i3 && (a3.permissions.meta = i3), s3 && (a3.permissions.uuid = "".concat(s3)), a3;
        }(0, t2);
        var n2 = t2.ttl, r2 = t2.resources, o2 = t2.patterns, i2 = t2.meta, s2 = t2.authorized_uuid, a2 = { ttl: 0, permissions: { resources: { channels: {}, groups: {}, uuids: {}, users: {}, spaces: {} }, patterns: { channels: {}, groups: {}, uuids: {}, users: {}, spaces: {} }, meta: {} } };
        if (r2) {
          var u2 = r2.uuids, c2 = r2.channels, l2 = r2.groups;
          u2 && Object.keys(u2).forEach(function(e3) {
            a2.permissions.resources.uuids[e3] = De(u2[e3]);
          }), c2 && Object.keys(c2).forEach(function(e3) {
            a2.permissions.resources.channels[e3] = De(c2[e3]);
          }), l2 && Object.keys(l2).forEach(function(e3) {
            a2.permissions.resources.groups[e3] = De(l2[e3]);
          });
        }
        if (o2) {
          var p2 = o2.uuids, h2 = o2.channels, f2 = o2.groups;
          p2 && Object.keys(p2).forEach(function(e3) {
            a2.permissions.patterns.uuids[e3] = De(p2[e3]);
          }), h2 && Object.keys(h2).forEach(function(e3) {
            a2.permissions.patterns.channels[e3] = De(h2[e3]);
          }), f2 && Object.keys(f2).forEach(function(e3) {
            a2.permissions.patterns.groups[e3] = De(f2[e3]);
          });
        }
        return (n2 || 0 === n2) && (a2.ttl = n2), i2 && (a2.permissions.meta = i2), s2 && (a2.permissions.uuid = "".concat(s2)), a2;
      }
      var Le = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNAccessManagerGrantToken;
      }, extractPermissions: De, validateParams: function(e2, t2) {
        var n2, r2, o2, i2, s2, a2, u2 = e2.config;
        if (!u2.subscribeKey) return "Missing Subscribe Key";
        if (!u2.publishKey) return "Missing Publish Key";
        if (!u2.secretKey) return "Missing Secret Key";
        if (!t2.resources && !t2.patterns) return "Missing either Resources or Patterns.";
        var c2 = void 0 !== (null == t2 ? void 0 : t2.authorized_uuid), l2 = void 0 !== (null === (n2 = null == t2 ? void 0 : t2.resources) || void 0 === n2 ? void 0 : n2.uuids), p2 = void 0 !== (null === (r2 = null == t2 ? void 0 : t2.resources) || void 0 === r2 ? void 0 : r2.channels), h2 = void 0 !== (null === (o2 = null == t2 ? void 0 : t2.resources) || void 0 === o2 ? void 0 : o2.groups), f2 = void 0 !== (null === (i2 = null == t2 ? void 0 : t2.patterns) || void 0 === i2 ? void 0 : i2.uuids), d2 = void 0 !== (null === (s2 = null == t2 ? void 0 : t2.patterns) || void 0 === s2 ? void 0 : s2.channels), y2 = void 0 !== (null === (a2 = null == t2 ? void 0 : t2.patterns) || void 0 === a2 ? void 0 : a2.groups), g2 = c2 || l2 || f2 || p2 || d2 || h2 || y2;
        return Ie(t2) && g2 ? "Cannot mix `users`, `spaces` and `authorizedUserId` with `uuids`, `channels`, `groups` and `authorized_uuid`" : (!t2.resources || t2.resources.uuids && 0 !== Object.keys(t2.resources.uuids).length || t2.resources.channels && 0 !== Object.keys(t2.resources.channels).length || t2.resources.groups && 0 !== Object.keys(t2.resources.groups).length || t2.resources.users && 0 !== Object.keys(t2.resources.users).length || t2.resources.spaces && 0 !== Object.keys(t2.resources.spaces).length) && (!t2.patterns || t2.patterns.uuids && 0 !== Object.keys(t2.patterns.uuids).length || t2.patterns.channels && 0 !== Object.keys(t2.patterns.channels).length || t2.patterns.groups && 0 !== Object.keys(t2.patterns.groups).length || t2.patterns.users && 0 !== Object.keys(t2.patterns.users).length || t2.patterns.spaces && 0 !== Object.keys(t2.patterns.spaces).length) ? void 0 : "Missing values for either Resources or Patterns.";
      }, postURL: function(e2) {
        var t2 = e2.config;
        return "/v3/pam/".concat(t2.subscribeKey, "/grant");
      }, usePost: function() {
        return true;
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return false;
      }, prepareParams: function() {
        return {};
      }, postPayload: function(e2, t2) {
        return Fe(0, t2);
      }, handleResponse: function(e2, t2) {
        return t2.data.token;
      } }), Ge = { getOperation: function() {
        return j.PNAccessManagerRevokeToken;
      }, validateParams: function(e2, t2) {
        return e2.config.secretKey ? t2 ? void 0 : "token can't be empty" : "Missing Secret Key";
      }, getURL: function(e2, t2) {
        var n2 = e2.config;
        return "/v3/pam/".concat(n2.subscribeKey, "/grant/").concat(H.encodeString(t2));
      }, useDelete: function() {
        return true;
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return false;
      }, prepareParams: function(e2) {
        return { uuid: e2.config.getUUID() };
      }, handleResponse: function(e2, t2) {
        return { status: t2.status, data: t2.data };
      } };
      function Ke(e2, t2) {
        var n2 = JSON.stringify(t2);
        if (e2.cryptoModule) {
          var r2 = e2.cryptoModule.encrypt(n2);
          n2 = "string" == typeof r2 ? r2 : b(r2), n2 = JSON.stringify(n2);
        }
        return n2 || "";
      }
      var Be = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNPublishOperation;
      }, validateParams: function(e2, t2) {
        var n2 = e2.config, r2 = t2.message;
        return t2.channel ? r2 ? n2.subscribeKey ? void 0 : "Missing Subscribe Key" : "Missing Message" : "Missing Channel";
      }, usePost: function(e2, t2) {
        var n2 = t2.sendByPost;
        return void 0 !== n2 && n2;
      }, getURL: function(e2, t2) {
        var n2 = e2.config, r2 = t2.channel, o2 = Ke(e2, t2.message);
        return "/publish/".concat(n2.publishKey, "/").concat(n2.subscribeKey, "/0/").concat(H.encodeString(r2), "/0/").concat(H.encodeString(o2));
      }, postURL: function(e2, t2) {
        var n2 = e2.config, r2 = t2.channel;
        return "/publish/".concat(n2.publishKey, "/").concat(n2.subscribeKey, "/0/").concat(H.encodeString(r2), "/0");
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, postPayload: function(e2, t2) {
        return Ke(e2, t2.message);
      }, prepareParams: function(e2, t2) {
        var n2 = t2.meta, r2 = t2.replicate, o2 = void 0 === r2 || r2, i2 = t2.storeInHistory, s2 = t2.ttl, a2 = {};
        return null != i2 && (a2.store = i2 ? "1" : "0"), s2 && (a2.ttl = s2), false === o2 && (a2.norep = "true"), n2 && "object" == typeof n2 && (a2.meta = JSON.stringify(n2)), a2;
      }, handleResponse: function(e2, t2) {
        return { timetoken: t2[2] };
      } });
      var He = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNSignalOperation;
      }, validateParams: function(e2, t2) {
        var n2 = e2.config, r2 = t2.message;
        return t2.channel ? r2 ? n2.subscribeKey ? void 0 : "Missing Subscribe Key" : "Missing Message" : "Missing Channel";
      }, getURL: function(e2, t2) {
        var n2, r2 = e2.config, o2 = t2.channel, i2 = t2.message, s2 = (n2 = i2, JSON.stringify(n2));
        return "/signal/".concat(r2.publishKey, "/").concat(r2.subscribeKey, "/0/").concat(H.encodeString(o2), "/0/").concat(H.encodeString(s2));
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function() {
        return {};
      }, handleResponse: function(e2, t2) {
        return { timetoken: t2[2] };
      } });
      var qe = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNHistoryOperation;
      }, validateParams: function(e2, t2) {
        var n2 = t2.channel, r2 = e2.config;
        return n2 ? r2.subscribeKey ? void 0 : "Missing Subscribe Key" : "Missing channel";
      }, getURL: function(e2, t2) {
        var n2 = t2.channel, r2 = e2.config;
        return "/v2/history/sub-key/".concat(r2.subscribeKey, "/channel/").concat(H.encodeString(n2));
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2 = t2.start, r2 = t2.end, o2 = t2.reverse, i2 = t2.count, s2 = void 0 === i2 ? 100 : i2, a2 = t2.stringifiedTimeToken, u2 = void 0 !== a2 && a2, c2 = t2.includeMeta, l2 = void 0 !== c2 && c2, p2 = { include_token: "true" };
        return p2.count = s2, n2 && (p2.start = n2), r2 && (p2.end = r2), u2 && (p2.string_message_token = "true"), null != o2 && (p2.reverse = o2.toString()), l2 && (p2.include_meta = "true"), p2;
      }, handleResponse: function(e2, t2) {
        var n2 = { messages: [], startTimeToken: t2[1], endTimeToken: t2[2] };
        return Array.isArray(t2[0]) && t2[0].forEach(function(t3) {
          var r2 = function(e3, t4) {
            var n3 = {};
            if (!e3.cryptoModule) return n3.payload = t4, n3;
            try {
              var r3 = e3.cryptoModule.decrypt(t4), o3 = r3 instanceof ArrayBuffer ? JSON.parse(new TextDecoder().decode(r3)) : r3;
              return n3.payload = o3, n3;
            } catch (r4) {
              e3.config.logVerbosity && console && console.log && console.log("decryption error", r4.message), n3.payload = t4, n3.error = "Error while decrypting message content: ".concat(r4.message);
            }
            return n3;
          }(e2, t3.message), o2 = { timetoken: t3.timetoken, entry: r2.payload };
          t3.meta && (o2.meta = t3.meta), r2.error && (o2.error = r2.error), n2.messages.push(o2);
        }), n2;
      } });
      var ze = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNDeleteMessagesOperation;
      }, validateParams: function(e2, t2) {
        var n2 = t2.channel, r2 = e2.config;
        return n2 ? r2.subscribeKey ? void 0 : "Missing Subscribe Key" : "Missing channel";
      }, useDelete: function() {
        return true;
      }, getURL: function(e2, t2) {
        var n2 = t2.channel, r2 = e2.config;
        return "/v3/history/sub-key/".concat(r2.subscribeKey, "/channel/").concat(H.encodeString(n2));
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2 = t2.start, r2 = t2.end, o2 = {};
        return n2 && (o2.start = n2), r2 && (o2.end = r2), o2;
      }, handleResponse: function(e2, t2) {
        return t2.payload;
      } });
      var Ve = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNMessageCounts;
      }, validateParams: function(e2, t2) {
        var n2 = t2.channels, r2 = t2.timetoken, o2 = t2.channelTimetokens, i2 = e2.config;
        return n2 ? r2 && o2 ? "timetoken and channelTimetokens are incompatible together" : o2 && o2.length > 1 && n2.length !== o2.length ? "Length of channelTimetokens and channels do not match" : i2.subscribeKey ? void 0 : "Missing Subscribe Key" : "Missing channel";
      }, getURL: function(e2, t2) {
        var n2 = t2.channels, r2 = e2.config, o2 = n2.join(",");
        return "/v3/history/sub-key/".concat(r2.subscribeKey, "/message-counts/").concat(H.encodeString(o2));
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2 = t2.timetoken, r2 = t2.channelTimetokens, o2 = {};
        if (r2 && 1 === r2.length) {
          var i2 = a(r2, 1)[0];
          o2.timetoken = i2;
        } else r2 ? o2.channelsTimetoken = r2.join(",") : n2 && (o2.timetoken = n2);
        return o2;
      }, handleResponse: function(e2, t2) {
        return { channels: t2.channels };
      } });
      var We = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNFetchMessagesOperation;
      }, validateParams: function(e2, t2) {
        var n2 = t2.channels, r2 = t2.includeMessageActions, o2 = void 0 !== r2 && r2, i2 = e2.config;
        if (!n2 || 0 === n2.length) return "Missing channels";
        if (!i2.subscribeKey) return "Missing Subscribe Key";
        if (o2 && n2.length > 1) throw new TypeError("History can return actions data for a single channel only. Either pass a single channel or disable the includeMessageActions flag.");
      }, getURL: function(e2, t2) {
        var n2 = t2.channels, r2 = void 0 === n2 ? [] : n2, o2 = t2.includeMessageActions, i2 = void 0 !== o2 && o2, s2 = e2.config, a2 = i2 ? "history-with-actions" : "history", u2 = r2.length > 0 ? r2.join(",") : ",";
        return "/v3/".concat(a2, "/sub-key/").concat(s2.subscribeKey, "/channel/").concat(H.encodeString(u2));
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2 = t2.channels, r2 = t2.start, o2 = t2.end, i2 = t2.includeMessageActions, s2 = t2.count, a2 = t2.stringifiedTimeToken, u2 = void 0 !== a2 && a2, c2 = t2.includeMeta, l2 = void 0 !== c2 && c2, p2 = t2.includeUuid, h2 = t2.includeUUID, f2 = void 0 === h2 || h2, d2 = t2.includeMessageType, y2 = void 0 === d2 || d2, g2 = {};
        return g2.max = s2 || (n2.length > 1 || true === i2 ? 25 : 100), r2 && (g2.start = r2), o2 && (g2.end = o2), u2 && (g2.string_message_token = "true"), l2 && (g2.include_meta = "true"), f2 && false !== p2 && (g2.include_uuid = "true"), y2 && (g2.include_message_type = "true"), g2;
      }, handleResponse: function(e2, t2) {
        var n2 = { channels: {} };
        return Object.keys(t2.channels || {}).forEach(function(r2) {
          n2.channels[r2] = [], (t2.channels[r2] || []).forEach(function(t3) {
            var o2 = {}, i2 = function(e3, t4) {
              var n3 = {};
              if (!e3.cryptoModule) return n3.payload = t4, n3;
              try {
                var r3 = e3.cryptoModule.decrypt(t4), o3 = r3 instanceof ArrayBuffer ? JSON.parse(new TextDecoder().decode(r3)) : r3;
                return n3.payload = o3, n3;
              } catch (r4) {
                e3.config.logVerbosity && console && console.log && console.log("decryption error", r4.message), n3.payload = t4, n3.error = "Error while decrypting message content: ".concat(r4.message);
              }
              return n3;
            }(e2, t3.message);
            o2.channel = r2, o2.timetoken = t3.timetoken, o2.message = i2.payload, o2.messageType = t3.message_type, o2.uuid = t3.uuid, t3.actions && (o2.actions = t3.actions, o2.data = t3.actions), t3.meta && (o2.meta = t3.meta), i2.error && (o2.error = i2.error), n2.channels[r2].push(o2);
          });
        }), t2.more && (n2.more = t2.more), n2;
      } });
      var Je = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNTimeOperation;
      }, getURL: function() {
        return "/time/0";
      }, getRequestTimeout: function(e2) {
        return e2.config.getTransactionTimeout();
      }, prepareParams: function() {
        return {};
      }, isAuthSupported: function() {
        return false;
      }, handleResponse: function(e2, t2) {
        return { timetoken: t2[0] };
      }, validateParams: function() {
      } });
      var $e = Object.freeze({ __proto__: null, getOperation: function() {
        return j.PNSubscribeOperation;
      }, validateParams: function(e2) {
        if (!e2.config.subscribeKey) return "Missing Subscribe Key";
      }, getURL: function(e2, t2) {
        var n2 = e2.config, r2 = t2.channels, o2 = void 0 === r2 ? [] : r2, i2 = o2.length > 0 ? o2.join(",") : ",";
        return "/v2/subscribe/".concat(n2.subscribeKey, "/").concat(H.encodeString(i2), "/0");
      }, getRequestTimeout: function(e2) {
        return e2.config.getSubscribeTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2 = e2.config, r2 = t2.state, o2 = t2.channelGroups, i2 = void 0 === o2 ? [] : o2, s2 = t2.timetoken, a2 = t2.filterExpression, u2 = t2.region, c2 = { heartbeat: n2.getPresenceTimeout() };
        return i2.length > 0 && (c2["channel-group"] = i2.join(",")), a2 && a2.length > 0 && (c2["filter-expr"] = a2), Object.keys(r2).length && (c2.state = JSON.stringify(r2)), s2 && (c2.tt = s2), u2 && (c2.tr = u2), c2;
      }, handleResponse: function(e2, t2) {
        var n2 = [];
        t2.m.forEach(function(e3) {
          var t3 = { timetoken: e3.p.t, region: e3.p.r }, r3 = { shard: parseInt(e3.a, 10), subscriptionMatch: e3.b, channel: e3.c, messageType: e3.e, payload: e3.d, flags: e3.f, issuingClientId: e3.i, subscribeKey: e3.k, originationTimetoken: e3.o, userMetadata: e3.u, publishMetaData: t3 };
          n2.push(r3);
        });
        var r2 = { timetoken: t2.t.t, region: t2.t.r };
        return { messages: n2, metadata: r2 };
      } }), Qe = { getOperation: function() {
        return j.PNHandshakeOperation;
      }, validateParams: function(e2, t2) {
        if (!(null == t2 ? void 0 : t2.channels) && !(null == t2 ? void 0 : t2.channelGroups)) return "channels and channleGroups both should not be empty";
      }, getURL: function(e2, t2) {
        var n2 = e2.config, r2 = t2.channels, o2 = void 0 === r2 ? [] : r2, i2 = o2.length > 0 ? o2.join(",") : ",";
        return "/v2/subscribe/".concat(n2.subscribeKey, "/").concat(H.encodeString(i2), "/0");
      }, getRequestTimeout: function(e2) {
        return e2.config.getSubscribeTimeout();
      }, isAuthSupported: function() {
        return true;
      }, prepareParams: function(e2, t2) {
        var n2 = {};
        return t2.channelGroups && t2.channelGroups.length > 0 && (n2["channel-group"] = t2.channelGroups.join(",")), n2.tt = 0, t2.state && (n2.state = JSON.stringify(t2.state)), t2.filterExpression && t2.filterExpression.length > 0 && (n2["filter-expr"] = t2.filterExpression), n2.ee = "", n2;
      }, handleResponse: function(e2, t2) {
        return { region: t2.t.r, timetoken: t2.t.t };
      } }, Xe = { getOperation: function() {
        return j.PNReceiveMessagesOperation;
      }, validateParams: function(e2, t2) {
        return (null == t2 ? void 0 : t2.channels) || (null == t2 ? void 0 : t2.channelGroups) ? (null == t2 ? void 0 : t2.timetoken) ? (null == t2 ? void 0 : t2.region) ? void 0 : "region can not be empty" : "timetoken can not be empty" : "channels and channleGroups both should not be empty";
      }, getURL: function(e2, t2) {
        var n2 = e2.config, r2 = t2.channels, o2 = void 0 === r2 ? [] : r2, i2 = o2.length > 0 ? o2.join(",") : ",";
        return "/v2/subscribe/".concat(n2.subscribeKey, "/").concat(H.encodeString(i2), "/0");
      }, getRequestTimeout: function(e2) {
        return e2.config.getSubscribeTimeout();
      }, isAuthSupported: function() {
        return true;
      }, getAbortSignal: function(e2, t2) {
        return t2.abortSignal;
      }, prepareParams: function(e2, t2) {
        var n2 = {};
        return t2.channelGroups && t2.channelGroups.length > 0 && (n2["channel-group"] = t2.channelGroups.join(",")), t2.filterExpression && t2.filterExpression.length > 0 && (n2["filter-expr"] = t2.filterExpression), n2.tt = t2.timetoken, n2.tr = t2.region, n2.ee = "", n2;
      }, handleResponse: function(e2, t2) {
        var n2 = [];
        return t2.m.forEach(function(e3) {
          var t3 = { shard: parseInt(e3.a, 10), subscriptionMatch: e3.b, channel: e3.c, messageType: e3.e, payload: e3.d, flags: e3.f, issuingClientId: e3.i, subscribeKey: e3.k, originationTimetoken: e3.o, userMetadata: e3.u, publishMetaData: { timetoken: e3.p.t, region: e3.p.r } };
          n2.push(t3);
        }), { messages: n2, metadata: { region: t2.t.r, timetoken: t2.t.t } };
      } }, Ye = function() {
        function e2(e3) {
          void 0 === e3 && (e3 = false), this.sync = e3, this.listeners = /* @__PURE__ */ new Set();
        }
        return e2.prototype.subscribe = function(e3) {
          var t2 = this;
          return this.listeners.add(e3), function() {
            t2.listeners.delete(e3);
          };
        }, e2.prototype.notify = function(e3) {
          var t2 = this, n2 = function() {
            t2.listeners.forEach(function(t3) {
              t3(e3);
            });
          };
          this.sync ? n2() : setTimeout(n2, 0);
        }, e2;
      }(), Ze = function() {
        function e2(e3) {
          this.label = e3, this.transitionMap = /* @__PURE__ */ new Map(), this.enterEffects = [], this.exitEffects = [];
        }
        return e2.prototype.transition = function(e3, t2) {
          var n2;
          if (this.transitionMap.has(t2.type)) return null === (n2 = this.transitionMap.get(t2.type)) || void 0 === n2 ? void 0 : n2(e3, t2);
        }, e2.prototype.on = function(e3, t2) {
          return this.transitionMap.set(e3, t2), this;
        }, e2.prototype.with = function(e3, t2) {
          return [this, e3, null != t2 ? t2 : []];
        }, e2.prototype.onEnter = function(e3) {
          return this.enterEffects.push(e3), this;
        }, e2.prototype.onExit = function(e3) {
          return this.exitEffects.push(e3), this;
        }, e2;
      }(), et = function(e2) {
        function n2() {
          return null !== e2 && e2.apply(this, arguments) || this;
        }
        return t(n2, e2), n2.prototype.describe = function(e3) {
          return new Ze(e3);
        }, n2.prototype.start = function(e3, t2) {
          this.currentState = e3, this.currentContext = t2, this.notify({ type: "engineStarted", state: e3, context: t2 });
        }, n2.prototype.transition = function(e3) {
          var t2, n3, r2, o2, i2, u2;
          if (!this.currentState) throw new Error("Start the engine first");
          this.notify({ type: "eventReceived", event: e3 });
          var c2 = this.currentState.transition(this.currentContext, e3);
          if (c2) {
            var l2 = a(c2, 3), p2 = l2[0], h2 = l2[1], f2 = l2[2];
            try {
              for (var d2 = s(this.currentState.exitEffects), y2 = d2.next(); !y2.done; y2 = d2.next()) {
                var g2 = y2.value;
                this.notify({ type: "invocationDispatched", invocation: g2(this.currentContext) });
              }
            } catch (e4) {
              t2 = { error: e4 };
            } finally {
              try {
                y2 && !y2.done && (n3 = d2.return) && n3.call(d2);
              } finally {
                if (t2) throw t2.error;
              }
            }
            var m2 = this.currentState;
            this.currentState = p2;
            var b2 = this.currentContext;
            this.currentContext = h2, this.notify({ type: "transitionDone", fromState: m2, fromContext: b2, toState: p2, toContext: h2, event: e3 });
            try {
              for (var v2 = s(f2), _2 = v2.next(); !_2.done; _2 = v2.next()) {
                g2 = _2.value;
                this.notify({ type: "invocationDispatched", invocation: g2 });
              }
            } catch (e4) {
              r2 = { error: e4 };
            } finally {
              try {
                _2 && !_2.done && (o2 = v2.return) && o2.call(v2);
              } finally {
                if (r2) throw r2.error;
              }
            }
            try {
              for (var S2 = s(this.currentState.enterEffects), w2 = S2.next(); !w2.done; w2 = S2.next()) {
                g2 = w2.value;
                this.notify({ type: "invocationDispatched", invocation: g2(this.currentContext) });
              }
            } catch (e4) {
              i2 = { error: e4 };
            } finally {
              try {
                w2 && !w2.done && (u2 = S2.return) && u2.call(S2);
              } finally {
                if (i2) throw i2.error;
              }
            }
          }
        }, n2;
      }(Ye), tt = function() {
        function e2(e3) {
          this.dependencies = e3, this.instances = /* @__PURE__ */ new Map(), this.handlers = /* @__PURE__ */ new Map();
        }
        return e2.prototype.on = function(e3, t2) {
          this.handlers.set(e3, t2);
        }, e2.prototype.dispatch = function(e3) {
          if ("CANCEL" !== e3.type) {
            var t2 = this.handlers.get(e3.type);
            if (!t2) throw new Error("Unhandled invocation '".concat(e3.type, "'"));
            var n2 = t2(e3.payload, this.dependencies);
            e3.managed && this.instances.set(e3.type, n2), n2.start();
          } else if (this.instances.has(e3.payload)) {
            var r2 = this.instances.get(e3.payload);
            null == r2 || r2.cancel(), this.instances.delete(e3.payload);
          }
        }, e2.prototype.dispose = function() {
          var e3, t2;
          try {
            for (var n2 = s(this.instances.entries()), r2 = n2.next(); !r2.done; r2 = n2.next()) {
              var o2 = a(r2.value, 2), i2 = o2[0];
              o2[1].cancel(), this.instances.delete(i2);
            }
          } catch (t3) {
            e3 = { error: t3 };
          } finally {
            try {
              r2 && !r2.done && (t2 = n2.return) && t2.call(n2);
            } finally {
              if (e3) throw e3.error;
            }
          }
        }, e2;
      }();
      function nt(e2, t2) {
        var n2 = function() {
          for (var n3 = [], r2 = 0; r2 < arguments.length; r2++) n3[r2] = arguments[r2];
          return { type: e2, payload: null == t2 ? void 0 : t2.apply(void 0, u([], a(n3), false)) };
        };
        return n2.type = e2, n2;
      }
      function rt(e2, t2) {
        var n2 = function() {
          for (var n3 = [], r2 = 0; r2 < arguments.length; r2++) n3[r2] = arguments[r2];
          return { type: e2, payload: t2.apply(void 0, u([], a(n3), false)), managed: false };
        };
        return n2.type = e2, n2;
      }
      function ot(e2, t2) {
        var n2 = function() {
          for (var n3 = [], r2 = 0; r2 < arguments.length; r2++) n3[r2] = arguments[r2];
          return { type: e2, payload: t2.apply(void 0, u([], a(n3), false)), managed: true };
        };
        return n2.type = e2, n2.cancel = { type: "CANCEL", payload: e2, managed: false }, n2;
      }
      var it = function(e2) {
        function n2() {
          var t2 = this.constructor, n3 = e2.call(this, "The operation was aborted.") || this;
          return n3.name = "AbortError", Object.setPrototypeOf(n3, t2.prototype), n3;
        }
        return t(n2, e2), n2;
      }(Error), st = function(e2) {
        function n2() {
          var t2 = null !== e2 && e2.apply(this, arguments) || this;
          return t2._aborted = false, t2;
        }
        return t(n2, e2), Object.defineProperty(n2.prototype, "aborted", { get: function() {
          return this._aborted;
        }, enumerable: false, configurable: true }), n2.prototype.throwIfAborted = function() {
          if (this._aborted) throw new it();
        }, n2.prototype.abort = function() {
          this._aborted = true, this.notify(new it());
        }, n2;
      }(Ye), at = function(e2) {
        function n2(t2, n3, r2) {
          var o2 = e2.call(this, t2, n3) || this;
          return o2.asyncFunction = r2, o2.abortSignal = new st(), o2;
        }
        return t(n2, e2), n2.prototype.start = function() {
          this.asyncFunction(this.payload, this.abortSignal, this.dependencies).catch(function(e3) {
          });
        }, n2.prototype.cancel = function() {
          this.abortSignal.abort();
        }, n2;
      }(function(e2, t2) {
        this.payload = e2, this.dependencies = t2;
      }), ut = function(e2) {
        return function(t2, n2) {
          return new at(t2, n2, e2);
        };
      }, ct = ot("HANDSHAKE", function(e2, t2) {
        return { channels: e2, groups: t2 };
      }), lt = ot("RECEIVE_MESSAGES", function(e2, t2, n2) {
        return { channels: e2, groups: t2, cursor: n2 };
      }), pt = rt("EMIT_MESSAGES", function(e2) {
        return e2;
      }), ht = rt("EMIT_STATUS", function(e2) {
        return e2;
      }), ft = ot("RECEIVE_RECONNECT", function(e2) {
        return e2;
      }), dt = ot("HANDSHAKE_RECONNECT", function(e2) {
        return e2;
      }), yt = nt("SUBSCRIPTION_CHANGED", function(e2, t2) {
        return { channels: e2, groups: t2 };
      }), gt = nt("SUBSCRIPTION_RESTORED", function(e2, t2, n2, r2) {
        return { channels: e2, groups: t2, cursor: { timetoken: n2, region: null != r2 ? r2 : 0 } };
      }), mt = nt("HANDSHAKE_SUCCESS", function(e2) {
        return e2;
      }), bt = nt("HANDSHAKE_FAILURE", function(e2) {
        return e2;
      }), vt = nt("HANDSHAKE_RECONNECT_SUCCESS", function(e2) {
        return { cursor: e2 };
      }), _t = nt("HANDSHAKE_RECONNECT_FAILURE", function(e2) {
        return e2;
      }), St = nt("HANDSHAKE_RECONNECT_GIVEUP", function(e2) {
        return e2;
      }), wt = nt("RECEIVE_SUCCESS", function(e2, t2) {
        return { cursor: e2, events: t2 };
      }), Ot = nt("RECEIVE_FAILURE", function(e2) {
        return e2;
      }), Pt = nt("RECEIVE_RECONNECT_SUCCESS", function(e2, t2) {
        return { cursor: e2, events: t2 };
      }), Et = nt("RECEIVE_RECONNECT_FAILURE", function(e2) {
        return e2;
      }), At = nt("RECEIVING_RECONNECT_GIVEUP", function(e2) {
        return e2;
      }), Tt = nt("DISCONNECT", function() {
        return {};
      }), Nt = nt("RECONNECT", function(e2, t2) {
        return { cursor: { timetoken: null != e2 ? e2 : "", region: null != t2 ? t2 : 0 } };
      }), Ct = nt("UNSUBSCRIBE_ALL", function() {
        return {};
      }), kt = function(e2) {
        function r2(t2, r3) {
          var s2 = e2.call(this, r3) || this;
          return s2.on(ct.type, ut(function(e3, r4, a2) {
            var u2 = a2.handshake, c2 = a2.presenceState, l2 = a2.config;
            return o(s2, void 0, void 0, function() {
              var o2, s3;
              return i(this, function(i2) {
                switch (i2.label) {
                  case 0:
                    r4.throwIfAborted(), i2.label = 1;
                  case 1:
                    return i2.trys.push([1, 3, , 4]), [4, u2(n({ abortSignal: r4, channels: e3.channels, channelGroups: e3.groups, filterExpression: l2.filterExpression }, l2.maintainPresenceState && { state: c2 }))];
                  case 2:
                    return o2 = i2.sent(), [2, t2.transition(mt(o2))];
                  case 3:
                    return (s3 = i2.sent()) instanceof Error && "Aborted" === s3.message ? [2] : s3 instanceof q ? [2, t2.transition(bt(s3))] : [3, 4];
                  case 4:
                    return [2];
                }
              });
            });
          })), s2.on(lt.type, ut(function(e3, n2, r4) {
            var a2 = r4.receiveMessages, u2 = r4.config;
            return o(s2, void 0, void 0, function() {
              var r5, o2;
              return i(this, function(i2) {
                switch (i2.label) {
                  case 0:
                    n2.throwIfAborted(), i2.label = 1;
                  case 1:
                    return i2.trys.push([1, 3, , 4]), [4, a2({ abortSignal: n2, channels: e3.channels, channelGroups: e3.groups, timetoken: e3.cursor.timetoken, region: e3.cursor.region, filterExpression: u2.filterExpression })];
                  case 2:
                    return r5 = i2.sent(), t2.transition(wt(r5.metadata, r5.messages)), [3, 4];
                  case 3:
                    return (o2 = i2.sent()) instanceof Error && "Aborted" === o2.message ? [2] : o2 instanceof q && !n2.aborted ? [2, t2.transition(Ot(o2))] : [3, 4];
                  case 4:
                    return [2];
                }
              });
            });
          })), s2.on(pt.type, ut(function(e3, t3, n2) {
            var r4 = n2.emitMessages;
            return o(s2, void 0, void 0, function() {
              return i(this, function(t4) {
                return e3.length > 0 && r4(e3), [2];
              });
            });
          })), s2.on(ht.type, ut(function(e3, t3, n2) {
            var r4 = n2.emitStatus;
            return o(s2, void 0, void 0, function() {
              return i(this, function(t4) {
                return r4(e3), [2];
              });
            });
          })), s2.on(ft.type, ut(function(e3, n2, r4) {
            var a2 = r4.receiveMessages, u2 = r4.delay, c2 = r4.config;
            return o(s2, void 0, void 0, function() {
              var r5, o2;
              return i(this, function(i2) {
                switch (i2.label) {
                  case 0:
                    return c2.retryConfiguration && c2.retryConfiguration.shouldRetry(e3.reason, e3.attempts) ? (n2.throwIfAborted(), [4, u2(c2.retryConfiguration.getDelay(e3.attempts, e3.reason))]) : [3, 6];
                  case 1:
                    i2.sent(), n2.throwIfAborted(), i2.label = 2;
                  case 2:
                    return i2.trys.push([2, 4, , 5]), [4, a2({ abortSignal: n2, channels: e3.channels, channelGroups: e3.groups, timetoken: e3.cursor.timetoken, region: e3.cursor.region, filterExpression: c2.filterExpression })];
                  case 3:
                    return r5 = i2.sent(), [2, t2.transition(Pt(r5.metadata, r5.messages))];
                  case 4:
                    return (o2 = i2.sent()) instanceof Error && "Aborted" === o2.message ? [2] : o2 instanceof q ? [2, t2.transition(Et(o2))] : [3, 5];
                  case 5:
                    return [3, 7];
                  case 6:
                    return [2, t2.transition(At(new q(c2.retryConfiguration.getGiveupReason(e3.reason, e3.attempts))))];
                  case 7:
                    return [2];
                }
              });
            });
          })), s2.on(dt.type, ut(function(e3, r4, a2) {
            var u2 = a2.handshake, c2 = a2.delay, l2 = a2.presenceState, p2 = a2.config;
            return o(s2, void 0, void 0, function() {
              var o2, s3;
              return i(this, function(i2) {
                switch (i2.label) {
                  case 0:
                    return p2.retryConfiguration && p2.retryConfiguration.shouldRetry(e3.reason, e3.attempts) ? (r4.throwIfAborted(), [4, c2(p2.retryConfiguration.getDelay(e3.attempts, e3.reason))]) : [3, 6];
                  case 1:
                    i2.sent(), r4.throwIfAborted(), i2.label = 2;
                  case 2:
                    return i2.trys.push([2, 4, , 5]), [4, u2(n({ abortSignal: r4, channels: e3.channels, channelGroups: e3.groups, filterExpression: p2.filterExpression }, p2.maintainPresenceState && { state: l2 }))];
                  case 3:
                    return o2 = i2.sent(), [2, t2.transition(vt(o2))];
                  case 4:
                    return (s3 = i2.sent()) instanceof Error && "Aborted" === s3.message ? [2] : s3 instanceof q ? [2, t2.transition(_t(s3))] : [3, 5];
                  case 5:
                    return [3, 7];
                  case 6:
                    return [2, t2.transition(St(new q(p2.retryConfiguration.getGiveupReason(e3.reason, e3.attempts))))];
                  case 7:
                    return [2];
                }
              });
            });
          })), s2;
        }
        return t(r2, e2), r2;
      }(tt), Mt = new Ze("HANDSHAKE_FAILED");
      Mt.on(yt.type, function(e2, t2) {
        return Ft.with({ channels: t2.payload.channels, groups: t2.payload.groups, cursor: e2.cursor });
      }), Mt.on(Nt.type, function(e2, t2) {
        return Ft.with({ channels: e2.channels, groups: e2.groups, cursor: t2.payload.cursor || e2.cursor });
      }), Mt.on(gt.type, function(e2, t2) {
        var n2, r2;
        return Ft.with({ channels: t2.payload.channels, groups: t2.payload.groups, cursor: { timetoken: t2.payload.cursor.timetoken, region: t2.payload.cursor.region ? t2.payload.cursor.region : null !== (r2 = null === (n2 = null == e2 ? void 0 : e2.cursor) || void 0 === n2 ? void 0 : n2.region) && void 0 !== r2 ? r2 : 0 } });
      }), Mt.on(Ct.type, function(e2) {
        return Lt.with();
      });
      var jt = new Ze("HANDSHAKE_STOPPED");
      jt.on(yt.type, function(e2, t2) {
        return jt.with({ channels: t2.payload.channels, groups: t2.payload.groups, cursor: e2.cursor });
      }), jt.on(Nt.type, function(e2, t2) {
        return Ft.with(n(n({}, e2), { cursor: t2.payload.cursor || e2.cursor }));
      }), jt.on(gt.type, function(e2, t2) {
        var n2;
        return jt.with({ channels: t2.payload.channels, groups: t2.payload.groups, cursor: { timetoken: t2.payload.cursor.timetoken, region: t2.payload.cursor.region || (null === (n2 = null == e2 ? void 0 : e2.cursor) || void 0 === n2 ? void 0 : n2.region) || 0 } });
      }), jt.on(Ct.type, function(e2) {
        return Lt.with();
      });
      var Rt = new Ze("RECEIVE_FAILED");
      Rt.on(Nt.type, function(e2, t2) {
        var n2;
        return Ft.with({ channels: e2.channels, groups: e2.groups, cursor: { timetoken: t2.payload.cursor.timetoken ? null === (n2 = t2.payload.cursor) || void 0 === n2 ? void 0 : n2.timetoken : e2.cursor.timetoken, region: t2.payload.cursor.region || e2.cursor.region } });
      }), Rt.on(yt.type, function(e2, t2) {
        return Ft.with({ channels: t2.payload.channels, groups: t2.payload.groups, cursor: e2.cursor });
      }), Rt.on(gt.type, function(e2, t2) {
        return Ft.with({ channels: t2.payload.channels, groups: t2.payload.groups, cursor: { timetoken: t2.payload.cursor.timetoken, region: t2.payload.cursor.region || e2.cursor.region } });
      }), Rt.on(Ct.type, function(e2) {
        return Lt.with(void 0);
      });
      var xt = new Ze("RECEIVE_STOPPED");
      xt.on(yt.type, function(e2, t2) {
        return xt.with({ channels: t2.payload.channels, groups: t2.payload.groups, cursor: e2.cursor });
      }), xt.on(gt.type, function(e2, t2) {
        return xt.with({ channels: t2.payload.channels, groups: t2.payload.groups, cursor: { timetoken: t2.payload.cursor.timetoken, region: t2.payload.cursor.region || e2.cursor.region } });
      }), xt.on(Nt.type, function(e2, t2) {
        var n2;
        return Ft.with({ channels: e2.channels, groups: e2.groups, cursor: { timetoken: t2.payload.cursor.timetoken ? null === (n2 = t2.payload.cursor) || void 0 === n2 ? void 0 : n2.timetoken : e2.cursor.timetoken, region: t2.payload.cursor.region || e2.cursor.region } });
      }), xt.on(Ct.type, function() {
        return Lt.with(void 0);
      });
      var Ut = new Ze("RECEIVE_RECONNECTING");
      Ut.onEnter(function(e2) {
        return ft(e2);
      }), Ut.onExit(function() {
        return ft.cancel;
      }), Ut.on(Pt.type, function(e2, t2) {
        return It.with({ channels: e2.channels, groups: e2.groups, cursor: t2.payload.cursor }, [pt(t2.payload.events)]);
      }), Ut.on(Et.type, function(e2, t2) {
        return Ut.with(n(n({}, e2), { attempts: e2.attempts + 1, reason: t2.payload }));
      }), Ut.on(At.type, function(e2, t2) {
        var n2;
        return Rt.with({ groups: e2.groups, channels: e2.channels, cursor: e2.cursor, reason: t2.payload }, [ht({ category: k.PNDisconnectedUnexpectedlyCategory, error: null === (n2 = t2.payload) || void 0 === n2 ? void 0 : n2.message })]);
      }), Ut.on(Tt.type, function(e2) {
        return xt.with({ channels: e2.channels, groups: e2.groups, cursor: e2.cursor }, [ht({ category: k.PNDisconnectedCategory })]);
      }), Ut.on(gt.type, function(e2, t2) {
        return It.with({ channels: t2.payload.channels, groups: t2.payload.groups, cursor: { timetoken: t2.payload.cursor.timetoken, region: t2.payload.cursor.region || e2.cursor.region } });
      }), Ut.on(yt.type, function(e2, t2) {
        return It.with({ channels: t2.payload.channels, groups: t2.payload.groups, cursor: e2.cursor });
      }), Ut.on(Ct.type, function(e2) {
        return Lt.with(void 0, [ht({ category: k.PNDisconnectedCategory })]);
      });
      var It = new Ze("RECEIVING");
      It.onEnter(function(e2) {
        return lt(e2.channels, e2.groups, e2.cursor);
      }), It.onExit(function() {
        return lt.cancel;
      }), It.on(wt.type, function(e2, t2) {
        return It.with({ channels: e2.channels, groups: e2.groups, cursor: t2.payload.cursor }, [pt(t2.payload.events)]);
      }), It.on(yt.type, function(e2, t2) {
        return 0 === t2.payload.channels.length && 0 === t2.payload.groups.length ? Lt.with(void 0) : It.with({ cursor: e2.cursor, channels: t2.payload.channels, groups: t2.payload.groups });
      }), It.on(gt.type, function(e2, t2) {
        return 0 === t2.payload.channels.length && 0 === t2.payload.groups.length ? Lt.with(void 0) : It.with({ channels: t2.payload.channels, groups: t2.payload.groups, cursor: { timetoken: t2.payload.cursor.timetoken, region: t2.payload.cursor.region || e2.cursor.region } });
      }), It.on(Ot.type, function(e2, t2) {
        return Ut.with(n(n({}, e2), { attempts: 0, reason: t2.payload }));
      }), It.on(Tt.type, function(e2) {
        return xt.with({ channels: e2.channels, groups: e2.groups, cursor: e2.cursor }, [ht({ category: k.PNDisconnectedCategory })]);
      }), It.on(Ct.type, function(e2) {
        return Lt.with(void 0, [ht({ category: k.PNDisconnectedCategory })]);
      });
      var Dt = new Ze("HANDSHAKE_RECONNECTING");
      Dt.onEnter(function(e2) {
        return dt(e2);
      }), Dt.onExit(function() {
        return dt.cancel;
      }), Dt.on(vt.type, function(e2, t2) {
        var n2, r2, o2 = { timetoken: (null === (n2 = e2.cursor) || void 0 === n2 ? void 0 : n2.timetoken) ? null === (r2 = e2.cursor) || void 0 === r2 ? void 0 : r2.timetoken : t2.payload.cursor.timetoken, region: t2.payload.cursor.region };
        return It.with({ channels: e2.channels, groups: e2.groups, cursor: o2 }, [ht({ category: k.PNConnectedCategory })]);
      }), Dt.on(_t.type, function(e2, t2) {
        return Dt.with(n(n({}, e2), { attempts: e2.attempts + 1, reason: t2.payload }));
      }), Dt.on(St.type, function(e2, t2) {
        var n2;
        return Mt.with({ groups: e2.groups, channels: e2.channels, cursor: e2.cursor, reason: t2.payload }, [ht({ category: k.PNConnectionErrorCategory, error: null === (n2 = t2.payload) || void 0 === n2 ? void 0 : n2.message })]);
      }), Dt.on(Tt.type, function(e2) {
        return jt.with({ channels: e2.channels, groups: e2.groups, cursor: e2.cursor });
      }), Dt.on(yt.type, function(e2, t2) {
        return Ft.with({ channels: t2.payload.channels, groups: t2.payload.groups, cursor: e2.cursor });
      }), Dt.on(gt.type, function(e2, t2) {
        var n2, r2;
        return Ft.with({ channels: t2.payload.channels, groups: t2.payload.groups, cursor: { timetoken: t2.payload.cursor.timetoken, region: (null === (n2 = t2.payload.cursor) || void 0 === n2 ? void 0 : n2.region) || (null === (r2 = null == e2 ? void 0 : e2.cursor) || void 0 === r2 ? void 0 : r2.region) || 0 } });
      }), Dt.on(Ct.type, function(e2) {
        return Lt.with(void 0);
      });
      var Ft = new Ze("HANDSHAKING");
      Ft.onEnter(function(e2) {
        return ct(e2.channels, e2.groups);
      }), Ft.onExit(function() {
        return ct.cancel;
      }), Ft.on(yt.type, function(e2, t2) {
        return 0 === t2.payload.channels.length && 0 === t2.payload.groups.length ? Lt.with(void 0) : Ft.with({ channels: t2.payload.channels, groups: t2.payload.groups, cursor: e2.cursor });
      }), Ft.on(mt.type, function(e2, t2) {
        var n2, r2;
        return It.with({ channels: e2.channels, groups: e2.groups, cursor: { timetoken: (null === (n2 = null == e2 ? void 0 : e2.cursor) || void 0 === n2 ? void 0 : n2.timetoken) ? null === (r2 = null == e2 ? void 0 : e2.cursor) || void 0 === r2 ? void 0 : r2.timetoken : t2.payload.timetoken, region: t2.payload.region } }, [ht({ category: k.PNConnectedCategory })]);
      }), Ft.on(bt.type, function(e2, t2) {
        return Dt.with({ channels: e2.channels, groups: e2.groups, cursor: e2.cursor, attempts: 0, reason: t2.payload });
      }), Ft.on(Tt.type, function(e2) {
        return jt.with({ channels: e2.channels, groups: e2.groups, cursor: e2.cursor });
      }), Ft.on(gt.type, function(e2, t2) {
        var n2;
        return Ft.with({ channels: t2.payload.channels, groups: t2.payload.groups, cursor: { timetoken: t2.payload.cursor.timetoken, region: t2.payload.cursor.region || (null === (n2 = null == e2 ? void 0 : e2.cursor) || void 0 === n2 ? void 0 : n2.region) || 0 } });
      }), Ft.on(Ct.type, function(e2) {
        return Lt.with();
      });
      var Lt = new Ze("UNSUBSCRIBED");
      Lt.on(yt.type, function(e2, t2) {
        return Ft.with({ channels: t2.payload.channels, groups: t2.payload.groups });
      }), Lt.on(gt.type, function(e2, t2) {
        return Ft.with({ channels: t2.payload.channels, groups: t2.payload.groups, cursor: t2.payload.cursor });
      });
      var Gt = function() {
        function e2(e3) {
          var t2 = this;
          this.engine = new et(), this.channels = [], this.groups = [], this.dependencies = e3, this.dispatcher = new kt(this.engine, e3), this._unsubscribeEngine = this.engine.subscribe(function(e4) {
            "invocationDispatched" === e4.type && t2.dispatcher.dispatch(e4.invocation);
          }), this.engine.start(Lt, void 0);
        }
        return Object.defineProperty(e2.prototype, "_engine", { get: function() {
          return this.engine;
        }, enumerable: false, configurable: true }), e2.prototype.subscribe = function(e3) {
          var t2 = this, n2 = e3.channels, r2 = e3.channelGroups, o2 = e3.timetoken, i2 = e3.withPresence;
          this.channels = u(u([], a(this.channels), false), a(null != n2 ? n2 : []), false), this.groups = u(u([], a(this.groups), false), a(null != r2 ? r2 : []), false), i2 && (this.channels.map(function(e4) {
            return t2.channels.push("".concat(e4, "-pnpres"));
          }), this.groups.map(function(e4) {
            return t2.groups.push("".concat(e4, "-pnpres"));
          })), o2 ? this.engine.transition(gt(Array.from(new Set(u(u([], a(this.channels), false), a(null != n2 ? n2 : []), false))), Array.from(new Set(u(u([], a(this.groups), false), a(null != r2 ? r2 : []), false))), o2)) : this.engine.transition(yt(Array.from(new Set(u(u([], a(this.channels), false), a(null != n2 ? n2 : []), false))), Array.from(new Set(u(u([], a(this.groups), false), a(null != r2 ? r2 : []), false))))), this.dependencies.join && this.dependencies.join({ channels: Array.from(new Set(this.channels.filter(function(e4) {
            return !e4.endsWith("-pnpres");
          }))), groups: Array.from(new Set(this.groups.filter(function(e4) {
            return !e4.endsWith("-pnpres");
          }))) });
        }, e2.prototype.unsubscribe = function(e3) {
          var t2 = this, n2 = e3.channels, r2 = void 0 === n2 ? [] : n2, o2 = e3.channelGroups, i2 = void 0 === o2 ? [] : o2, s2 = H.removeSingleOccurance(this.channels, u(u([], a(r2), false), a(r2.map(function(e4) {
            return "".concat(e4, "-pnpres");
          })), false)), c2 = H.removeSingleOccurance(this.groups, u(u([], a(i2), false), a(i2.map(function(e4) {
            return "".concat(e4, "-pnpres");
          })), false));
          if (new Set(this.channels).size !== new Set(s2).size || new Set(this.groups).size !== new Set(c2).size) {
            var l2 = H.findUniqueCommonElements(this.channels, r2), p2 = H.findUniqueCommonElements(this.groups, i2);
            this.dependencies.presenceState && (null == l2 || l2.forEach(function(e4) {
              return delete t2.dependencies.presenceState[e4];
            }), null == p2 || p2.forEach(function(e4) {
              return delete t2.dependencies.presenceState[e4];
            })), this.channels = s2, this.groups = c2, this.engine.transition(yt(Array.from(new Set(this.channels.slice(0))), Array.from(new Set(this.groups.slice(0))))), this.dependencies.leave && this.dependencies.leave({ channels: l2.slice(0), groups: p2.slice(0) });
          }
        }, e2.prototype.unsubscribeAll = function() {
          this.channels = [], this.groups = [], this.dependencies.presenceState && (this.dependencies.presenceState = {}), this.engine.transition(yt(this.channels.slice(0), this.groups.slice(0))), this.dependencies.leaveAll && this.dependencies.leaveAll();
        }, e2.prototype.reconnect = function(e3) {
          var t2 = e3.timetoken, n2 = e3.region;
          this.engine.transition(Nt(t2, n2));
        }, e2.prototype.disconnect = function() {
          this.engine.transition(Tt()), this.dependencies.leaveAll && this.dependencies.leaveAll();
        }, e2.prototype.getSubscribedChannels = function() {
          return Array.from(new Set(this.channels));
        }, e2.prototype.getSubscribedChannelGroups = function() {
          return Array.from(new Set(this.groups));
        }, e2.prototype.dispose = function() {
          this.disconnect(), this._unsubscribeEngine(), this.dispatcher.dispose();
        }, e2;
      }(), Kt = nt("RECONNECT", function() {
        return {};
      }), Bt = nt("DISCONNECT", function() {
        return {};
      }), Ht = nt("JOINED", function(e2, t2) {
        return { channels: e2, groups: t2 };
      }), qt = nt("LEFT", function(e2, t2) {
        return { channels: e2, groups: t2 };
      }), zt = nt("LEFT_ALL", function() {
        return {};
      }), Vt = nt("HEARTBEAT_SUCCESS", function(e2) {
        return { statusCode: e2 };
      }), Wt = nt("HEARTBEAT_FAILURE", function(e2) {
        return e2;
      }), Jt = nt("HEARTBEAT_GIVEUP", function() {
        return {};
      }), $t = nt("TIMES_UP", function() {
        return {};
      }), Qt = rt("HEARTBEAT", function(e2, t2) {
        return { channels: e2, groups: t2 };
      }), Xt = rt("LEAVE", function(e2, t2) {
        return { channels: e2, groups: t2 };
      }), Yt = rt("EMIT_STATUS", function(e2) {
        return e2;
      }), Zt = ot("WAIT", function() {
        return {};
      }), en = ot("DELAYED_HEARTBEAT", function(e2) {
        return e2;
      }), tn = function(e2) {
        function r2(t2, r3) {
          var s2 = e2.call(this, r3) || this;
          return s2.on(Qt.type, ut(function(e3, r4, a2) {
            var u2 = a2.heartbeat, c2 = a2.presenceState, l2 = a2.config;
            return o(s2, void 0, void 0, function() {
              var r5;
              return i(this, function(o2) {
                switch (o2.label) {
                  case 0:
                    return o2.trys.push([0, 2, , 3]), [4, u2(n({ channels: e3.channels, channelGroups: e3.groups }, l2.maintainPresenceState && { state: c2 }))];
                  case 1:
                    return o2.sent(), t2.transition(Vt(200)), [3, 3];
                  case 2:
                    return (r5 = o2.sent()) instanceof q ? [2, t2.transition(Wt(r5))] : [3, 3];
                  case 3:
                    return [2];
                }
              });
            });
          })), s2.on(Xt.type, ut(function(e3, t3, n2) {
            var r4 = n2.leave, a2 = n2.config;
            return o(s2, void 0, void 0, function() {
              return i(this, function(t4) {
                switch (t4.label) {
                  case 0:
                    if (a2.suppressLeaveEvents) return [3, 4];
                    t4.label = 1;
                  case 1:
                    return t4.trys.push([1, 3, , 4]), [4, r4({ channels: e3.channels, channelGroups: e3.groups })];
                  case 2:
                  case 3:
                    return t4.sent(), [3, 4];
                  case 4:
                    return [2];
                }
              });
            });
          })), s2.on(Zt.type, ut(function(e3, n2, r4) {
            var a2 = r4.heartbeatDelay;
            return o(s2, void 0, void 0, function() {
              return i(this, function(e4) {
                switch (e4.label) {
                  case 0:
                    return n2.throwIfAborted(), [4, a2()];
                  case 1:
                    return e4.sent(), n2.throwIfAborted(), [2, t2.transition($t())];
                }
              });
            });
          })), s2.on(en.type, ut(function(e3, r4, a2) {
            var u2 = a2.heartbeat, c2 = a2.retryDelay, l2 = a2.presenceState, p2 = a2.config;
            return o(s2, void 0, void 0, function() {
              var o2;
              return i(this, function(i2) {
                switch (i2.label) {
                  case 0:
                    return p2.retryConfiguration && p2.retryConfiguration.shouldRetry(e3.reason, e3.attempts) ? (r4.throwIfAborted(), [4, c2(p2.retryConfiguration.getDelay(e3.attempts, e3.reason))]) : [3, 6];
                  case 1:
                    i2.sent(), r4.throwIfAborted(), i2.label = 2;
                  case 2:
                    return i2.trys.push([2, 4, , 5]), [4, u2(n({ channels: e3.channels, channelGroups: e3.groups }, p2.maintainPresenceState && { state: l2 }))];
                  case 3:
                    return i2.sent(), [2, t2.transition(Vt(200))];
                  case 4:
                    return (o2 = i2.sent()) instanceof Error && "Aborted" === o2.message ? [2] : o2 instanceof q ? [2, t2.transition(Wt(o2))] : [3, 5];
                  case 5:
                    return [3, 7];
                  case 6:
                    return [2, t2.transition(Jt())];
                  case 7:
                    return [2];
                }
              });
            });
          })), s2.on(Yt.type, ut(function(e3, t3, r4) {
            var a2 = r4.emitStatus, u2 = r4.config;
            return o(s2, void 0, void 0, function() {
              var t4;
              return i(this, function(r5) {
                return u2.announceFailedHeartbeats && true === (null === (t4 = null == e3 ? void 0 : e3.status) || void 0 === t4 ? void 0 : t4.error) ? a2(e3.status) : u2.announceSuccessfulHeartbeats && 200 === e3.statusCode && a2(n(n({}, e3), { operation: j.PNHeartbeatOperation, error: false })), [2];
              });
            });
          })), s2;
        }
        return t(r2, e2), r2;
      }(tt), nn = new Ze("HEARTBEAT_STOPPED");
      nn.on(Ht.type, function(e2, t2) {
        return nn.with({ channels: u(u([], a(e2.channels), false), a(t2.payload.channels), false), groups: u(u([], a(e2.groups), false), a(t2.payload.groups), false) });
      }), nn.on(qt.type, function(e2, t2) {
        return nn.with({ channels: e2.channels.filter(function(e3) {
          return !t2.payload.channels.includes(e3);
        }), groups: e2.groups.filter(function(e3) {
          return !t2.payload.groups.includes(e3);
        }) });
      }), nn.on(Kt.type, function(e2, t2) {
        return an.with({ channels: e2.channels, groups: e2.groups });
      }), nn.on(zt.type, function(e2, t2) {
        return un.with(void 0);
      });
      var rn = new Ze("HEARTBEAT_COOLDOWN");
      rn.onEnter(function() {
        return Zt();
      }), rn.onExit(function() {
        return Zt.cancel;
      }), rn.on($t.type, function(e2, t2) {
        return an.with({ channels: e2.channels, groups: e2.groups });
      }), rn.on(Ht.type, function(e2, t2) {
        return an.with({ channels: u(u([], a(e2.channels), false), a(t2.payload.channels), false), groups: u(u([], a(e2.groups), false), a(t2.payload.groups), false) });
      }), rn.on(qt.type, function(e2, t2) {
        return an.with({ channels: e2.channels.filter(function(e3) {
          return !t2.payload.channels.includes(e3);
        }), groups: e2.groups.filter(function(e3) {
          return !t2.payload.groups.includes(e3);
        }) }, [Xt(t2.payload.channels, t2.payload.groups)]);
      }), rn.on(Bt.type, function(e2) {
        return nn.with({ channels: e2.channels, groups: e2.groups }, [Xt(e2.channels, e2.groups)]);
      }), rn.on(zt.type, function(e2, t2) {
        return un.with(void 0, [Xt(e2.channels, e2.groups)]);
      });
      var on = new Ze("HEARTBEAT_FAILED");
      on.on(Ht.type, function(e2, t2) {
        return an.with({ channels: u(u([], a(e2.channels), false), a(t2.payload.channels), false), groups: u(u([], a(e2.groups), false), a(t2.payload.groups), false) });
      }), on.on(qt.type, function(e2, t2) {
        return an.with({ channels: e2.channels.filter(function(e3) {
          return !t2.payload.channels.includes(e3);
        }), groups: e2.groups.filter(function(e3) {
          return !t2.payload.groups.includes(e3);
        }) }, [Xt(t2.payload.channels, t2.payload.groups)]);
      }), on.on(Kt.type, function(e2, t2) {
        return an.with({ channels: e2.channels, groups: e2.groups });
      }), on.on(Bt.type, function(e2, t2) {
        return nn.with({ channels: e2.channels, groups: e2.groups }, [Xt(e2.channels, e2.groups)]);
      }), on.on(zt.type, function(e2, t2) {
        return un.with(void 0, [Xt(e2.channels, e2.groups)]);
      });
      var sn = new Ze("HEARBEAT_RECONNECTING");
      sn.onEnter(function(e2) {
        return en(e2);
      }), sn.onExit(function() {
        return en.cancel;
      }), sn.on(Ht.type, function(e2, t2) {
        return an.with({ channels: u(u([], a(e2.channels), false), a(t2.payload.channels), false), groups: u(u([], a(e2.groups), false), a(t2.payload.groups), false) });
      }), sn.on(qt.type, function(e2, t2) {
        return an.with({ channels: e2.channels.filter(function(e3) {
          return !t2.payload.channels.includes(e3);
        }), groups: e2.groups.filter(function(e3) {
          return !t2.payload.groups.includes(e3);
        }) }, [Xt(t2.payload.channels, t2.payload.groups)]);
      }), sn.on(Bt.type, function(e2, t2) {
        nn.with({ channels: e2.channels, groups: e2.groups }, [Xt(e2.channels, e2.groups)]);
      }), sn.on(Vt.type, function(e2, t2) {
        return rn.with({ channels: e2.channels, groups: e2.groups });
      }), sn.on(Wt.type, function(e2, t2) {
        return sn.with(n(n({}, e2), { attempts: e2.attempts + 1, reason: t2.payload }));
      }), sn.on(Jt.type, function(e2, t2) {
        return on.with({ channels: e2.channels, groups: e2.groups });
      }), sn.on(zt.type, function(e2, t2) {
        return un.with(void 0, [Xt(e2.channels, e2.groups)]);
      });
      var an = new Ze("HEARTBEATING");
      an.onEnter(function(e2) {
        return Qt(e2.channels, e2.groups);
      }), an.on(Vt.type, function(e2, t2) {
        return rn.with({ channels: e2.channels, groups: e2.groups });
      }), an.on(Ht.type, function(e2, t2) {
        return an.with({ channels: u(u([], a(e2.channels), false), a(t2.payload.channels), false), groups: u(u([], a(e2.groups), false), a(t2.payload.groups), false) });
      }), an.on(qt.type, function(e2, t2) {
        return an.with({ channels: e2.channels.filter(function(e3) {
          return !t2.payload.channels.includes(e3);
        }), groups: e2.groups.filter(function(e3) {
          return !t2.payload.groups.includes(e3);
        }) }, [Xt(t2.payload.channels, t2.payload.groups)]);
      }), an.on(Wt.type, function(e2, t2) {
        return sn.with(n(n({}, e2), { attempts: 0, reason: t2.payload }));
      }), an.on(Bt.type, function(e2) {
        return nn.with({ channels: e2.channels, groups: e2.groups }, [Xt(e2.channels, e2.groups)]);
      }), an.on(zt.type, function(e2, t2) {
        return un.with(void 0, [Xt(e2.channels, e2.groups)]);
      });
      var un = new Ze("HEARTBEAT_INACTIVE");
      un.on(Ht.type, function(e2, t2) {
        return an.with({ channels: t2.payload.channels, groups: t2.payload.groups });
      });
      var cn = function() {
        function e2(e3) {
          var t2 = this;
          this.engine = new et(), this.channels = [], this.groups = [], this.dispatcher = new tn(this.engine, e3), this.dependencies = e3, this._unsubscribeEngine = this.engine.subscribe(function(e4) {
            "invocationDispatched" === e4.type && t2.dispatcher.dispatch(e4.invocation);
          }), this.engine.start(un, void 0);
        }
        return Object.defineProperty(e2.prototype, "_engine", { get: function() {
          return this.engine;
        }, enumerable: false, configurable: true }), e2.prototype.join = function(e3) {
          var t2 = e3.channels, n2 = e3.groups;
          this.channels = u(u([], a(this.channels), false), a(null != t2 ? t2 : []), false), this.groups = u(u([], a(this.groups), false), a(null != n2 ? n2 : []), false), this.engine.transition(Ht(this.channels.slice(0), this.groups.slice(0)));
        }, e2.prototype.leave = function(e3) {
          var t2 = this, n2 = e3.channels, r2 = e3.groups;
          this.dependencies.presenceState && (null == n2 || n2.forEach(function(e4) {
            return delete t2.dependencies.presenceState[e4];
          }), null == r2 || r2.forEach(function(e4) {
            return delete t2.dependencies.presenceState[e4];
          })), this.engine.transition(qt(null != n2 ? n2 : [], null != r2 ? r2 : []));
        }, e2.prototype.leaveAll = function() {
          this.engine.transition(zt());
        }, e2.prototype.dispose = function() {
          this._unsubscribeEngine(), this.dispatcher.dispose();
        }, e2;
      }(), ln = function() {
        function e2() {
        }
        return e2.LinearRetryPolicy = function(e3) {
          return { delay: e3.delay, maximumRetry: e3.maximumRetry, shouldRetry: function(e4, t2) {
            var n2;
            return 403 !== (null === (n2 = null == e4 ? void 0 : e4.status) || void 0 === n2 ? void 0 : n2.statusCode) && this.maximumRetry > t2;
          }, getDelay: function(e4, t2) {
            var n2;
            return 1e3 * ((null !== (n2 = t2.retryAfter) && void 0 !== n2 ? n2 : this.delay) + Math.random());
          }, getGiveupReason: function(e4, t2) {
            var n2;
            return this.maximumRetry <= t2 ? "retry attempts exhaused." : 403 === (null === (n2 = null == e4 ? void 0 : e4.status) || void 0 === n2 ? void 0 : n2.statusCode) ? "forbidden operation." : "unknown error";
          } };
        }, e2.ExponentialRetryPolicy = function(e3) {
          return { minimumDelay: e3.minimumDelay, maximumDelay: e3.maximumDelay, maximumRetry: e3.maximumRetry, shouldRetry: function(e4, t2) {
            var n2;
            return 403 !== (null === (n2 = null == e4 ? void 0 : e4.status) || void 0 === n2 ? void 0 : n2.statusCode) && this.maximumRetry > t2;
          }, getDelay: function(e4, t2) {
            var n2;
            return 1e3 * ((null !== (n2 = t2.retryAfter) && void 0 !== n2 ? n2 : Math.min(Math.pow(2, e4), this.maximumDelay)) + Math.random());
          }, getGiveupReason: function(e4, t2) {
            var n2;
            return this.maximumRetry <= t2 ? "retry attempts exhaused." : 403 === (null === (n2 = null == e4 ? void 0 : e4.status) || void 0 === n2 ? void 0 : n2.statusCode) ? "forbidden operation." : "unknown error";
          } };
        }, e2;
      }(), pn = function() {
        function e2(e3) {
          var t2 = e3.modules, n2 = e3.listenerManager, r2 = e3.getFileUrl;
          this.modules = t2, this.listenerManager = n2, this.getFileUrl = r2, this._channelListenerMap = /* @__PURE__ */ new Map(), this._groupListenerMap = /* @__PURE__ */ new Map(), t2.cryptoModule && (this._decoder = new TextDecoder());
        }
        return e2.prototype.emitEvent = function(e3) {
          var t2 = e3.channel, o2 = e3.publishMetaData, i2 = e3.subscriptionMatch;
          if (t2 === i2 && (i2 = null), e3.channel.endsWith("-pnpres")) {
            var s2 = { channel: null, subscription: null };
            t2 && (s2.channel = t2.substring(0, t2.lastIndexOf("-pnpres"))), i2 && (s2.subscription = i2.substring(0, i2.lastIndexOf("-pnpres"))), s2.action = e3.payload.action, s2.state = e3.payload.data, s2.timetoken = o2.timetoken, s2.occupancy = e3.payload.occupancy, s2.uuid = e3.payload.uuid, s2.timestamp = e3.payload.timestamp, e3.payload.join && (s2.join = e3.payload.join), e3.payload.leave && (s2.leave = e3.payload.leave), e3.payload.timeout && (s2.timeout = e3.payload.timeout), s2.actualChannel = null != i2 ? t2 : null, s2.subscribedChannel = null != i2 ? i2 : t2, this.listenerManager.announcePresence(s2), this._announce("presence", s2, s2.channel, s2.subscription);
          } else if (1 === e3.messageType) {
            (s2 = { channel: null, subscription: null }).channel = t2, s2.subscription = i2, s2.timetoken = o2.timetoken, s2.publisher = e3.issuingClientId, e3.userMetadata && (s2.userMetadata = e3.userMetadata), s2.message = e3.payload, this.listenerManager.announceSignal(s2), this._announce("signal", s2, s2.channel, s2.subscription);
          } else if (2 === e3.messageType) {
            if ((s2 = { channel: null, subscription: null }).channel = t2, s2.subscription = i2, s2.timetoken = o2.timetoken, s2.publisher = e3.issuingClientId, e3.userMetadata && (s2.userMetadata = e3.userMetadata), s2.message = { event: e3.payload.event, type: e3.payload.type, data: e3.payload.data }, this.listenerManager.announceObjects(s2), this._announce("objects", s2, s2.channel, s2.subscription), "uuid" === e3.payload.type) {
              var a2 = this._renameChannelField(s2), u2 = n(n({}, a2), { message: n(n({}, a2.message), { event: this._renameEvent(a2.message.event), type: "user" }) });
              this.listenerManager.announceUser(u2), this._announce("user", u2, s2.channel, s2.subscription);
            } else if ("channel" === e3.payload.type) {
              a2 = this._renameChannelField(s2);
              var c2 = n(n({}, a2), { message: n(n({}, a2.message), { event: this._renameEvent(a2.message.event), type: "space" }) });
              this.listenerManager.announceSpace(c2), this._announce("space", c2, s2.channel, s2.subscription);
            } else if ("membership" === e3.payload.type) {
              var l2 = (a2 = this._renameChannelField(s2)).message.data, p2 = l2.uuid, h2 = l2.channel, f2 = r(l2, ["uuid", "channel"]);
              f2.user = p2, f2.space = h2;
              var d2 = n(n({}, a2), { message: n(n({}, a2.message), { event: this._renameEvent(a2.message.event), data: f2 }) });
              this.listenerManager.announceMembership(d2), this._announce("membership", d2, s2.channel, s2.subscription);
            }
          } else if (3 === e3.messageType) {
            (s2 = {}).channel = t2, s2.subscription = i2, s2.timetoken = o2.timetoken, s2.publisher = e3.issuingClientId, s2.data = { messageTimetoken: e3.payload.data.messageTimetoken, actionTimetoken: e3.payload.data.actionTimetoken, type: e3.payload.data.type, uuid: e3.issuingClientId, value: e3.payload.data.value }, s2.event = e3.payload.event, this.listenerManager.announceMessageAction(s2), this._announce("messageAction", s2, s2.channel, s2.subscription);
          } else if (4 === e3.messageType) {
            (s2 = {}).channel = t2, s2.subscription = i2, s2.timetoken = o2.timetoken, s2.publisher = e3.issuingClientId;
            var y2 = e3.payload;
            if (this.modules.cryptoModule) {
              var g2 = void 0;
              try {
                g2 = (m2 = this.modules.cryptoModule.decrypt(e3.payload)) instanceof ArrayBuffer ? JSON.parse(this._decoder.decode(m2)) : m2;
              } catch (e4) {
                g2 = null, s2.error = "Error while decrypting message content: ".concat(e4.message);
              }
              null !== g2 && (y2 = g2);
            }
            e3.userMetadata && (s2.userMetadata = e3.userMetadata), s2.message = y2.message, s2.file = { id: y2.file.id, name: y2.file.name, url: this.getFileUrl({ id: y2.file.id, name: y2.file.name, channel: t2 }) }, this.listenerManager.announceFile(s2), this._announce("file", s2, s2.channel, s2.subscription);
          } else {
            if ((s2 = { channel: null, subscription: null }).channel = t2, s2.subscription = i2, s2.timetoken = o2.timetoken, s2.publisher = e3.issuingClientId, e3.userMetadata && (s2.userMetadata = e3.userMetadata), this.modules.cryptoModule) {
              g2 = void 0;
              try {
                var m2;
                g2 = (m2 = this.modules.cryptoModule.decrypt(e3.payload)) instanceof ArrayBuffer ? JSON.parse(this._decoder.decode(m2)) : m2;
              } catch (e4) {
                g2 = null, s2.error = "Error while decrypting message content: ".concat(e4.message);
              }
              s2.message = null != g2 ? g2 : e3.payload;
            } else s2.message = e3.payload;
            s2.actualChannel = null != i2 ? t2 : null, s2.subscribedChannel = null != i2 ? i2 : t2, this.listenerManager.announceMessage(s2), this._announce("message", s2, s2.channel, s2.subscription);
          }
        }, e2.prototype.addListener = function(e3, t2, n2) {
          var r2 = this;
          t2 && n2 ? (null == t2 || t2.forEach(function(t3) {
            r2._channelListenerMap[t3] ? r2._channelListenerMap[t3].includes(e3) || r2._channelListenerMap[t3].push(e3) : r2._channelListenerMap[t3] = [e3];
          }), null == n2 || n2.forEach(function(t3) {
            r2._groupListenerMap[t3] ? r2._groupListenerMap[t3].includes(e3) || r2._groupListenerMap[t3].push(e3) : r2._groupListenerMap[t3] = [e3];
          })) : this.listenerManager.addListener(e3);
        }, e2.prototype.removeListener = function(e3, t2, n2) {
          var r2 = this;
          t2 && n2 ? (null == t2 || t2.forEach(function(t3) {
            var n3;
            r2._channelListenerMap[t3] = null === (n3 = r2._channelListenerMap[t3]) || void 0 === n3 ? void 0 : n3.filter(function(t4) {
              return t4 !== e3;
            });
          }), null == n2 || n2.forEach(function(t3) {
            var n3;
            r2._groupListenerMap[t3] = null === (n3 = r2._groupListenerMap[t3]) || void 0 === n3 ? void 0 : n3.filter(function(t4) {
              return t4 !== e3;
            });
          })) : this.listenerManager.removeListener(e3);
        }, e2.prototype.removeAllListeners = function() {
          this.listenerManager.removeAllListeners();
        }, e2.prototype._renameEvent = function(e3) {
          return "set" === e3 ? "updated" : "removed";
        }, e2.prototype._renameChannelField = function(e3) {
          var t2 = e3.channel, n2 = r(e3, ["channel"]);
          return n2.spaceId = t2, n2;
        }, e2.prototype._announce = function(e3, t2, n2, r2) {
          var o2, i2;
          null === (o2 = this._channelListenerMap[n2]) || void 0 === o2 || o2.forEach(function(n3) {
            return n3[e3] && n3[e3](t2);
          }), null === (i2 = this._groupListenerMap[r2]) || void 0 === i2 || i2.forEach(function(n3) {
            return n3[e3] && n3[e3](t2);
          });
        }, e2;
      }(), hn = function() {
        function e2() {
        }
        return e2.prototype.subscribe = function() {
          var e3, t2;
          this.pubnub.subscribe(n({ channels: this.channelNames, channelGroups: this.groupNames }, (null === (t2 = null === (e3 = this.options) || void 0 === e3 ? void 0 : e3.cursor) || void 0 === t2 ? void 0 : t2.timetoken) && { timetoken: this.options.cursor.timetoken }));
        }, e2.prototype.unsubscribe = function() {
          this.pubnub.unsubscribe({ channels: this.channelNames.filter(function(e3) {
            return !e3.endsWith("-pnpres");
          }), channelGroups: this.groupNames.filter(function(e3) {
            return !e3.endsWith("-pnpres");
          }) });
        }, Object.defineProperty(e2.prototype, "onMessage", { set: function(e3) {
          this.listener.message = e3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "onPresence", { set: function(e3) {
          this.listener.presence = e3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "onSignal", { set: function(e3) {
          this.listener.signal = e3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "onObjects", { set: function(e3) {
          this.listener.objects = e3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "onMessageAction", { set: function(e3) {
          this.listener.messageAction = e3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "onFile", { set: function(e3) {
          this.listener.file = e3;
        }, enumerable: false, configurable: true }), e2.prototype.addListener = function(e3) {
          this.eventEmitter.addListener(e3, this.channelNames.filter(function(e4) {
            return !e4.endsWith("-pnpres");
          }), this.groupNames.filter(function(e4) {
            return !e4.endsWith("-pnpres");
          }));
        }, e2.prototype.removeListener = function(e3) {
          this.eventEmitter.removeListener(e3, this.channelNames, this.groupNames);
        }, Object.defineProperty(e2.prototype, "channels", { get: function() {
          return this.channelNames.slice(0);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "channelGroups", { get: function() {
          return this.groupNames.slice(0);
        }, enumerable: false, configurable: true }), e2;
      }(), fn = function(e2) {
        function n2(t2) {
          var n3 = t2.channels, r2 = void 0 === n3 ? [] : n3, o2 = t2.channelGroups, i2 = void 0 === o2 ? [] : o2, s2 = t2.subscriptionOptions, c2 = t2.eventEmitter, l2 = t2.pubnub, p2 = e2.call(this) || this;
          return p2.channelNames = [], p2.groupNames = [], p2.subscriptionList = [], p2.options = s2, p2.eventEmitter = c2, p2.pubnub = l2, r2.filter(function(e3) {
            return !e3.endsWith("-pnpres");
          }).forEach(function(e3) {
            var t3 = p2.pubnub.channel(e3).subscription(p2.options);
            p2.channelNames = u(u([], a(p2.channelNames), false), a(t3.channels), false), p2.subscriptionList.push(t3);
          }), i2.filter(function(e3) {
            return !e3.endsWith("-pnpres");
          }).forEach(function(e3) {
            var t3 = p2.pubnub.channelGroup(e3).subscription(p2.options);
            p2.groupNames = u(u([], a(p2.groupNames), false), a(t3.channelGroups), false), p2.subscriptionList.push(t3);
          }), p2.listener = {}, c2.addListener(p2.listener, p2.channelNames.filter(function(e3) {
            return !e3.endsWith("-pnpres");
          }), p2.groupNames.filter(function(e3) {
            return !e3.endsWith("-pnpres");
          })), p2;
        }
        return t(n2, e2), n2.prototype.addSubscription = function(e3) {
          this.subscriptionList.push(e3), this.channelNames = u(u([], a(this.channelNames), false), a(e3.channels), false), this.groupNames = u(u([], a(this.groupNames), false), a(e3.channelGroups), false), this.eventEmitter.addListener(this.listener, e3.channels, e3.channelGroups);
        }, n2.prototype.removeSubscription = function(e3) {
          var t2 = e3.channels, n3 = e3.channelGroups;
          this.channelNames = this.channelNames.filter(function(e4) {
            return !t2.includes(e4);
          }), this.groupNames = this.groupNames.filter(function(e4) {
            return !n3.includes(e4);
          }), this.subscriptionList = this.subscriptionList.filter(function(t3) {
            return t3 !== e3;
          }), this.eventEmitter.removeListener(this.listener, t2, n3);
        }, n2.prototype.addSubscriptionSet = function(e3) {
          this.subscriptionList = u(u([], a(this.subscriptionList), false), a(e3.subscriptions), false), this.channelNames = u(u([], a(this.channelNames), false), a(e3.channels), false), this.groupNames = u(u([], a(this.groupNames), false), a(e3.channelGroups), false), this.eventEmitter.addListener(this.listener, e3.channels, e3.channelGroups);
        }, n2.prototype.removeSubscriptionSet = function(e3) {
          var t2 = e3.channels, n3 = e3.channelGroups;
          this.channelNames = this.channelNames.filter(function(e4) {
            return !t2.includes(e4);
          }), this.groupNames = this.groupNames.filter(function(e4) {
            return !n3.includes(e4);
          }), this.subscriptionList = this.subscriptionList.filter(function(t3) {
            return !e3.subscriptions.includes(t3);
          }), this.eventEmitter.removeListener(this.listener, t2, n3);
        }, Object.defineProperty(n2.prototype, "subscriptions", { get: function() {
          return this.subscriptionList.slice(0);
        }, enumerable: false, configurable: true }), n2;
      }(hn), dn = function(e2) {
        function r2(t2) {
          var n2 = t2.channels, r3 = t2.channelGroups, o2 = t2.subscriptionOptions, i2 = t2.eventEmitter, s2 = t2.pubnub, a2 = e2.call(this) || this;
          return a2.channelNames = [], a2.groupNames = [], a2.channelNames = n2, a2.groupNames = r3, a2.options = o2, a2.pubnub = s2, a2.eventEmitter = i2, a2.listener = {}, i2.addListener(a2.listener, a2.channelNames.filter(function(e3) {
            return !e3.endsWith("-pnpres");
          }), a2.groupNames.filter(function(e3) {
            return !e3.endsWith("-pnpres");
          })), a2;
        }
        return t(r2, e2), r2.prototype.addSubscription = function(e3) {
          return new fn({ channels: u(u([], a(this.channelNames), false), a(e3.channels), false), channelGroups: u(u([], a(this.groupNames), false), a(e3.channelGroups), false), subscriptionOptions: n(n({}, this.options), null == e3 ? void 0 : e3.options), eventEmitter: this.eventEmitter, pubnub: this.pubnub });
        }, r2;
      }(hn), yn = function() {
        function e2(e3, t2, n2) {
          this.name = e3, this.eventEmitter = t2, this.pubnub = n2;
        }
        return e2.prototype.subscription = function(e3) {
          return new dn({ channels: (null == e3 ? void 0 : e3.receivePresenceEvents) ? [this.name, "".concat(this.name, "-pnpres")] : [this.name], channelGroups: [], subscriptionOptions: e3, eventEmitter: this.eventEmitter, pubnub: this.pubnub });
        }, e2;
      }(), gn = function() {
        function e2(e3, t2, n2) {
          this.name = e3, this.eventEmitter = t2, this.pubnub = n2;
        }
        return e2.prototype.subscription = function(e3) {
          return new dn({ channels: [], channelGroups: (null == e3 ? void 0 : e3.receivePresenceEvents) ? [this.name, "".concat(this.name, "-pnpres")] : [this.name], subscriptionOptions: e3, eventEmitter: this.eventEmitter, pubnub: this.pubnub });
        }, e2;
      }(), mn = function() {
        function e2(e3, t2, n2) {
          this.id = e3, this.eventEmitter = t2, this.pubnub = n2;
        }
        return e2.prototype.subscription = function(e3) {
          return new dn({ channels: [this.id], channelGroups: [], subscriptionOptions: e3, eventEmitter: this.eventEmitter, pubnub: this.pubnub });
        }, e2;
      }(), bn = function() {
        function e2(e3, t2, n2) {
          this.id = e3, this.eventEmitter = t2, this.pubnub = n2;
        }
        return e2.prototype.subscription = function(e3) {
          return new dn({ channels: [this.id], channelGroups: [], subscriptionOptions: e3, eventEmitter: this.eventEmitter, pubnub: this.pubnub });
        }, e2;
      }(), vn = function() {
        function e2(e3) {
          var t2 = this, r2 = e3.networking, o2 = e3.cbor, i2 = new g({ setup: e3 });
          this._config = i2;
          var c2 = new T({ config: i2 }), l2 = e3.cryptography;
          r2.init(i2);
          var p2 = new G(i2, o2);
          this._tokenManager = p2;
          var h2 = new R({ maximumSamplesCount: 6e4 });
          this._telemetryManager = h2;
          var f2 = this._config.cryptoModule, d2 = { config: i2, networking: r2, crypto: c2, cryptography: l2, tokenManager: p2, telemetryManager: h2, PubNubFile: e3.PubNubFile, cryptoModule: f2 };
          this.File = e3.PubNubFile, this.encryptFile = function(e4, t3) {
            return 1 == arguments.length && "string" != typeof e4 && d2.cryptoModule ? (t3 = e4, d2.cryptoModule.encryptFile(t3, this.File)) : l2.encryptFile(e4, t3, this.File);
          }, this.decryptFile = function(e4, t3) {
            return 1 == arguments.length && "string" != typeof e4 && d2.cryptoModule ? (t3 = e4, d2.cryptoModule.decryptFile(t3, this.File)) : l2.decryptFile(e4, t3, this.File);
          };
          var y2 = Q.bind(this, d2, Je), m2 = Q.bind(this, d2, se), v2 = Q.bind(this, d2, ue), _2 = Q.bind(this, d2, le), S2 = Q.bind(this, d2, $e), w2 = new L();
          if (this._listenerManager = w2, this.iAmHere = Q.bind(this, d2, ue), this.iAmAway = Q.bind(this, d2, se), this.setPresenceState = Q.bind(this, d2, le), this.handshake = Q.bind(this, d2, Qe), this.receiveMessages = Q.bind(this, d2, Xe), this._eventEmitter = new pn({ modules: d2, listenerManager: this._listenerManager, getFileUrl: function(e4) {
            return ve(d2, e4);
          } }), true === i2.enableEventEngine) {
            if (i2.maintainPresenceState && (this.presenceState = {}, this.setState = function(e4) {
              var n2, r3;
              return null === (n2 = e4.channels) || void 0 === n2 || n2.forEach(function(n3) {
                return t2.presenceState[n3] = e4.state;
              }), null === (r3 = e4.channelGroups) || void 0 === r3 || r3.forEach(function(n3) {
                return t2.presenceState[n3] = e4.state;
              }), t2.setPresenceState({ channels: e4.channels, channelGroups: e4.channelGroups, state: t2.presenceState });
            }), i2.getHeartbeatInterval()) {
              var O2 = new cn({ heartbeat: this.iAmHere, leave: this.iAmAway, heartbeatDelay: function() {
                return new Promise(function(e4) {
                  return setTimeout(e4, 1e3 * d2.config.getHeartbeatInterval());
                });
              }, retryDelay: function(e4) {
                return new Promise(function(t3) {
                  return setTimeout(t3, e4);
                });
              }, config: d2.config, presenceState: this.presenceState, emitStatus: function(e4) {
                w2.announceStatus(e4);
              } });
              this.presenceEventEngine = O2, this.join = this.presenceEventEngine.join.bind(O2), this.leave = this.presenceEventEngine.leave.bind(O2), this.leaveAll = this.presenceEventEngine.leaveAll.bind(O2);
            }
            var P2 = new Gt({ handshake: this.handshake, receiveMessages: this.receiveMessages, delay: function(e4) {
              return new Promise(function(t3) {
                return setTimeout(t3, e4);
              });
            }, join: this.join, leave: this.leave, leaveAll: this.leaveAll, presenceState: this.presenceState, config: d2.config, emitMessages: function(e4) {
              var n2, r3;
              try {
                for (var o3 = s(e4), i3 = o3.next(); !i3.done; i3 = o3.next()) {
                  var a2 = i3.value;
                  t2._eventEmitter.emitEvent(a2);
                }
              } catch (e5) {
                n2 = { error: e5 };
              } finally {
                try {
                  i3 && !i3.done && (r3 = o3.return) && r3.call(o3);
                } finally {
                  if (n2) throw n2.error;
                }
              }
            }, emitStatus: function(e4) {
              w2.announceStatus(e4);
            } });
            this.subscribe = P2.subscribe.bind(P2), this.unsubscribe = P2.unsubscribe.bind(P2), this.unsubscribeAll = P2.unsubscribeAll.bind(P2), this.reconnect = P2.reconnect.bind(P2), this.disconnect = P2.disconnect.bind(P2), this.destroy = P2.dispose.bind(P2), this.getSubscribedChannels = P2.getSubscribedChannels.bind(P2), this.getSubscribedChannelGroups = P2.getSubscribedChannelGroups.bind(P2), this.eventEngine = P2;
          } else {
            var E2 = new M({ timeEndpoint: y2, leaveEndpoint: m2, heartbeatEndpoint: v2, setStateEndpoint: _2, subscribeEndpoint: S2, crypto: d2.crypto, config: d2.config, listenerManager: w2, getFileUrl: function(e4) {
              return ve(d2, e4);
            }, cryptoModule: d2.cryptoModule, eventEmitter: this._eventEmitter });
            this.subscribe = E2.adaptSubscribeChange.bind(E2), this.unsubscribe = E2.adaptUnsubscribeChange.bind(E2), this.disconnect = E2.disconnect.bind(E2), this.reconnect = E2.reconnect.bind(E2), this.unsubscribeAll = E2.unsubscribeAll.bind(E2), this.getSubscribedChannels = E2.getSubscribedChannels.bind(E2), this.getSubscribedChannelGroups = E2.getSubscribedChannelGroups.bind(E2), this.setState = E2.adaptStateChange.bind(E2), this.presence = E2.adaptPresenceChange.bind(E2), this.destroy = function(e4) {
              E2.unsubscribeAll(e4), E2.disconnect();
            };
          }
          this.addListener = this._eventEmitter.addListener.bind(this._eventEmitter), this.removeListener = this._eventEmitter.removeListener.bind(this._eventEmitter), this.removeAllListeners = this._eventEmitter.removeAllListeners.bind(this._eventEmitter), this.parseToken = p2.parseToken.bind(p2), this.setToken = p2.setToken.bind(p2), this.getToken = p2.getToken.bind(p2), this.channelGroups = { listGroups: Q.bind(this, d2, ee), listChannels: Q.bind(this, d2, te), addChannels: Q.bind(this, d2, X), removeChannels: Q.bind(this, d2, Y), deleteGroup: Q.bind(this, d2, Z) }, this.push = { addChannels: Q.bind(this, d2, ne), removeChannels: Q.bind(this, d2, re), deleteDevice: Q.bind(this, d2, ie), listChannels: Q.bind(this, d2, oe) }, this.hereNow = Q.bind(this, d2, pe), this.whereNow = Q.bind(this, d2, ae), this.getState = Q.bind(this, d2, ce), this.grant = Q.bind(this, d2, Ue), this.grantToken = Q.bind(this, d2, Le), this.audit = Q.bind(this, d2, xe), this.revokeToken = Q.bind(this, d2, Ge), this.publish = Q.bind(this, d2, Be), this.fire = function(e4, n2) {
            return e4.replicate = false, e4.storeInHistory = false, t2.publish(e4, n2);
          }, this.signal = Q.bind(this, d2, He), this.history = Q.bind(this, d2, qe), this.deleteMessages = Q.bind(this, d2, ze), this.messageCounts = Q.bind(this, d2, Ve), this.fetchMessages = Q.bind(this, d2, We), this.addMessageAction = Q.bind(this, d2, he), this.removeMessageAction = Q.bind(this, d2, fe), this.getMessageActions = Q.bind(this, d2, de), this.listFiles = Q.bind(this, d2, ye);
          var A2 = Q.bind(this, d2, ge);
          this.publishFile = Q.bind(this, d2, me), this.sendFile = be({ generateUploadUrl: A2, publishFile: this.publishFile, modules: d2 }), this.getFileUrl = function(e4) {
            return ve(d2, e4);
          }, this.downloadFile = Q.bind(this, d2, _e), this.deleteFile = Q.bind(this, d2, Se), this.channel = function(e4) {
            return new yn(e4, t2._eventEmitter, t2);
          }, this.channelGroup = function(e4) {
            return new gn(e4, t2._eventEmitter, t2);
          }, this.channelMetadata = function(e4) {
            return new mn(e4, t2._eventEmitter, t2);
          }, this.userMetadata = function(e4) {
            return new bn(e4, t2._eventEmitter, t2);
          }, this.subscriptionSet = function(e4) {
            return new fn({ channels: e4.channels, channelGroups: e4.channelGroups, subscriptionOptions: e4.subscriptionOptions, eventEmitter: t2._eventEmitter, pubnub: t2 });
          }, this.objects = { getAllUUIDMetadata: Q.bind(this, d2, we), getUUIDMetadata: Q.bind(this, d2, Oe), setUUIDMetadata: Q.bind(this, d2, Pe), removeUUIDMetadata: Q.bind(this, d2, Ee), getAllChannelMetadata: Q.bind(this, d2, Ae), getChannelMetadata: Q.bind(this, d2, Te), setChannelMetadata: Q.bind(this, d2, Ne), removeChannelMetadata: Q.bind(this, d2, Ce), getChannelMembers: Q.bind(this, d2, ke), setChannelMembers: function(e4) {
            for (var r3 = [], o3 = 1; o3 < arguments.length; o3++) r3[o3 - 1] = arguments[o3];
            return Q.call.apply(Q, u([t2, d2, Me, n({ type: "set" }, e4)], a(r3), false));
          }, removeChannelMembers: function(e4) {
            for (var r3 = [], o3 = 1; o3 < arguments.length; o3++) r3[o3 - 1] = arguments[o3];
            return Q.call.apply(Q, u([t2, d2, Me, n({ type: "delete" }, e4)], a(r3), false));
          }, getMemberships: Q.bind(this, d2, je), setMemberships: function(e4) {
            for (var r3 = [], o3 = 1; o3 < arguments.length; o3++) r3[o3 - 1] = arguments[o3];
            return Q.call.apply(Q, u([t2, d2, Re, n({ type: "set" }, e4)], a(r3), false));
          }, removeMemberships: function(e4) {
            for (var r3 = [], o3 = 1; o3 < arguments.length; o3++) r3[o3 - 1] = arguments[o3];
            return Q.call.apply(Q, u([t2, d2, Re, n({ type: "delete" }, e4)], a(r3), false));
          } }, this.createUser = function(e4) {
            return t2.objects.setUUIDMetadata({ uuid: e4.userId, data: e4.data, include: e4.include });
          }, this.updateUser = this.createUser, this.removeUser = function(e4) {
            return t2.objects.removeUUIDMetadata({ uuid: null == e4 ? void 0 : e4.userId });
          }, this.fetchUser = function(e4) {
            return t2.objects.getUUIDMetadata({ uuid: null == e4 ? void 0 : e4.userId, include: null == e4 ? void 0 : e4.include });
          }, this.fetchUsers = this.objects.getAllUUIDMetadata, this.createSpace = function(e4) {
            return t2.objects.setChannelMetadata({ channel: e4.spaceId, data: e4.data, include: e4.include });
          }, this.updateSpace = this.createSpace, this.removeSpace = function(e4) {
            return t2.objects.removeChannelMetadata({ channel: e4.spaceId });
          }, this.fetchSpace = function(e4) {
            return t2.objects.getChannelMetadata({ channel: e4.spaceId, include: e4.include });
          }, this.fetchSpaces = this.objects.getAllChannelMetadata, this.addMemberships = function(e4) {
            var n2, r3;
            return "string" == typeof e4.spaceId ? t2.objects.setChannelMembers({ channel: e4.spaceId, uuids: null === (n2 = e4.users) || void 0 === n2 ? void 0 : n2.map(function(e5) {
              return "string" == typeof e5 ? e5 : { id: e5.userId, custom: e5.custom, status: e5.status };
            }), limit: 0 }) : t2.objects.setMemberships({ uuid: e4.userId, channels: null === (r3 = e4.spaces) || void 0 === r3 ? void 0 : r3.map(function(e5) {
              return "string" == typeof e5 ? e5 : { id: e5.spaceId, custom: e5.custom, status: e5.status };
            }), limit: 0 });
          }, this.updateMemberships = this.addMemberships, this.removeMemberships = function(e4) {
            return "string" == typeof e4.spaceId ? t2.objects.removeChannelMembers({ channel: e4.spaceId, uuids: e4.userIds, limit: 0 }) : t2.objects.removeMemberships({ uuid: e4.userId, channels: e4.spaceIds, limit: 0 });
          }, this.fetchMemberships = function(e4) {
            return "string" == typeof e4.spaceId ? t2.objects.getChannelMembers({ channel: e4.spaceId, filter: e4.filter, limit: e4.limit, page: e4.page, include: { customFields: e4.include.customFields, UUIDFields: e4.include.userFields, customUUIDFields: e4.include.customUserFields, statusField: e4.include.statusField, UUIDStatusField: e4.include.userStatusField, UUIDTypeField: e4.include.userTypeField, totalCount: e4.include.totalCount }, sort: null != e4.sort ? Object.fromEntries(Object.entries(e4.sort).map(function(e5) {
              var t3 = a(e5, 2), n2 = t3[0], r3 = t3[1];
              return [n2.replace("user", "uuid"), r3];
            })) : null }).then(function(e5) {
              var t3;
              return e5.data = null === (t3 = e5.data) || void 0 === t3 ? void 0 : t3.map(function(e6) {
                return { user: e6.uuid, custom: e6.custom, updated: e6.updated, eTag: e6.eTag };
              }), e5;
            }) : t2.objects.getMemberships({ uuid: e4.userId, filter: e4.filter, limit: e4.limit, page: e4.page, include: { customFields: e4.include.customFields, channelFields: e4.include.spaceFields, customChannelFields: e4.include.customSpaceFields, statusField: e4.include.statusField, channelStatusField: e4.include.spaceStatusField, channelTypeField: e4.include.spaceTypeField, totalCount: e4.include.totalCount }, sort: null != e4.sort ? Object.fromEntries(Object.entries(e4.sort).map(function(e5) {
              var t3 = a(e5, 2), n2 = t3[0], r3 = t3[1];
              return [n2.replace("space", "channel"), r3];
            })) : null }).then(function(e5) {
              var t3;
              return e5.data = null === (t3 = e5.data) || void 0 === t3 ? void 0 : t3.map(function(e6) {
                return { space: e6.channel, custom: e6.custom, updated: e6.updated, eTag: e6.eTag };
              }), e5;
            });
          }, this.time = y2, this.stop = this.destroy, this.encrypt = function(e4, t3) {
            if (void 0 === t3 && d2.cryptoModule) {
              var n2 = d2.cryptoModule.encrypt(e4);
              return "string" == typeof n2 ? n2 : b(n2);
            }
            return c2.encrypt(e4, t3);
          }, this.decrypt = function(e4, t3) {
            if (void 0 === t3 && f2) {
              var n2 = d2.cryptoModule.decrypt(e4);
              return n2 instanceof ArrayBuffer ? JSON.parse(new TextDecoder().decode(n2)) : n2;
            }
            return c2.decrypt(e4, t3);
          }, this.getAuthKey = d2.config.getAuthKey.bind(d2.config), this.setAuthKey = d2.config.setAuthKey.bind(d2.config), this.getUUID = d2.config.getUUID.bind(d2.config), this.setUUID = d2.config.setUUID.bind(d2.config), this.getUserId = d2.config.getUserId.bind(d2.config), this.setUserId = d2.config.setUserId.bind(d2.config), this.getFilterExpression = d2.config.getFilterExpression.bind(d2.config), this.setFilterExpression = d2.config.setFilterExpression.bind(d2.config), this.setCipherKey = function(t3) {
            return d2.config.setCipherKey(t3, e3, d2);
          }, this.setHeartbeatInterval = d2.config.setHeartbeatInterval.bind(d2.config), r2.hasModule("proxy") && (this.setProxy = function(e4) {
            d2.config.setProxy(e4), t2.reconnect();
          });
        }
        return e2.prototype.getVersion = function() {
          return this._config.getVersion();
        }, e2.prototype._addPnsdkSuffix = function(e3, t2) {
          this._config._addPnsdkSuffix(e3, t2);
        }, e2.prototype.networkDownDetected = function() {
          this._listenerManager.announceNetworkDown(), this._config.restore ? this.disconnect() : this.destroy(true);
        }, e2.prototype.networkUpDetected = function() {
          this._listenerManager.announceNetworkUp(), this.reconnect();
        }, e2.notificationPayload = function(e3, t2) {
          return new F(e3, t2);
        }, e2.generateUUID = function() {
          return y();
        }, e2.OPERATIONS = j, e2.CATEGORIES = k, e2.LinearRetryPolicy = ln.LinearRetryPolicy, e2.ExponentialRetryPolicy = ln.ExponentialRetryPolicy, e2;
      }(), _n = function() {
        function e2(e3) {
          var t2 = this;
          this._modules = {}, Object.keys(e3).forEach(function(n2) {
            t2._modules[n2] = e3[n2].bind(t2);
          });
        }
        return e2.prototype.init = function(e3) {
          this._config = e3, Array.isArray(this._config.origin) ? this._currentSubDomain = Math.floor(Math.random() * this._config.origin.length) : this._currentSubDomain = 0, this._coreParams = {}, this.shiftStandardOrigin();
        }, e2.prototype.nextOrigin = function() {
          var e3 = this._config.secure ? "https://" : "http://";
          if ("string" == typeof this._config.origin) return "".concat(e3).concat(this._config.origin);
          this._currentSubDomain += 1, this._currentSubDomain >= this._config.origin.length && (this._currentSubDomain = 0);
          var t2 = this._config.origin[this._currentSubDomain];
          return "".concat(e3).concat(t2);
        }, e2.prototype.hasModule = function(e3) {
          return e3 in this._modules;
        }, e2.prototype.shiftStandardOrigin = function() {
          return this._standardOrigin = this.nextOrigin(), this._standardOrigin;
        }, e2.prototype.getStandardOrigin = function() {
          return this._standardOrigin;
        }, e2.prototype.POSTFILE = function(e3, t2, n2) {
          return this._modules.postfile(e3, t2, n2);
        }, e2.prototype.GETFILE = function(e3, t2, n2) {
          return this._modules.getfile(e3, t2, n2);
        }, e2.prototype.POST = function(e3, t2, n2, r2) {
          return this._modules.post(e3, t2, n2, r2);
        }, e2.prototype.PATCH = function(e3, t2, n2, r2) {
          return this._modules.patch(e3, t2, n2, r2);
        }, e2.prototype.GET = function(e3, t2, n2) {
          return this._modules.get(e3, t2, n2);
        }, e2.prototype.DELETE = function(e3, t2, n2) {
          return this._modules.del(e3, t2, n2);
        }, e2.prototype._detectErrorCategory = function(e3) {
          if ("ENOTFOUND" === e3.code) return k.PNNetworkIssuesCategory;
          if ("ECONNREFUSED" === e3.code) return k.PNNetworkIssuesCategory;
          if ("ECONNRESET" === e3.code) return k.PNNetworkIssuesCategory;
          if ("EAI_AGAIN" === e3.code) return k.PNNetworkIssuesCategory;
          if (0 === e3.status || e3.hasOwnProperty("status") && void 0 === e3.status) return k.PNNetworkIssuesCategory;
          if (e3.timeout) return k.PNTimeoutCategory;
          if ("ETIMEDOUT" === e3.code) return k.PNNetworkIssuesCategory;
          if (e3.response) {
            if (e3.response.badRequest) return k.PNBadRequestCategory;
            if (e3.response.forbidden) return k.PNAccessDeniedCategory;
          }
          return k.PNUnknownCategory;
        }, e2;
      }();
      function Sn(e2) {
        var t2 = function(e3) {
          return e3 && "object" == typeof e3 && e3.constructor === Object;
        };
        if (!t2(e2)) return e2;
        var n2 = {};
        return Object.keys(e2).forEach(function(r2) {
          var o2 = function(e3) {
            return "string" == typeof e3 || e3 instanceof String;
          }(r2), i2 = r2, s2 = e2[r2];
          Array.isArray(r2) || o2 && r2.indexOf(",") >= 0 ? i2 = (o2 ? r2.split(",") : r2).reduce(function(e3, t3) {
            return e3 += String.fromCharCode(t3);
          }, "") : (function(e3) {
            return "number" == typeof e3 && isFinite(e3);
          }(r2) || o2 && !isNaN(r2)) && (i2 = String.fromCharCode(o2 ? parseInt(r2, 10) : 10));
          n2[i2] = t2(s2) ? Sn(s2) : s2;
        }), n2;
      }
      var wn = function() {
        function e2(e3, t2) {
          this._base64ToBinary = t2, this._decode = e3;
        }
        return e2.prototype.decodeToken = function(e3) {
          var t2 = "";
          e3.length % 4 == 3 ? t2 = "=" : e3.length % 4 == 2 && (t2 = "==");
          var n2 = e3.replace(/-/gi, "+").replace(/_/gi, "/") + t2, r2 = this._decode(this._base64ToBinary(n2));
          if ("object" == typeof r2) return r2;
        }, e2;
      }(), On = { exports: {} }, Pn = { exports: {} };
      !function(e2) {
        function t2(e3) {
          if (e3) return function(e4) {
            for (var n2 in t2.prototype) e4[n2] = t2.prototype[n2];
            return e4;
          }(e3);
        }
        e2.exports = t2, t2.prototype.on = t2.prototype.addEventListener = function(e3, t3) {
          return this._callbacks = this._callbacks || {}, (this._callbacks["$" + e3] = this._callbacks["$" + e3] || []).push(t3), this;
        }, t2.prototype.once = function(e3, t3) {
          function n2() {
            this.off(e3, n2), t3.apply(this, arguments);
          }
          return n2.fn = t3, this.on(e3, n2), this;
        }, t2.prototype.off = t2.prototype.removeListener = t2.prototype.removeAllListeners = t2.prototype.removeEventListener = function(e3, t3) {
          if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;
          var n2, r2 = this._callbacks["$" + e3];
          if (!r2) return this;
          if (1 == arguments.length) return delete this._callbacks["$" + e3], this;
          for (var o2 = 0; o2 < r2.length; o2++) if ((n2 = r2[o2]) === t3 || n2.fn === t3) {
            r2.splice(o2, 1);
            break;
          }
          return 0 === r2.length && delete this._callbacks["$" + e3], this;
        }, t2.prototype.emit = function(e3) {
          this._callbacks = this._callbacks || {};
          for (var t3 = new Array(arguments.length - 1), n2 = this._callbacks["$" + e3], r2 = 1; r2 < arguments.length; r2++) t3[r2 - 1] = arguments[r2];
          if (n2) {
            r2 = 0;
            for (var o2 = (n2 = n2.slice(0)).length; r2 < o2; ++r2) n2[r2].apply(this, t3);
          }
          return this;
        }, t2.prototype.listeners = function(e3) {
          return this._callbacks = this._callbacks || {}, this._callbacks["$" + e3] || [];
        }, t2.prototype.hasListeners = function(e3) {
          return !!this.listeners(e3).length;
        };
      }(Pn);
      var En = Mn;
      Mn.default = Mn, Mn.stable = Un, Mn.stableStringify = Un;
      var An = "[...]", Tn = "[Circular]", Nn = [], Cn = [];
      function kn() {
        return { depthLimit: Number.MAX_SAFE_INTEGER, edgesLimit: Number.MAX_SAFE_INTEGER };
      }
      function Mn(e2, t2, n2, r2) {
        var o2;
        void 0 === r2 && (r2 = kn()), Rn(e2, "", 0, [], void 0, 0, r2);
        try {
          o2 = 0 === Cn.length ? JSON.stringify(e2, t2, n2) : JSON.stringify(e2, Dn(t2), n2);
        } catch (e3) {
          return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
        } finally {
          for (; 0 !== Nn.length; ) {
            var i2 = Nn.pop();
            4 === i2.length ? Object.defineProperty(i2[0], i2[1], i2[3]) : i2[0][i2[1]] = i2[2];
          }
        }
        return o2;
      }
      function jn(e2, t2, n2, r2) {
        var o2 = Object.getOwnPropertyDescriptor(r2, n2);
        void 0 !== o2.get ? o2.configurable ? (Object.defineProperty(r2, n2, { value: e2 }), Nn.push([r2, n2, t2, o2])) : Cn.push([t2, n2, e2]) : (r2[n2] = e2, Nn.push([r2, n2, t2]));
      }
      function Rn(e2, t2, n2, r2, o2, i2, s2) {
        var a2;
        if (i2 += 1, "object" == typeof e2 && null !== e2) {
          for (a2 = 0; a2 < r2.length; a2++) if (r2[a2] === e2) return void jn(Tn, e2, t2, o2);
          if (void 0 !== s2.depthLimit && i2 > s2.depthLimit) return void jn(An, e2, t2, o2);
          if (void 0 !== s2.edgesLimit && n2 + 1 > s2.edgesLimit) return void jn(An, e2, t2, o2);
          if (r2.push(e2), Array.isArray(e2)) for (a2 = 0; a2 < e2.length; a2++) Rn(e2[a2], a2, a2, r2, e2, i2, s2);
          else {
            var u2 = Object.keys(e2);
            for (a2 = 0; a2 < u2.length; a2++) {
              var c2 = u2[a2];
              Rn(e2[c2], c2, a2, r2, e2, i2, s2);
            }
          }
          r2.pop();
        }
      }
      function xn(e2, t2) {
        return e2 < t2 ? -1 : e2 > t2 ? 1 : 0;
      }
      function Un(e2, t2, n2, r2) {
        void 0 === r2 && (r2 = kn());
        var o2, i2 = In(e2, "", 0, [], void 0, 0, r2) || e2;
        try {
          o2 = 0 === Cn.length ? JSON.stringify(i2, t2, n2) : JSON.stringify(i2, Dn(t2), n2);
        } catch (e3) {
          return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
        } finally {
          for (; 0 !== Nn.length; ) {
            var s2 = Nn.pop();
            4 === s2.length ? Object.defineProperty(s2[0], s2[1], s2[3]) : s2[0][s2[1]] = s2[2];
          }
        }
        return o2;
      }
      function In(e2, t2, n2, r2, o2, i2, s2) {
        var a2;
        if (i2 += 1, "object" == typeof e2 && null !== e2) {
          for (a2 = 0; a2 < r2.length; a2++) if (r2[a2] === e2) return void jn(Tn, e2, t2, o2);
          try {
            if ("function" == typeof e2.toJSON) return;
          } catch (e3) {
            return;
          }
          if (void 0 !== s2.depthLimit && i2 > s2.depthLimit) return void jn(An, e2, t2, o2);
          if (void 0 !== s2.edgesLimit && n2 + 1 > s2.edgesLimit) return void jn(An, e2, t2, o2);
          if (r2.push(e2), Array.isArray(e2)) for (a2 = 0; a2 < e2.length; a2++) In(e2[a2], a2, a2, r2, e2, i2, s2);
          else {
            var u2 = {}, c2 = Object.keys(e2).sort(xn);
            for (a2 = 0; a2 < c2.length; a2++) {
              var l2 = c2[a2];
              In(e2[l2], l2, a2, r2, e2, i2, s2), u2[l2] = e2[l2];
            }
            if (void 0 === o2) return u2;
            Nn.push([o2, t2, e2]), o2[t2] = u2;
          }
          r2.pop();
        }
      }
      function Dn(e2) {
        return e2 = void 0 !== e2 ? e2 : function(e3, t2) {
          return t2;
        }, function(t2, n2) {
          if (Cn.length > 0) for (var r2 = 0; r2 < Cn.length; r2++) {
            var o2 = Cn[r2];
            if (o2[1] === t2 && o2[0] === n2) {
              n2 = o2[2], Cn.splice(r2, 1);
              break;
            }
          }
          return e2.call(this, t2, n2);
        };
      }
      var Fn, Ln = "undefined" != typeof Symbol && Symbol, Gn = function() {
        if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols) return false;
        if ("symbol" == typeof Symbol.iterator) return true;
        var e2 = {}, t2 = Symbol("test"), n2 = Object(t2);
        if ("string" == typeof t2) return false;
        if ("[object Symbol]" !== Object.prototype.toString.call(t2)) return false;
        if ("[object Symbol]" !== Object.prototype.toString.call(n2)) return false;
        for (t2 in e2[t2] = 42, e2) return false;
        if ("function" == typeof Object.keys && 0 !== Object.keys(e2).length) return false;
        if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(e2).length) return false;
        var r2 = Object.getOwnPropertySymbols(e2);
        if (1 !== r2.length || r2[0] !== t2) return false;
        if (!Object.prototype.propertyIsEnumerable.call(e2, t2)) return false;
        if ("function" == typeof Object.getOwnPropertyDescriptor) {
          var o2 = Object.getOwnPropertyDescriptor(e2, t2);
          if (42 !== o2.value || true !== o2.enumerable) return false;
        }
        return true;
      }, Kn = "Function.prototype.bind called on incompatible ", Bn = Array.prototype.slice, Hn = Object.prototype.toString, qn = "[object Function]", zn = function(e2) {
        var t2 = this;
        if ("function" != typeof t2 || Hn.call(t2) !== qn) throw new TypeError(Kn + t2);
        for (var n2, r2 = Bn.call(arguments, 1), o2 = function() {
          if (this instanceof n2) {
            var o3 = t2.apply(this, r2.concat(Bn.call(arguments)));
            return Object(o3) === o3 ? o3 : this;
          }
          return t2.apply(e2, r2.concat(Bn.call(arguments)));
        }, i2 = Math.max(0, t2.length - r2.length), s2 = [], a2 = 0; a2 < i2; a2++) s2.push("$" + a2);
        if (n2 = Function("binder", "return function (" + s2.join(",") + "){ return binder.apply(this,arguments); }")(o2), t2.prototype) {
          var u2 = function() {
          };
          u2.prototype = t2.prototype, n2.prototype = new u2(), u2.prototype = null;
        }
        return n2;
      }, Vn = Function.prototype.bind || zn, Wn = Vn.call(Function.call, Object.prototype.hasOwnProperty), Jn = SyntaxError, $n = Function, Qn = TypeError, Xn = function(e2) {
        try {
          return $n('"use strict"; return (' + e2 + ").constructor;")();
        } catch (e3) {
        }
      }, Yn = Object.getOwnPropertyDescriptor;
      if (Yn) try {
        Yn({}, "");
      } catch (e2) {
        Yn = null;
      }
      var Zn = function() {
        throw new Qn();
      }, er = Yn ? function() {
        try {
          return Zn;
        } catch (e2) {
          try {
            return Yn(arguments, "callee").get;
          } catch (e3) {
            return Zn;
          }
        }
      }() : Zn, tr = "function" == typeof Ln && "function" == typeof Symbol && "symbol" == typeof Ln("foo") && "symbol" == typeof Symbol("bar") && Gn(), nr = Object.getPrototypeOf || function(e2) {
        return e2.__proto__;
      }, rr = {}, or = "undefined" == typeof Uint8Array ? Fn : nr(Uint8Array), ir = { "%AggregateError%": "undefined" == typeof AggregateError ? Fn : AggregateError, "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? Fn : ArrayBuffer, "%ArrayIteratorPrototype%": tr ? nr([][Symbol.iterator]()) : Fn, "%AsyncFromSyncIteratorPrototype%": Fn, "%AsyncFunction%": rr, "%AsyncGenerator%": rr, "%AsyncGeneratorFunction%": rr, "%AsyncIteratorPrototype%": rr, "%Atomics%": "undefined" == typeof Atomics ? Fn : Atomics, "%BigInt%": "undefined" == typeof BigInt ? Fn : BigInt, "%Boolean%": Boolean, "%DataView%": "undefined" == typeof DataView ? Fn : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": "undefined" == typeof Float32Array ? Fn : Float32Array, "%Float64Array%": "undefined" == typeof Float64Array ? Fn : Float64Array, "%FinalizationRegistry%": "undefined" == typeof FinalizationRegistry ? Fn : FinalizationRegistry, "%Function%": $n, "%GeneratorFunction%": rr, "%Int8Array%": "undefined" == typeof Int8Array ? Fn : Int8Array, "%Int16Array%": "undefined" == typeof Int16Array ? Fn : Int16Array, "%Int32Array%": "undefined" == typeof Int32Array ? Fn : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": tr ? nr(nr([][Symbol.iterator]())) : Fn, "%JSON%": "object" == typeof JSON ? JSON : Fn, "%Map%": "undefined" == typeof Map ? Fn : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && tr ? nr((/* @__PURE__ */ new Map())[Symbol.iterator]()) : Fn, "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? Fn : Promise, "%Proxy%": "undefined" == typeof Proxy ? Fn : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": "undefined" == typeof Reflect ? Fn : Reflect, "%RegExp%": RegExp, "%Set%": "undefined" == typeof Set ? Fn : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && tr ? nr((/* @__PURE__ */ new Set())[Symbol.iterator]()) : Fn, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? Fn : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": tr ? nr(""[Symbol.iterator]()) : Fn, "%Symbol%": tr ? Symbol : Fn, "%SyntaxError%": Jn, "%ThrowTypeError%": er, "%TypedArray%": or, "%TypeError%": Qn, "%Uint8Array%": "undefined" == typeof Uint8Array ? Fn : Uint8Array, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? Fn : Uint8ClampedArray, "%Uint16Array%": "undefined" == typeof Uint16Array ? Fn : Uint16Array, "%Uint32Array%": "undefined" == typeof Uint32Array ? Fn : Uint32Array, "%URIError%": URIError, "%WeakMap%": "undefined" == typeof WeakMap ? Fn : WeakMap, "%WeakRef%": "undefined" == typeof WeakRef ? Fn : WeakRef, "%WeakSet%": "undefined" == typeof WeakSet ? Fn : WeakSet }, sr = function e2(t2) {
        var n2;
        if ("%AsyncFunction%" === t2) n2 = Xn("async function () {}");
        else if ("%GeneratorFunction%" === t2) n2 = Xn("function* () {}");
        else if ("%AsyncGeneratorFunction%" === t2) n2 = Xn("async function* () {}");
        else if ("%AsyncGenerator%" === t2) {
          var r2 = e2("%AsyncGeneratorFunction%");
          r2 && (n2 = r2.prototype);
        } else if ("%AsyncIteratorPrototype%" === t2) {
          var o2 = e2("%AsyncGenerator%");
          o2 && (n2 = nr(o2.prototype));
        }
        return ir[t2] = n2, n2;
      }, ar = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, ur = Vn, cr = Wn, lr = ur.call(Function.call, Array.prototype.concat), pr = ur.call(Function.apply, Array.prototype.splice), hr = ur.call(Function.call, String.prototype.replace), fr = ur.call(Function.call, String.prototype.slice), dr = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, yr = /\\(\\)?/g, gr = function(e2) {
        var t2 = fr(e2, 0, 1), n2 = fr(e2, -1);
        if ("%" === t2 && "%" !== n2) throw new Jn("invalid intrinsic syntax, expected closing `%`");
        if ("%" === n2 && "%" !== t2) throw new Jn("invalid intrinsic syntax, expected opening `%`");
        var r2 = [];
        return hr(e2, dr, function(e3, t3, n3, o2) {
          r2[r2.length] = n3 ? hr(o2, yr, "$1") : t3 || e3;
        }), r2;
      }, mr = function(e2, t2) {
        var n2, r2 = e2;
        if (cr(ar, r2) && (r2 = "%" + (n2 = ar[r2])[0] + "%"), cr(ir, r2)) {
          var o2 = ir[r2];
          if (o2 === rr && (o2 = sr(r2)), void 0 === o2 && !t2) throw new Qn("intrinsic " + e2 + " exists, but is not available. Please file an issue!");
          return { alias: n2, name: r2, value: o2 };
        }
        throw new Jn("intrinsic " + e2 + " does not exist!");
      }, br = function(e2, t2) {
        if ("string" != typeof e2 || 0 === e2.length) throw new Qn("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && "boolean" != typeof t2) throw new Qn('"allowMissing" argument must be a boolean');
        var n2 = gr(e2), r2 = n2.length > 0 ? n2[0] : "", o2 = mr("%" + r2 + "%", t2), i2 = o2.name, s2 = o2.value, a2 = false, u2 = o2.alias;
        u2 && (r2 = u2[0], pr(n2, lr([0, 1], u2)));
        for (var c2 = 1, l2 = true; c2 < n2.length; c2 += 1) {
          var p2 = n2[c2], h2 = fr(p2, 0, 1), f2 = fr(p2, -1);
          if (('"' === h2 || "'" === h2 || "`" === h2 || '"' === f2 || "'" === f2 || "`" === f2) && h2 !== f2) throw new Jn("property names with quotes must have matching quotes");
          if ("constructor" !== p2 && l2 || (a2 = true), cr(ir, i2 = "%" + (r2 += "." + p2) + "%")) s2 = ir[i2];
          else if (null != s2) {
            if (!(p2 in s2)) {
              if (!t2) throw new Qn("base intrinsic for " + e2 + " exists, but the property is not available.");
              return;
            }
            if (Yn && c2 + 1 >= n2.length) {
              var d2 = Yn(s2, p2);
              s2 = (l2 = !!d2) && "get" in d2 && !("originalValue" in d2.get) ? d2.get : s2[p2];
            } else l2 = cr(s2, p2), s2 = s2[p2];
            l2 && !a2 && (ir[i2] = s2);
          }
        }
        return s2;
      }, vr = { exports: {} };
      !function(e2) {
        var t2 = Vn, n2 = br, r2 = n2("%Function.prototype.apply%"), o2 = n2("%Function.prototype.call%"), i2 = n2("%Reflect.apply%", true) || t2.call(o2, r2), s2 = n2("%Object.getOwnPropertyDescriptor%", true), a2 = n2("%Object.defineProperty%", true), u2 = n2("%Math.max%");
        if (a2) try {
          a2({}, "a", { value: 1 });
        } catch (e3) {
          a2 = null;
        }
        e2.exports = function(e3) {
          var n3 = i2(t2, o2, arguments);
          if (s2 && a2) {
            var r3 = s2(n3, "length");
            r3.configurable && a2(n3, "length", { value: 1 + u2(0, e3.length - (arguments.length - 1)) });
          }
          return n3;
        };
        var c2 = function() {
          return i2(t2, r2, arguments);
        };
        a2 ? a2(e2.exports, "apply", { value: c2 }) : e2.exports.apply = c2;
      }(vr);
      var _r = br, Sr = vr.exports, wr = Sr(_r("String.prototype.indexOf")), Or = l(Object.freeze({ __proto__: null, default: {} })), Pr = "function" == typeof Map && Map.prototype, Er = Object.getOwnPropertyDescriptor && Pr ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, Ar = Pr && Er && "function" == typeof Er.get ? Er.get : null, Tr = Pr && Map.prototype.forEach, Nr = "function" == typeof Set && Set.prototype, Cr = Object.getOwnPropertyDescriptor && Nr ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, kr = Nr && Cr && "function" == typeof Cr.get ? Cr.get : null, Mr = Nr && Set.prototype.forEach, jr = "function" == typeof WeakMap && WeakMap.prototype ? WeakMap.prototype.has : null, Rr = "function" == typeof WeakSet && WeakSet.prototype ? WeakSet.prototype.has : null, xr = "function" == typeof WeakRef && WeakRef.prototype ? WeakRef.prototype.deref : null, Ur = Boolean.prototype.valueOf, Ir = Object.prototype.toString, Dr = Function.prototype.toString, Fr = String.prototype.match, Lr = String.prototype.slice, Gr = String.prototype.replace, Kr = String.prototype.toUpperCase, Br = String.prototype.toLowerCase, Hr = RegExp.prototype.test, qr = Array.prototype.concat, zr = Array.prototype.join, Vr = Array.prototype.slice, Wr = Math.floor, Jr = "function" == typeof BigInt ? BigInt.prototype.valueOf : null, $r = Object.getOwnPropertySymbols, Qr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? Symbol.prototype.toString : null, Xr = "function" == typeof Symbol && "object" == typeof Symbol.iterator, Yr = "function" == typeof Symbol && Symbol.toStringTag && (typeof Symbol.toStringTag === Xr || "symbol") ? Symbol.toStringTag : null, Zr = Object.prototype.propertyIsEnumerable, eo = ("function" == typeof Reflect ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(e2) {
        return e2.__proto__;
      } : null);
      function to(e2, t2) {
        if (e2 === 1 / 0 || e2 === -1 / 0 || e2 != e2 || e2 && e2 > -1e3 && e2 < 1e3 || Hr.call(/e/, t2)) return t2;
        var n2 = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
        if ("number" == typeof e2) {
          var r2 = e2 < 0 ? -Wr(-e2) : Wr(e2);
          if (r2 !== e2) {
            var o2 = String(r2), i2 = Lr.call(t2, o2.length + 1);
            return Gr.call(o2, n2, "$&_") + "." + Gr.call(Gr.call(i2, /([0-9]{3})/g, "$&_"), /_$/, "");
          }
        }
        return Gr.call(t2, n2, "$&_");
      }
      var no = Or, ro = no.custom, oo = co(ro) ? ro : null;
      function io(e2, t2, n2) {
        var r2 = "double" === (n2.quoteStyle || t2) ? '"' : "'";
        return r2 + e2 + r2;
      }
      function so(e2) {
        return Gr.call(String(e2), /"/g, "&quot;");
      }
      function ao(e2) {
        return !("[object Array]" !== ho(e2) || Yr && "object" == typeof e2 && Yr in e2);
      }
      function uo(e2) {
        return !("[object RegExp]" !== ho(e2) || Yr && "object" == typeof e2 && Yr in e2);
      }
      function co(e2) {
        if (Xr) return e2 && "object" == typeof e2 && e2 instanceof Symbol;
        if ("symbol" == typeof e2) return true;
        if (!e2 || "object" != typeof e2 || !Qr) return false;
        try {
          return Qr.call(e2), true;
        } catch (e3) {
        }
        return false;
      }
      var lo = Object.prototype.hasOwnProperty || function(e2) {
        return e2 in this;
      };
      function po(e2, t2) {
        return lo.call(e2, t2);
      }
      function ho(e2) {
        return Ir.call(e2);
      }
      function fo(e2, t2) {
        if (e2.indexOf) return e2.indexOf(t2);
        for (var n2 = 0, r2 = e2.length; n2 < r2; n2++) if (e2[n2] === t2) return n2;
        return -1;
      }
      function yo(e2, t2) {
        if (e2.length > t2.maxStringLength) {
          var n2 = e2.length - t2.maxStringLength, r2 = "... " + n2 + " more character" + (n2 > 1 ? "s" : "");
          return yo(Lr.call(e2, 0, t2.maxStringLength), t2) + r2;
        }
        return io(Gr.call(Gr.call(e2, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, go), "single", t2);
      }
      function go(e2) {
        var t2 = e2.charCodeAt(0), n2 = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[t2];
        return n2 ? "\\" + n2 : "\\x" + (t2 < 16 ? "0" : "") + Kr.call(t2.toString(16));
      }
      function mo(e2) {
        return "Object(" + e2 + ")";
      }
      function bo(e2) {
        return e2 + " { ? }";
      }
      function vo(e2, t2, n2, r2) {
        return e2 + " (" + t2 + ") {" + (r2 ? _o(n2, r2) : zr.call(n2, ", ")) + "}";
      }
      function _o(e2, t2) {
        if (0 === e2.length) return "";
        var n2 = "\n" + t2.prev + t2.base;
        return n2 + zr.call(e2, "," + n2) + "\n" + t2.prev;
      }
      function So(e2, t2) {
        var n2 = ao(e2), r2 = [];
        if (n2) {
          r2.length = e2.length;
          for (var o2 = 0; o2 < e2.length; o2++) r2[o2] = po(e2, o2) ? t2(e2[o2], e2) : "";
        }
        var i2, s2 = "function" == typeof $r ? $r(e2) : [];
        if (Xr) {
          i2 = {};
          for (var a2 = 0; a2 < s2.length; a2++) i2["$" + s2[a2]] = s2[a2];
        }
        for (var u2 in e2) po(e2, u2) && (n2 && String(Number(u2)) === u2 && u2 < e2.length || Xr && i2["$" + u2] instanceof Symbol || (Hr.call(/[^\w$]/, u2) ? r2.push(t2(u2, e2) + ": " + t2(e2[u2], e2)) : r2.push(u2 + ": " + t2(e2[u2], e2))));
        if ("function" == typeof $r) for (var c2 = 0; c2 < s2.length; c2++) Zr.call(e2, s2[c2]) && r2.push("[" + t2(s2[c2]) + "]: " + t2(e2[s2[c2]], e2));
        return r2;
      }
      var wo = br, Oo = function(e2, t2) {
        var n2 = _r(e2, !!t2);
        return "function" == typeof n2 && wr(e2, ".prototype.") > -1 ? Sr(n2) : n2;
      }, Po = function e2(t2, n2, r2, o2) {
        var i2 = n2 || {};
        if (po(i2, "quoteStyle") && "single" !== i2.quoteStyle && "double" !== i2.quoteStyle) throw new TypeError('option "quoteStyle" must be "single" or "double"');
        if (po(i2, "maxStringLength") && ("number" == typeof i2.maxStringLength ? i2.maxStringLength < 0 && i2.maxStringLength !== 1 / 0 : null !== i2.maxStringLength)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
        var s2 = !po(i2, "customInspect") || i2.customInspect;
        if ("boolean" != typeof s2 && "symbol" !== s2) throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
        if (po(i2, "indent") && null !== i2.indent && "	" !== i2.indent && !(parseInt(i2.indent, 10) === i2.indent && i2.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
        if (po(i2, "numericSeparator") && "boolean" != typeof i2.numericSeparator) throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
        var a2 = i2.numericSeparator;
        if (void 0 === t2) return "undefined";
        if (null === t2) return "null";
        if ("boolean" == typeof t2) return t2 ? "true" : "false";
        if ("string" == typeof t2) return yo(t2, i2);
        if ("number" == typeof t2) {
          if (0 === t2) return 1 / 0 / t2 > 0 ? "0" : "-0";
          var u2 = String(t2);
          return a2 ? to(t2, u2) : u2;
        }
        if ("bigint" == typeof t2) {
          var l2 = String(t2) + "n";
          return a2 ? to(t2, l2) : l2;
        }
        var p2 = void 0 === i2.depth ? 5 : i2.depth;
        if (void 0 === r2 && (r2 = 0), r2 >= p2 && p2 > 0 && "object" == typeof t2) return ao(t2) ? "[Array]" : "[Object]";
        var h2 = function(e3, t3) {
          var n3;
          if ("	" === e3.indent) n3 = "	";
          else {
            if (!("number" == typeof e3.indent && e3.indent > 0)) return null;
            n3 = zr.call(Array(e3.indent + 1), " ");
          }
          return { base: n3, prev: zr.call(Array(t3 + 1), n3) };
        }(i2, r2);
        if (void 0 === o2) o2 = [];
        else if (fo(o2, t2) >= 0) return "[Circular]";
        function f2(t3, n3, s3) {
          if (n3 && (o2 = Vr.call(o2)).push(n3), s3) {
            var a3 = { depth: i2.depth };
            return po(i2, "quoteStyle") && (a3.quoteStyle = i2.quoteStyle), e2(t3, a3, r2 + 1, o2);
          }
          return e2(t3, i2, r2 + 1, o2);
        }
        if ("function" == typeof t2 && !uo(t2)) {
          var d2 = function(e3) {
            if (e3.name) return e3.name;
            var t3 = Fr.call(Dr.call(e3), /^function\s*([\w$]+)/);
            if (t3) return t3[1];
            return null;
          }(t2), y2 = So(t2, f2);
          return "[Function" + (d2 ? ": " + d2 : " (anonymous)") + "]" + (y2.length > 0 ? " { " + zr.call(y2, ", ") + " }" : "");
        }
        if (co(t2)) {
          var g2 = Xr ? Gr.call(String(t2), /^(Symbol\(.*\))_[^)]*$/, "$1") : Qr.call(t2);
          return "object" != typeof t2 || Xr ? g2 : mo(g2);
        }
        if (function(e3) {
          if (!e3 || "object" != typeof e3) return false;
          if ("undefined" != typeof HTMLElement && e3 instanceof HTMLElement) return true;
          return "string" == typeof e3.nodeName && "function" == typeof e3.getAttribute;
        }(t2)) {
          for (var m2 = "<" + Br.call(String(t2.nodeName)), b2 = t2.attributes || [], v2 = 0; v2 < b2.length; v2++) m2 += " " + b2[v2].name + "=" + io(so(b2[v2].value), "double", i2);
          return m2 += ">", t2.childNodes && t2.childNodes.length && (m2 += "..."), m2 += "</" + Br.call(String(t2.nodeName)) + ">";
        }
        if (ao(t2)) {
          if (0 === t2.length) return "[]";
          var _2 = So(t2, f2);
          return h2 && !function(e3) {
            for (var t3 = 0; t3 < e3.length; t3++) if (fo(e3[t3], "\n") >= 0) return false;
            return true;
          }(_2) ? "[" + _o(_2, h2) + "]" : "[ " + zr.call(_2, ", ") + " ]";
        }
        if (function(e3) {
          return !("[object Error]" !== ho(e3) || Yr && "object" == typeof e3 && Yr in e3);
        }(t2)) {
          var S2 = So(t2, f2);
          return "cause" in Error.prototype || !("cause" in t2) || Zr.call(t2, "cause") ? 0 === S2.length ? "[" + String(t2) + "]" : "{ [" + String(t2) + "] " + zr.call(S2, ", ") + " }" : "{ [" + String(t2) + "] " + zr.call(qr.call("[cause]: " + f2(t2.cause), S2), ", ") + " }";
        }
        if ("object" == typeof t2 && s2) {
          if (oo && "function" == typeof t2[oo] && no) return no(t2, { depth: p2 - r2 });
          if ("symbol" !== s2 && "function" == typeof t2.inspect) return t2.inspect();
        }
        if (function(e3) {
          if (!Ar || !e3 || "object" != typeof e3) return false;
          try {
            Ar.call(e3);
            try {
              kr.call(e3);
            } catch (e4) {
              return true;
            }
            return e3 instanceof Map;
          } catch (e4) {
          }
          return false;
        }(t2)) {
          var w2 = [];
          return Tr && Tr.call(t2, function(e3, n3) {
            w2.push(f2(n3, t2, true) + " => " + f2(e3, t2));
          }), vo("Map", Ar.call(t2), w2, h2);
        }
        if (function(e3) {
          if (!kr || !e3 || "object" != typeof e3) return false;
          try {
            kr.call(e3);
            try {
              Ar.call(e3);
            } catch (e4) {
              return true;
            }
            return e3 instanceof Set;
          } catch (e4) {
          }
          return false;
        }(t2)) {
          var O2 = [];
          return Mr && Mr.call(t2, function(e3) {
            O2.push(f2(e3, t2));
          }), vo("Set", kr.call(t2), O2, h2);
        }
        if (function(e3) {
          if (!jr || !e3 || "object" != typeof e3) return false;
          try {
            jr.call(e3, jr);
            try {
              Rr.call(e3, Rr);
            } catch (e4) {
              return true;
            }
            return e3 instanceof WeakMap;
          } catch (e4) {
          }
          return false;
        }(t2)) return bo("WeakMap");
        if (function(e3) {
          if (!Rr || !e3 || "object" != typeof e3) return false;
          try {
            Rr.call(e3, Rr);
            try {
              jr.call(e3, jr);
            } catch (e4) {
              return true;
            }
            return e3 instanceof WeakSet;
          } catch (e4) {
          }
          return false;
        }(t2)) return bo("WeakSet");
        if (function(e3) {
          if (!xr || !e3 || "object" != typeof e3) return false;
          try {
            return xr.call(e3), true;
          } catch (e4) {
          }
          return false;
        }(t2)) return bo("WeakRef");
        if (function(e3) {
          return !("[object Number]" !== ho(e3) || Yr && "object" == typeof e3 && Yr in e3);
        }(t2)) return mo(f2(Number(t2)));
        if (function(e3) {
          if (!e3 || "object" != typeof e3 || !Jr) return false;
          try {
            return Jr.call(e3), true;
          } catch (e4) {
          }
          return false;
        }(t2)) return mo(f2(Jr.call(t2)));
        if (function(e3) {
          return !("[object Boolean]" !== ho(e3) || Yr && "object" == typeof e3 && Yr in e3);
        }(t2)) return mo(Ur.call(t2));
        if (function(e3) {
          return !("[object String]" !== ho(e3) || Yr && "object" == typeof e3 && Yr in e3);
        }(t2)) return mo(f2(String(t2)));
        if ("undefined" != typeof window && t2 === window) return "{ [object Window] }";
        if (t2 === c) return "{ [object globalThis] }";
        if (!function(e3) {
          return !("[object Date]" !== ho(e3) || Yr && "object" == typeof e3 && Yr in e3);
        }(t2) && !uo(t2)) {
          var P2 = So(t2, f2), E2 = eo ? eo(t2) === Object.prototype : t2 instanceof Object || t2.constructor === Object, A2 = t2 instanceof Object ? "" : "null prototype", T2 = !E2 && Yr && Object(t2) === t2 && Yr in t2 ? Lr.call(ho(t2), 8, -1) : A2 ? "Object" : "", N2 = (E2 || "function" != typeof t2.constructor ? "" : t2.constructor.name ? t2.constructor.name + " " : "") + (T2 || A2 ? "[" + zr.call(qr.call([], T2 || [], A2 || []), ": ") + "] " : "");
          return 0 === P2.length ? N2 + "{}" : h2 ? N2 + "{" + _o(P2, h2) + "}" : N2 + "{ " + zr.call(P2, ", ") + " }";
        }
        return String(t2);
      }, Eo = wo("%TypeError%"), Ao = wo("%WeakMap%", true), To = wo("%Map%", true), No = Oo("WeakMap.prototype.get", true), Co = Oo("WeakMap.prototype.set", true), ko = Oo("WeakMap.prototype.has", true), Mo = Oo("Map.prototype.get", true), jo = Oo("Map.prototype.set", true), Ro = Oo("Map.prototype.has", true), xo = function(e2, t2) {
        for (var n2, r2 = e2; null !== (n2 = r2.next); r2 = n2) if (n2.key === t2) return r2.next = n2.next, n2.next = e2.next, e2.next = n2, n2;
      }, Uo = String.prototype.replace, Io = /%20/g, Do = "RFC3986", Fo = { default: Do, formatters: { RFC1738: function(e2) {
        return Uo.call(e2, Io, "+");
      }, RFC3986: function(e2) {
        return String(e2);
      } }, RFC1738: "RFC1738", RFC3986: Do }, Lo = Fo, Go = Object.prototype.hasOwnProperty, Ko = Array.isArray, Bo = function() {
        for (var e2 = [], t2 = 0; t2 < 256; ++t2) e2.push("%" + ((t2 < 16 ? "0" : "") + t2.toString(16)).toUpperCase());
        return e2;
      }(), Ho = function(e2, t2) {
        for (var n2 = t2 && t2.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, r2 = 0; r2 < e2.length; ++r2) void 0 !== e2[r2] && (n2[r2] = e2[r2]);
        return n2;
      }, qo = { arrayToObject: Ho, assign: function(e2, t2) {
        return Object.keys(t2).reduce(function(e3, n2) {
          return e3[n2] = t2[n2], e3;
        }, e2);
      }, combine: function(e2, t2) {
        return [].concat(e2, t2);
      }, compact: function(e2) {
        for (var t2 = [{ obj: { o: e2 }, prop: "o" }], n2 = [], r2 = 0; r2 < t2.length; ++r2) for (var o2 = t2[r2], i2 = o2.obj[o2.prop], s2 = Object.keys(i2), a2 = 0; a2 < s2.length; ++a2) {
          var u2 = s2[a2], c2 = i2[u2];
          "object" == typeof c2 && null !== c2 && -1 === n2.indexOf(c2) && (t2.push({ obj: i2, prop: u2 }), n2.push(c2));
        }
        return function(e3) {
          for (; e3.length > 1; ) {
            var t3 = e3.pop(), n3 = t3.obj[t3.prop];
            if (Ko(n3)) {
              for (var r3 = [], o3 = 0; o3 < n3.length; ++o3) void 0 !== n3[o3] && r3.push(n3[o3]);
              t3.obj[t3.prop] = r3;
            }
          }
        }(t2), e2;
      }, decode: function(e2, t2, n2) {
        var r2 = e2.replace(/\+/g, " ");
        if ("iso-8859-1" === n2) return r2.replace(/%[0-9a-f]{2}/gi, unescape);
        try {
          return decodeURIComponent(r2);
        } catch (e3) {
          return r2;
        }
      }, encode: function(e2, t2, n2, r2, o2) {
        if (0 === e2.length) return e2;
        var i2 = e2;
        if ("symbol" == typeof e2 ? i2 = Symbol.prototype.toString.call(e2) : "string" != typeof e2 && (i2 = String(e2)), "iso-8859-1" === n2) return escape(i2).replace(/%u[0-9a-f]{4}/gi, function(e3) {
          return "%26%23" + parseInt(e3.slice(2), 16) + "%3B";
        });
        for (var s2 = "", a2 = 0; a2 < i2.length; ++a2) {
          var u2 = i2.charCodeAt(a2);
          45 === u2 || 46 === u2 || 95 === u2 || 126 === u2 || u2 >= 48 && u2 <= 57 || u2 >= 65 && u2 <= 90 || u2 >= 97 && u2 <= 122 || o2 === Lo.RFC1738 && (40 === u2 || 41 === u2) ? s2 += i2.charAt(a2) : u2 < 128 ? s2 += Bo[u2] : u2 < 2048 ? s2 += Bo[192 | u2 >> 6] + Bo[128 | 63 & u2] : u2 < 55296 || u2 >= 57344 ? s2 += Bo[224 | u2 >> 12] + Bo[128 | u2 >> 6 & 63] + Bo[128 | 63 & u2] : (a2 += 1, u2 = 65536 + ((1023 & u2) << 10 | 1023 & i2.charCodeAt(a2)), s2 += Bo[240 | u2 >> 18] + Bo[128 | u2 >> 12 & 63] + Bo[128 | u2 >> 6 & 63] + Bo[128 | 63 & u2]);
        }
        return s2;
      }, isBuffer: function(e2) {
        return !(!e2 || "object" != typeof e2) && !!(e2.constructor && e2.constructor.isBuffer && e2.constructor.isBuffer(e2));
      }, isRegExp: function(e2) {
        return "[object RegExp]" === Object.prototype.toString.call(e2);
      }, maybeMap: function(e2, t2) {
        if (Ko(e2)) {
          for (var n2 = [], r2 = 0; r2 < e2.length; r2 += 1) n2.push(t2(e2[r2]));
          return n2;
        }
        return t2(e2);
      }, merge: function e2(t2, n2, r2) {
        if (!n2) return t2;
        if ("object" != typeof n2) {
          if (Ko(t2)) t2.push(n2);
          else {
            if (!t2 || "object" != typeof t2) return [t2, n2];
            (r2 && (r2.plainObjects || r2.allowPrototypes) || !Go.call(Object.prototype, n2)) && (t2[n2] = true);
          }
          return t2;
        }
        if (!t2 || "object" != typeof t2) return [t2].concat(n2);
        var o2 = t2;
        return Ko(t2) && !Ko(n2) && (o2 = Ho(t2, r2)), Ko(t2) && Ko(n2) ? (n2.forEach(function(n3, o3) {
          if (Go.call(t2, o3)) {
            var i2 = t2[o3];
            i2 && "object" == typeof i2 && n3 && "object" == typeof n3 ? t2[o3] = e2(i2, n3, r2) : t2.push(n3);
          } else t2[o3] = n3;
        }), t2) : Object.keys(n2).reduce(function(t3, o3) {
          var i2 = n2[o3];
          return Go.call(t3, o3) ? t3[o3] = e2(t3[o3], i2, r2) : t3[o3] = i2, t3;
        }, o2);
      } }, zo = function() {
        var e2, t2, n2, r2 = { assert: function(e3) {
          if (!r2.has(e3)) throw new Eo("Side channel does not contain " + Po(e3));
        }, get: function(r3) {
          if (Ao && r3 && ("object" == typeof r3 || "function" == typeof r3)) {
            if (e2) return No(e2, r3);
          } else if (To) {
            if (t2) return Mo(t2, r3);
          } else if (n2) return function(e3, t3) {
            var n3 = xo(e3, t3);
            return n3 && n3.value;
          }(n2, r3);
        }, has: function(r3) {
          if (Ao && r3 && ("object" == typeof r3 || "function" == typeof r3)) {
            if (e2) return ko(e2, r3);
          } else if (To) {
            if (t2) return Ro(t2, r3);
          } else if (n2) return function(e3, t3) {
            return !!xo(e3, t3);
          }(n2, r3);
          return false;
        }, set: function(r3, o2) {
          Ao && r3 && ("object" == typeof r3 || "function" == typeof r3) ? (e2 || (e2 = new Ao()), Co(e2, r3, o2)) : To ? (t2 || (t2 = new To()), jo(t2, r3, o2)) : (n2 || (n2 = { key: {}, next: null }), function(e3, t3, n3) {
            var r4 = xo(e3, t3);
            r4 ? r4.value = n3 : e3.next = { key: t3, next: e3.next, value: n3 };
          }(n2, r3, o2));
        } };
        return r2;
      }, Vo = qo, Wo = Fo, Jo = Object.prototype.hasOwnProperty, $o = { brackets: function(e2) {
        return e2 + "[]";
      }, comma: "comma", indices: function(e2, t2) {
        return e2 + "[" + t2 + "]";
      }, repeat: function(e2) {
        return e2;
      } }, Qo = Array.isArray, Xo = Array.prototype.push, Yo = function(e2, t2) {
        Xo.apply(e2, Qo(t2) ? t2 : [t2]);
      }, Zo = Date.prototype.toISOString, ei = Wo.default, ti = { addQueryPrefix: false, allowDots: false, charset: "utf-8", charsetSentinel: false, delimiter: "&", encode: true, encoder: Vo.encode, encodeValuesOnly: false, format: ei, formatter: Wo.formatters[ei], indices: false, serializeDate: function(e2) {
        return Zo.call(e2);
      }, skipNulls: false, strictNullHandling: false }, ni = {}, ri = function e2(t2, n2, r2, o2, i2, s2, a2, u2, c2, l2, p2, h2, f2, d2, y2, g2) {
        for (var m2, b2 = t2, v2 = g2, _2 = 0, S2 = false; void 0 !== (v2 = v2.get(ni)) && !S2; ) {
          var w2 = v2.get(t2);
          if (_2 += 1, void 0 !== w2) {
            if (w2 === _2) throw new RangeError("Cyclic object value");
            S2 = true;
          }
          void 0 === v2.get(ni) && (_2 = 0);
        }
        if ("function" == typeof u2 ? b2 = u2(n2, b2) : b2 instanceof Date ? b2 = p2(b2) : "comma" === r2 && Qo(b2) && (b2 = Vo.maybeMap(b2, function(e3) {
          return e3 instanceof Date ? p2(e3) : e3;
        })), null === b2) {
          if (i2) return a2 && !d2 ? a2(n2, ti.encoder, y2, "key", h2) : n2;
          b2 = "";
        }
        if ("string" == typeof (m2 = b2) || "number" == typeof m2 || "boolean" == typeof m2 || "symbol" == typeof m2 || "bigint" == typeof m2 || Vo.isBuffer(b2)) return a2 ? [f2(d2 ? n2 : a2(n2, ti.encoder, y2, "key", h2)) + "=" + f2(a2(b2, ti.encoder, y2, "value", h2))] : [f2(n2) + "=" + f2(String(b2))];
        var O2, P2 = [];
        if (void 0 === b2) return P2;
        if ("comma" === r2 && Qo(b2)) d2 && a2 && (b2 = Vo.maybeMap(b2, a2)), O2 = [{ value: b2.length > 0 ? b2.join(",") || null : void 0 }];
        else if (Qo(u2)) O2 = u2;
        else {
          var E2 = Object.keys(b2);
          O2 = c2 ? E2.sort(c2) : E2;
        }
        for (var A2 = o2 && Qo(b2) && 1 === b2.length ? n2 + "[]" : n2, T2 = 0; T2 < O2.length; ++T2) {
          var N2 = O2[T2], C2 = "object" == typeof N2 && void 0 !== N2.value ? N2.value : b2[N2];
          if (!s2 || null !== C2) {
            var k2 = Qo(b2) ? "function" == typeof r2 ? r2(A2, N2) : A2 : A2 + (l2 ? "." + N2 : "[" + N2 + "]");
            g2.set(t2, _2);
            var M2 = zo();
            M2.set(ni, g2), Yo(P2, e2(C2, k2, r2, o2, i2, s2, "comma" === r2 && d2 && Qo(b2) ? null : a2, u2, c2, l2, p2, h2, f2, d2, y2, M2));
          }
        }
        return P2;
      }, oi = qo, ii = Object.prototype.hasOwnProperty, si = Array.isArray, ai = { allowDots: false, allowPrototypes: false, allowSparse: false, arrayLimit: 20, charset: "utf-8", charsetSentinel: false, comma: false, decoder: oi.decode, delimiter: "&", depth: 5, ignoreQueryPrefix: false, interpretNumericEntities: false, parameterLimit: 1e3, parseArrays: true, plainObjects: false, strictNullHandling: false }, ui = function(e2) {
        return e2.replace(/&#(\d+);/g, function(e3, t2) {
          return String.fromCharCode(parseInt(t2, 10));
        });
      }, ci = function(e2, t2) {
        return e2 && "string" == typeof e2 && t2.comma && e2.indexOf(",") > -1 ? e2.split(",") : e2;
      }, li = function(e2, t2, n2, r2) {
        if (e2) {
          var o2 = n2.allowDots ? e2.replace(/\.([^.[]+)/g, "[$1]") : e2, i2 = /(\[[^[\]]*])/g, s2 = n2.depth > 0 && /(\[[^[\]]*])/.exec(o2), a2 = s2 ? o2.slice(0, s2.index) : o2, u2 = [];
          if (a2) {
            if (!n2.plainObjects && ii.call(Object.prototype, a2) && !n2.allowPrototypes) return;
            u2.push(a2);
          }
          for (var c2 = 0; n2.depth > 0 && null !== (s2 = i2.exec(o2)) && c2 < n2.depth; ) {
            if (c2 += 1, !n2.plainObjects && ii.call(Object.prototype, s2[1].slice(1, -1)) && !n2.allowPrototypes) return;
            u2.push(s2[1]);
          }
          return s2 && u2.push("[" + o2.slice(s2.index) + "]"), function(e3, t3, n3, r3) {
            for (var o3 = r3 ? t3 : ci(t3, n3), i3 = e3.length - 1; i3 >= 0; --i3) {
              var s3, a3 = e3[i3];
              if ("[]" === a3 && n3.parseArrays) s3 = [].concat(o3);
              else {
                s3 = n3.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
                var u3 = "[" === a3.charAt(0) && "]" === a3.charAt(a3.length - 1) ? a3.slice(1, -1) : a3, c3 = parseInt(u3, 10);
                n3.parseArrays || "" !== u3 ? !isNaN(c3) && a3 !== u3 && String(c3) === u3 && c3 >= 0 && n3.parseArrays && c3 <= n3.arrayLimit ? (s3 = [])[c3] = o3 : "__proto__" !== u3 && (s3[u3] = o3) : s3 = { 0: o3 };
              }
              o3 = s3;
            }
            return o3;
          }(u2, t2, n2, r2);
        }
      }, pi = function(e2, t2) {
        var n2, r2 = e2, o2 = function(e3) {
          if (!e3) return ti;
          if (null !== e3.encoder && void 0 !== e3.encoder && "function" != typeof e3.encoder) throw new TypeError("Encoder has to be a function.");
          var t3 = e3.charset || ti.charset;
          if (void 0 !== e3.charset && "utf-8" !== e3.charset && "iso-8859-1" !== e3.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
          var n3 = Wo.default;
          if (void 0 !== e3.format) {
            if (!Jo.call(Wo.formatters, e3.format)) throw new TypeError("Unknown format option provided.");
            n3 = e3.format;
          }
          var r3 = Wo.formatters[n3], o3 = ti.filter;
          return ("function" == typeof e3.filter || Qo(e3.filter)) && (o3 = e3.filter), { addQueryPrefix: "boolean" == typeof e3.addQueryPrefix ? e3.addQueryPrefix : ti.addQueryPrefix, allowDots: void 0 === e3.allowDots ? ti.allowDots : !!e3.allowDots, charset: t3, charsetSentinel: "boolean" == typeof e3.charsetSentinel ? e3.charsetSentinel : ti.charsetSentinel, delimiter: void 0 === e3.delimiter ? ti.delimiter : e3.delimiter, encode: "boolean" == typeof e3.encode ? e3.encode : ti.encode, encoder: "function" == typeof e3.encoder ? e3.encoder : ti.encoder, encodeValuesOnly: "boolean" == typeof e3.encodeValuesOnly ? e3.encodeValuesOnly : ti.encodeValuesOnly, filter: o3, format: n3, formatter: r3, serializeDate: "function" == typeof e3.serializeDate ? e3.serializeDate : ti.serializeDate, skipNulls: "boolean" == typeof e3.skipNulls ? e3.skipNulls : ti.skipNulls, sort: "function" == typeof e3.sort ? e3.sort : null, strictNullHandling: "boolean" == typeof e3.strictNullHandling ? e3.strictNullHandling : ti.strictNullHandling };
        }(t2);
        "function" == typeof o2.filter ? r2 = (0, o2.filter)("", r2) : Qo(o2.filter) && (n2 = o2.filter);
        var i2, s2 = [];
        if ("object" != typeof r2 || null === r2) return "";
        i2 = t2 && t2.arrayFormat in $o ? t2.arrayFormat : t2 && "indices" in t2 ? t2.indices ? "indices" : "repeat" : "indices";
        var a2 = $o[i2];
        if (t2 && "commaRoundTrip" in t2 && "boolean" != typeof t2.commaRoundTrip) throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
        var u2 = "comma" === a2 && t2 && t2.commaRoundTrip;
        n2 || (n2 = Object.keys(r2)), o2.sort && n2.sort(o2.sort);
        for (var c2 = zo(), l2 = 0; l2 < n2.length; ++l2) {
          var p2 = n2[l2];
          o2.skipNulls && null === r2[p2] || Yo(s2, ri(r2[p2], p2, a2, u2, o2.strictNullHandling, o2.skipNulls, o2.encode ? o2.encoder : null, o2.filter, o2.sort, o2.allowDots, o2.serializeDate, o2.format, o2.formatter, o2.encodeValuesOnly, o2.charset, c2));
        }
        var h2 = s2.join(o2.delimiter), f2 = true === o2.addQueryPrefix ? "?" : "";
        return o2.charsetSentinel && ("iso-8859-1" === o2.charset ? f2 += "utf8=%26%2310003%3B&" : f2 += "utf8=%E2%9C%93&"), h2.length > 0 ? f2 + h2 : "";
      }, hi = { formats: Fo, parse: function(e2, t2) {
        var n2 = function(e3) {
          if (!e3) return ai;
          if (null !== e3.decoder && void 0 !== e3.decoder && "function" != typeof e3.decoder) throw new TypeError("Decoder has to be a function.");
          if (void 0 !== e3.charset && "utf-8" !== e3.charset && "iso-8859-1" !== e3.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
          var t3 = void 0 === e3.charset ? ai.charset : e3.charset;
          return { allowDots: void 0 === e3.allowDots ? ai.allowDots : !!e3.allowDots, allowPrototypes: "boolean" == typeof e3.allowPrototypes ? e3.allowPrototypes : ai.allowPrototypes, allowSparse: "boolean" == typeof e3.allowSparse ? e3.allowSparse : ai.allowSparse, arrayLimit: "number" == typeof e3.arrayLimit ? e3.arrayLimit : ai.arrayLimit, charset: t3, charsetSentinel: "boolean" == typeof e3.charsetSentinel ? e3.charsetSentinel : ai.charsetSentinel, comma: "boolean" == typeof e3.comma ? e3.comma : ai.comma, decoder: "function" == typeof e3.decoder ? e3.decoder : ai.decoder, delimiter: "string" == typeof e3.delimiter || oi.isRegExp(e3.delimiter) ? e3.delimiter : ai.delimiter, depth: "number" == typeof e3.depth || false === e3.depth ? +e3.depth : ai.depth, ignoreQueryPrefix: true === e3.ignoreQueryPrefix, interpretNumericEntities: "boolean" == typeof e3.interpretNumericEntities ? e3.interpretNumericEntities : ai.interpretNumericEntities, parameterLimit: "number" == typeof e3.parameterLimit ? e3.parameterLimit : ai.parameterLimit, parseArrays: false !== e3.parseArrays, plainObjects: "boolean" == typeof e3.plainObjects ? e3.plainObjects : ai.plainObjects, strictNullHandling: "boolean" == typeof e3.strictNullHandling ? e3.strictNullHandling : ai.strictNullHandling };
        }(t2);
        if ("" === e2 || null == e2) return n2.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        for (var r2 = "string" == typeof e2 ? function(e3, t3) {
          var n3, r3 = { __proto__: null }, o3 = t3.ignoreQueryPrefix ? e3.replace(/^\?/, "") : e3, i3 = t3.parameterLimit === 1 / 0 ? void 0 : t3.parameterLimit, s3 = o3.split(t3.delimiter, i3), a3 = -1, u3 = t3.charset;
          if (t3.charsetSentinel) for (n3 = 0; n3 < s3.length; ++n3) 0 === s3[n3].indexOf("utf8=") && ("utf8=%E2%9C%93" === s3[n3] ? u3 = "utf-8" : "utf8=%26%2310003%3B" === s3[n3] && (u3 = "iso-8859-1"), a3 = n3, n3 = s3.length);
          for (n3 = 0; n3 < s3.length; ++n3) if (n3 !== a3) {
            var c2, l2, p2 = s3[n3], h2 = p2.indexOf("]="), f2 = -1 === h2 ? p2.indexOf("=") : h2 + 1;
            -1 === f2 ? (c2 = t3.decoder(p2, ai.decoder, u3, "key"), l2 = t3.strictNullHandling ? null : "") : (c2 = t3.decoder(p2.slice(0, f2), ai.decoder, u3, "key"), l2 = oi.maybeMap(ci(p2.slice(f2 + 1), t3), function(e4) {
              return t3.decoder(e4, ai.decoder, u3, "value");
            })), l2 && t3.interpretNumericEntities && "iso-8859-1" === u3 && (l2 = ui(l2)), p2.indexOf("[]=") > -1 && (l2 = si(l2) ? [l2] : l2), ii.call(r3, c2) ? r3[c2] = oi.combine(r3[c2], l2) : r3[c2] = l2;
          }
          return r3;
        }(e2, n2) : e2, o2 = n2.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, i2 = Object.keys(r2), s2 = 0; s2 < i2.length; ++s2) {
          var a2 = i2[s2], u2 = li(a2, r2[a2], n2, "string" == typeof e2);
          o2 = oi.merge(o2, u2, n2);
        }
        return true === n2.allowSparse ? o2 : oi.compact(o2);
      }, stringify: pi }, fi = {};
      !function(e2) {
        function t2(e3, t3) {
          var r2 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
          if (!r2) {
            if (Array.isArray(e3) || (r2 = function(e4, t4) {
              if (!e4) return;
              if ("string" == typeof e4) return n2(e4, t4);
              var r3 = Object.prototype.toString.call(e4).slice(8, -1);
              "Object" === r3 && e4.constructor && (r3 = e4.constructor.name);
              if ("Map" === r3 || "Set" === r3) return Array.from(e4);
              if ("Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3)) return n2(e4, t4);
            }(e3)) || t3 && e3 && "number" == typeof e3.length) {
              r2 && (e3 = r2);
              var o2 = 0, i2 = function() {
              };
              return { s: i2, n: function() {
                return o2 >= e3.length ? { done: true } : { done: false, value: e3[o2++] };
              }, e: function(e4) {
                throw e4;
              }, f: i2 };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var s2, a2 = true, u2 = false;
          return { s: function() {
            r2 = r2.call(e3);
          }, n: function() {
            var e4 = r2.next();
            return a2 = e4.done, e4;
          }, e: function(e4) {
            u2 = true, s2 = e4;
          }, f: function() {
            try {
              a2 || null == r2.return || r2.return();
            } finally {
              if (u2) throw s2;
            }
          } };
        }
        function n2(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var n3 = 0, r2 = new Array(t3); n3 < t3; n3++) r2[n3] = e3[n3];
          return r2;
        }
        e2.type = (e3) => e3.split(/ *; */).shift(), e2.params = (e3) => {
          const n3 = {};
          var r2, o2 = t2(e3.split(/ *; */));
          try {
            for (o2.s(); !(r2 = o2.n()).done; ) {
              const e4 = r2.value.split(/ *= */), t3 = e4.shift(), o3 = e4.shift();
              t3 && o3 && (n3[t3] = o3);
            }
          } catch (e4) {
            o2.e(e4);
          } finally {
            o2.f();
          }
          return n3;
        }, e2.parseLinks = (e3) => {
          const n3 = {};
          var r2, o2 = t2(e3.split(/ *, */));
          try {
            for (o2.s(); !(r2 = o2.n()).done; ) {
              const e4 = r2.value.split(/ *; */), t3 = e4[0].slice(1, -1);
              n3[e4[1].split(/ *= */)[1].slice(1, -1)] = t3;
            }
          } catch (e4) {
            o2.e(e4);
          } finally {
            o2.f();
          }
          return n3;
        }, e2.cleanHeader = (e3, t3) => (delete e3["content-type"], delete e3["content-length"], delete e3["transfer-encoding"], delete e3.host, t3 && (delete e3.authorization, delete e3.cookie), e3), e2.isObject = (e3) => null !== e3 && "object" == typeof e3, e2.hasOwn = Object.hasOwn || function(e3, t3) {
          if (null == e3) throw new TypeError("Cannot convert undefined or null to object");
          return Object.prototype.hasOwnProperty.call(new Object(e3), t3);
        }, e2.mixin = (t3, n3) => {
          for (const r2 in n3) e2.hasOwn(n3, r2) && (t3[r2] = n3[r2]);
        };
      }(fi);
      const di = Or, yi = fi.isObject, gi = fi.hasOwn;
      var mi = bi;
      function bi() {
      }
      bi.prototype.clearTimeout = function() {
        return clearTimeout(this._timer), clearTimeout(this._responseTimeoutTimer), clearTimeout(this._uploadTimeoutTimer), delete this._timer, delete this._responseTimeoutTimer, delete this._uploadTimeoutTimer, this;
      }, bi.prototype.parse = function(e2) {
        return this._parser = e2, this;
      }, bi.prototype.responseType = function(e2) {
        return this._responseType = e2, this;
      }, bi.prototype.serialize = function(e2) {
        return this._serializer = e2, this;
      }, bi.prototype.timeout = function(e2) {
        if (!e2 || "object" != typeof e2) return this._timeout = e2, this._responseTimeout = 0, this._uploadTimeout = 0, this;
        for (const t2 in e2) if (gi(e2, t2)) switch (t2) {
          case "deadline":
            this._timeout = e2.deadline;
            break;
          case "response":
            this._responseTimeout = e2.response;
            break;
          case "upload":
            this._uploadTimeout = e2.upload;
            break;
          default:
            console.warn("Unknown timeout option", t2);
        }
        return this;
      }, bi.prototype.retry = function(e2, t2) {
        return 0 !== arguments.length && true !== e2 || (e2 = 1), e2 <= 0 && (e2 = 0), this._maxRetries = e2, this._retries = 0, this._retryCallback = t2, this;
      };
      const vi = /* @__PURE__ */ new Set(["ETIMEDOUT", "ECONNRESET", "EADDRINUSE", "ECONNREFUSED", "EPIPE", "ENOTFOUND", "ENETUNREACH", "EAI_AGAIN"]), _i = /* @__PURE__ */ new Set([408, 413, 429, 500, 502, 503, 504, 521, 522, 524]);
      bi.prototype._shouldRetry = function(e2, t2) {
        if (!this._maxRetries || this._retries++ >= this._maxRetries) return false;
        if (this._retryCallback) try {
          const n2 = this._retryCallback(e2, t2);
          if (true === n2) return true;
          if (false === n2) return false;
        } catch (e3) {
          console.error(e3);
        }
        if (t2 && t2.status && _i.has(t2.status)) return true;
        if (e2) {
          if (e2.code && vi.has(e2.code)) return true;
          if (e2.timeout && "ECONNABORTED" === e2.code) return true;
          if (e2.crossDomain) return true;
        }
        return false;
      }, bi.prototype._retry = function() {
        return this.clearTimeout(), this.req && (this.req = null, this.req = this.request()), this._aborted = false, this.timedout = false, this.timedoutError = null, this._end();
      }, bi.prototype.then = function(e2, t2) {
        if (!this._fullfilledPromise) {
          const e3 = this;
          this._endCalled && console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises"), this._fullfilledPromise = new Promise((t3, n2) => {
            e3.on("abort", () => {
              if (this._maxRetries && this._maxRetries > this._retries) return;
              if (this.timedout && this.timedoutError) return void n2(this.timedoutError);
              const e4 = new Error("Aborted");
              e4.code = "ABORTED", e4.status = this.status, e4.method = this.method, e4.url = this.url, n2(e4);
            }), e3.end((e4, r2) => {
              e4 ? n2(e4) : t3(r2);
            });
          });
        }
        return this._fullfilledPromise.then(e2, t2);
      }, bi.prototype.catch = function(e2) {
        return this.then(void 0, e2);
      }, bi.prototype.use = function(e2) {
        return e2(this), this;
      }, bi.prototype.ok = function(e2) {
        if ("function" != typeof e2) throw new Error("Callback required");
        return this._okCallback = e2, this;
      }, bi.prototype._isResponseOK = function(e2) {
        return !!e2 && (this._okCallback ? this._okCallback(e2) : e2.status >= 200 && e2.status < 300);
      }, bi.prototype.get = function(e2) {
        return this._header[e2.toLowerCase()];
      }, bi.prototype.getHeader = bi.prototype.get, bi.prototype.set = function(e2, t2) {
        if (yi(e2)) {
          for (const t3 in e2) gi(e2, t3) && this.set(t3, e2[t3]);
          return this;
        }
        return this._header[e2.toLowerCase()] = t2, this.header[e2] = t2, this;
      }, bi.prototype.unset = function(e2) {
        return delete this._header[e2.toLowerCase()], delete this.header[e2], this;
      }, bi.prototype.field = function(e2, t2, n2) {
        if (null == e2) throw new Error(".field(name, val) name can not be empty");
        if (this._data) throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
        if (yi(e2)) {
          for (const t3 in e2) gi(e2, t3) && this.field(t3, e2[t3]);
          return this;
        }
        if (Array.isArray(t2)) {
          for (const n3 in t2) gi(t2, n3) && this.field(e2, t2[n3]);
          return this;
        }
        if (null == t2) throw new Error(".field(name, val) val can not be empty");
        return "boolean" == typeof t2 && (t2 = String(t2)), n2 ? this._getFormData().append(e2, t2, n2) : this._getFormData().append(e2, t2), this;
      }, bi.prototype.abort = function() {
        if (this._aborted) return this;
        if (this._aborted = true, this.xhr && this.xhr.abort(), this.req) {
          if (di.gte(process.version, "v13.0.0") && di.lt(process.version, "v14.0.0")) throw new Error("Superagent does not work in v13 properly with abort() due to Node.js core changes");
          this.req.abort();
        }
        return this.clearTimeout(), this.emit("abort"), this;
      }, bi.prototype._auth = function(e2, t2, n2, r2) {
        switch (n2.type) {
          case "basic":
            this.set("Authorization", `Basic ${r2(`${e2}:${t2}`)}`);
            break;
          case "auto":
            this.username = e2, this.password = t2;
            break;
          case "bearer":
            this.set("Authorization", `Bearer ${e2}`);
        }
        return this;
      }, bi.prototype.withCredentials = function(e2) {
        return void 0 === e2 && (e2 = true), this._withCredentials = e2, this;
      }, bi.prototype.redirects = function(e2) {
        return this._maxRedirects = e2, this;
      }, bi.prototype.maxResponseSize = function(e2) {
        if ("number" != typeof e2) throw new TypeError("Invalid argument");
        return this._maxResponseSize = e2, this;
      }, bi.prototype.toJSON = function() {
        return { method: this.method, url: this.url, data: this._data, headers: this._header };
      }, bi.prototype.send = function(e2) {
        const t2 = yi(e2);
        let n2 = this._header["content-type"];
        if (this._formData) throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
        if (t2 && !this._data) Array.isArray(e2) ? this._data = [] : this._isHost(e2) || (this._data = {});
        else if (e2 && this._data && this._isHost(this._data)) throw new Error("Can't merge these send calls");
        if (t2 && yi(this._data)) for (const t3 in e2) {
          if ("bigint" == typeof e2[t3] && !e2[t3].toJSON) throw new Error("Cannot serialize BigInt value to json");
          gi(e2, t3) && (this._data[t3] = e2[t3]);
        }
        else {
          if ("bigint" == typeof e2) throw new Error("Cannot send value of type BigInt");
          "string" == typeof e2 ? (n2 || this.type("form"), n2 = this._header["content-type"], n2 && (n2 = n2.toLowerCase().trim()), this._data = "application/x-www-form-urlencoded" === n2 ? this._data ? `${this._data}&${e2}` : e2 : (this._data || "") + e2) : this._data = e2;
        }
        return !t2 || this._isHost(e2) || n2 || this.type("json"), this;
      }, bi.prototype.sortQuery = function(e2) {
        return this._sort = void 0 === e2 || e2, this;
      }, bi.prototype._finalizeQueryString = function() {
        const e2 = this._query.join("&");
        if (e2 && (this.url += (this.url.includes("?") ? "&" : "?") + e2), this._query.length = 0, this._sort) {
          const e3 = this.url.indexOf("?");
          if (e3 >= 0) {
            const t2 = this.url.slice(e3 + 1).split("&");
            "function" == typeof this._sort ? t2.sort(this._sort) : t2.sort(), this.url = this.url.slice(0, e3) + "?" + t2.join("&");
          }
        }
      }, bi.prototype._appendQueryString = () => {
        console.warn("Unsupported");
      }, bi.prototype._timeoutError = function(e2, t2, n2) {
        if (this._aborted) return;
        const r2 = new Error(`${e2 + t2}ms exceeded`);
        r2.timeout = t2, r2.code = "ECONNABORTED", r2.errno = n2, this.timedout = true, this.timedoutError = r2, this.abort(), this.callback(r2);
      }, bi.prototype._setTimeouts = function() {
        const e2 = this;
        this._timeout && !this._timer && (this._timer = setTimeout(() => {
          e2._timeoutError("Timeout of ", e2._timeout, "ETIME");
        }, this._timeout)), this._responseTimeout && !this._responseTimeoutTimer && (this._responseTimeoutTimer = setTimeout(() => {
          e2._timeoutError("Response timeout of ", e2._responseTimeout, "ETIMEDOUT");
        }, this._responseTimeout));
      };
      const Si = fi;
      var wi = Oi;
      function Oi() {
      }
      function Pi(e2, t2) {
        var n2 = "undefined" != typeof Symbol && e2[Symbol.iterator] || e2["@@iterator"];
        if (!n2) {
          if (Array.isArray(e2) || (n2 = function(e3, t3) {
            if (!e3) return;
            if ("string" == typeof e3) return Ei(e3, t3);
            var n3 = Object.prototype.toString.call(e3).slice(8, -1);
            "Object" === n3 && e3.constructor && (n3 = e3.constructor.name);
            if ("Map" === n3 || "Set" === n3) return Array.from(e3);
            if ("Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3)) return Ei(e3, t3);
          }(e2)) || t2 && e2 && "number" == typeof e2.length) {
            n2 && (e2 = n2);
            var r2 = 0, o2 = function() {
            };
            return { s: o2, n: function() {
              return r2 >= e2.length ? { done: true } : { done: false, value: e2[r2++] };
            }, e: function(e3) {
              throw e3;
            }, f: o2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var i2, s2 = true, a2 = false;
        return { s: function() {
          n2 = n2.call(e2);
        }, n: function() {
          var e3 = n2.next();
          return s2 = e3.done, e3;
        }, e: function(e3) {
          a2 = true, i2 = e3;
        }, f: function() {
          try {
            s2 || null == n2.return || n2.return();
          } finally {
            if (a2) throw i2;
          }
        } };
      }
      function Ei(e2, t2) {
        (null == t2 || t2 > e2.length) && (t2 = e2.length);
        for (var n2 = 0, r2 = new Array(t2); n2 < t2; n2++) r2[n2] = e2[n2];
        return r2;
      }
      function Ai() {
        this._defaults = [];
      }
      Oi.prototype.get = function(e2) {
        return this.header[e2.toLowerCase()];
      }, Oi.prototype._setHeaderProperties = function(e2) {
        const t2 = e2["content-type"] || "";
        this.type = Si.type(t2);
        const n2 = Si.params(t2);
        for (const e3 in n2) Object.prototype.hasOwnProperty.call(n2, e3) && (this[e3] = n2[e3]);
        this.links = {};
        try {
          e2.link && (this.links = Si.parseLinks(e2.link));
        } catch (e3) {
        }
      }, Oi.prototype._setStatusProperties = function(e2) {
        const t2 = Math.trunc(e2 / 100);
        this.statusCode = e2, this.status = this.statusCode, this.statusType = t2, this.info = 1 === t2, this.ok = 2 === t2, this.redirect = 3 === t2, this.clientError = 4 === t2, this.serverError = 5 === t2, this.error = (4 === t2 || 5 === t2) && this.toError(), this.created = 201 === e2, this.accepted = 202 === e2, this.noContent = 204 === e2, this.badRequest = 400 === e2, this.unauthorized = 401 === e2, this.notAcceptable = 406 === e2, this.forbidden = 403 === e2, this.notFound = 404 === e2, this.unprocessableEntity = 422 === e2;
      };
      for (var Ti = 0, Ni = ["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert", "disableTLSCerts"]; Ti < Ni.length; Ti++) {
        const e2 = Ni[Ti];
        Ai.prototype[e2] = function() {
          for (var t2 = arguments.length, n2 = new Array(t2), r2 = 0; r2 < t2; r2++) n2[r2] = arguments[r2];
          return this._defaults.push({ fn: e2, args: n2 }), this;
        };
      }
      Ai.prototype._setDefaults = function(e2) {
        var t2, n2 = Pi(this._defaults);
        try {
          for (n2.s(); !(t2 = n2.n()).done; ) {
            const n3 = t2.value;
            e2[n3.fn](...n3.args);
          }
        } catch (e3) {
          n2.e(e3);
        } finally {
          n2.f();
        }
      };
      var Ci = Ai;
      !function(e2, t2) {
        function n2(e3, t3) {
          var n3 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
          if (!n3) {
            if (Array.isArray(e3) || (n3 = function(e4, t4) {
              if (!e4) return;
              if ("string" == typeof e4) return r2(e4, t4);
              var n4 = Object.prototype.toString.call(e4).slice(8, -1);
              "Object" === n4 && e4.constructor && (n4 = e4.constructor.name);
              if ("Map" === n4 || "Set" === n4) return Array.from(e4);
              if ("Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4)) return r2(e4, t4);
            }(e3)) || t3 && e3 && "number" == typeof e3.length) {
              n3 && (e3 = n3);
              var o3 = 0, i3 = function() {
              };
              return { s: i3, n: function() {
                return o3 >= e3.length ? { done: true } : { done: false, value: e3[o3++] };
              }, e: function(e4) {
                throw e4;
              }, f: i3 };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var s3, a3 = true, u3 = false;
          return { s: function() {
            n3 = n3.call(e3);
          }, n: function() {
            var e4 = n3.next();
            return a3 = e4.done, e4;
          }, e: function(e4) {
            u3 = true, s3 = e4;
          }, f: function() {
            try {
              a3 || null == n3.return || n3.return();
            } finally {
              if (u3) throw s3;
            }
          } };
        }
        function r2(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var n3 = 0, r3 = new Array(t3); n3 < t3; n3++) r3[n3] = e3[n3];
          return r3;
        }
        let o2;
        "undefined" != typeof window ? o2 = window : "undefined" == typeof self ? (console.warn("Using browser-only version of superagent in non-browser environment"), o2 = void 0) : o2 = self;
        const i2 = Pn.exports, s2 = En, a2 = hi, u2 = mi, c2 = fi.isObject, l2 = fi.mixin, p2 = fi.hasOwn, h2 = wi, f2 = Ci;
        function d2() {
        }
        e2.exports = function(e3, n3) {
          return "function" == typeof n3 ? new t2.Request("GET", e3).end(n3) : 1 === arguments.length ? new t2.Request("GET", e3) : new t2.Request(e3, n3);
        };
        const y2 = t2 = e2.exports;
        t2.Request = w2, y2.getXHR = () => {
          if (o2.XMLHttpRequest) return new o2.XMLHttpRequest();
          throw new Error("Browser-only version of superagent could not find XHR");
        };
        const g2 = "".trim ? (e3) => e3.trim() : (e3) => e3.replace(/(^\s*|\s*$)/g, "");
        function m2(e3) {
          if (!c2(e3)) return e3;
          const t3 = [];
          for (const n3 in e3) p2(e3, n3) && b2(t3, n3, e3[n3]);
          return t3.join("&");
        }
        function b2(e3, t3, r3) {
          if (void 0 !== r3) if (null !== r3) if (Array.isArray(r3)) {
            var o3, i3 = n2(r3);
            try {
              for (i3.s(); !(o3 = i3.n()).done; ) {
                b2(e3, t3, o3.value);
              }
            } catch (e4) {
              i3.e(e4);
            } finally {
              i3.f();
            }
          } else if (c2(r3)) for (const n3 in r3) p2(r3, n3) && b2(e3, `${t3}[${n3}]`, r3[n3]);
          else e3.push(encodeURI(t3) + "=" + encodeURIComponent(r3));
          else e3.push(encodeURI(t3));
        }
        function v2(e3) {
          const t3 = {}, n3 = e3.split("&");
          let r3, o3;
          for (let e4 = 0, i3 = n3.length; e4 < i3; ++e4) r3 = n3[e4], o3 = r3.indexOf("="), -1 === o3 ? t3[decodeURIComponent(r3)] = "" : t3[decodeURIComponent(r3.slice(0, o3))] = decodeURIComponent(r3.slice(o3 + 1));
          return t3;
        }
        function _2(e3) {
          return /[/+]json($|[^-\w])/i.test(e3);
        }
        function S2(e3) {
          this.req = e3, this.xhr = this.req.xhr, this.text = "HEAD" !== this.req.method && ("" === this.xhr.responseType || "text" === this.xhr.responseType) || void 0 === this.xhr.responseType ? this.xhr.responseText : null, this.statusText = this.req.xhr.statusText;
          let t3 = this.xhr.status;
          1223 === t3 && (t3 = 204), this._setStatusProperties(t3), this.headers = function(e4) {
            const t4 = e4.split(/\r?\n/), n3 = {};
            let r3, o3, i3, s3;
            for (let e5 = 0, a3 = t4.length; e5 < a3; ++e5) o3 = t4[e5], r3 = o3.indexOf(":"), -1 !== r3 && (i3 = o3.slice(0, r3).toLowerCase(), s3 = g2(o3.slice(r3 + 1)), n3[i3] = s3);
            return n3;
          }(this.xhr.getAllResponseHeaders()), this.header = this.headers, this.header["content-type"] = this.xhr.getResponseHeader("content-type"), this._setHeaderProperties(this.header), null === this.text && e3._responseType ? this.body = this.xhr.response : this.body = "HEAD" === this.req.method ? null : this._parseBody(this.text ? this.text : this.xhr.response);
        }
        function w2(e3, t3) {
          const n3 = this;
          this._query = this._query || [], this.method = e3, this.url = t3, this.header = {}, this._header = {}, this.on("end", () => {
            let e4, t4 = null, r3 = null;
            try {
              r3 = new S2(n3);
            } catch (e5) {
              return t4 = new Error("Parser is unable to parse the response"), t4.parse = true, t4.original = e5, n3.xhr ? (t4.rawResponse = void 0 === n3.xhr.responseType ? n3.xhr.responseText : n3.xhr.response, t4.status = n3.xhr.status ? n3.xhr.status : null, t4.statusCode = t4.status) : (t4.rawResponse = null, t4.status = null), n3.callback(t4);
            }
            n3.emit("response", r3);
            try {
              n3._isResponseOK(r3) || (e4 = new Error(r3.statusText || r3.text || "Unsuccessful HTTP response"));
            } catch (t5) {
              e4 = t5;
            }
            e4 ? (e4.original = t4, e4.response = r3, e4.status = e4.status || r3.status, n3.callback(e4, r3)) : n3.callback(null, r3);
          });
        }
        y2.serializeObject = m2, y2.parseString = v2, y2.types = { html: "text/html", json: "application/json", xml: "text/xml", urlencoded: "application/x-www-form-urlencoded", form: "application/x-www-form-urlencoded", "form-data": "application/x-www-form-urlencoded" }, y2.serialize = { "application/x-www-form-urlencoded": a2.stringify, "application/json": s2 }, y2.parse = { "application/x-www-form-urlencoded": v2, "application/json": JSON.parse }, l2(S2.prototype, h2.prototype), S2.prototype._parseBody = function(e3) {
          let t3 = y2.parse[this.type];
          return this.req._parser ? this.req._parser(this, e3) : (!t3 && _2(this.type) && (t3 = y2.parse["application/json"]), t3 && e3 && (e3.length > 0 || e3 instanceof Object) ? t3(e3) : null);
        }, S2.prototype.toError = function() {
          const e3 = this.req, t3 = e3.method, n3 = e3.url, r3 = `cannot ${t3} ${n3} (${this.status})`, o3 = new Error(r3);
          return o3.status = this.status, o3.method = t3, o3.url = n3, o3;
        }, y2.Response = S2, i2(w2.prototype), l2(w2.prototype, u2.prototype), w2.prototype.type = function(e3) {
          return this.set("Content-Type", y2.types[e3] || e3), this;
        }, w2.prototype.accept = function(e3) {
          return this.set("Accept", y2.types[e3] || e3), this;
        }, w2.prototype.auth = function(e3, t3, n3) {
          1 === arguments.length && (t3 = ""), "object" == typeof t3 && null !== t3 && (n3 = t3, t3 = ""), n3 || (n3 = { type: "function" == typeof btoa ? "basic" : "auto" });
          const r3 = n3.encoder ? n3.encoder : (e4) => {
            if ("function" == typeof btoa) return btoa(e4);
            throw new Error("Cannot use basic auth, btoa is not a function");
          };
          return this._auth(e3, t3, n3, r3);
        }, w2.prototype.query = function(e3) {
          return "string" != typeof e3 && (e3 = m2(e3)), e3 && this._query.push(e3), this;
        }, w2.prototype.attach = function(e3, t3, n3) {
          if (t3) {
            if (this._data) throw new Error("superagent can't mix .send() and .attach()");
            this._getFormData().append(e3, t3, n3 || t3.name);
          }
          return this;
        }, w2.prototype._getFormData = function() {
          return this._formData || (this._formData = new o2.FormData()), this._formData;
        }, w2.prototype.callback = function(e3, t3) {
          if (this._shouldRetry(e3, t3)) return this._retry();
          const n3 = this._callback;
          this.clearTimeout(), e3 && (this._maxRetries && (e3.retries = this._retries - 1), this.emit("error", e3)), n3(e3, t3);
        }, w2.prototype.crossDomainError = function() {
          const e3 = new Error("Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.");
          e3.crossDomain = true, e3.status = this.status, e3.method = this.method, e3.url = this.url, this.callback(e3);
        }, w2.prototype.agent = function() {
          return console.warn("This is not supported in browser version of superagent"), this;
        }, w2.prototype.ca = w2.prototype.agent, w2.prototype.buffer = w2.prototype.ca, w2.prototype.write = () => {
          throw new Error("Streaming is not supported in browser version of superagent");
        }, w2.prototype.pipe = w2.prototype.write, w2.prototype._isHost = function(e3) {
          return e3 && "object" == typeof e3 && !Array.isArray(e3) && "[object Object]" !== Object.prototype.toString.call(e3);
        }, w2.prototype.end = function(e3) {
          this._endCalled && console.warn("Warning: .end() was called twice. This is not supported in superagent"), this._endCalled = true, this._callback = e3 || d2, this._finalizeQueryString(), this._end();
        }, w2.prototype._setUploadTimeout = function() {
          const e3 = this;
          this._uploadTimeout && !this._uploadTimeoutTimer && (this._uploadTimeoutTimer = setTimeout(() => {
            e3._timeoutError("Upload timeout of ", e3._uploadTimeout, "ETIMEDOUT");
          }, this._uploadTimeout));
        }, w2.prototype._end = function() {
          if (this._aborted) return this.callback(new Error("The request has been aborted even before .end() was called"));
          const e3 = this;
          this.xhr = y2.getXHR();
          const t3 = this.xhr;
          let n3 = this._formData || this._data;
          this._setTimeouts(), t3.addEventListener("readystatechange", () => {
            const n4 = t3.readyState;
            if (n4 >= 2 && e3._responseTimeoutTimer && clearTimeout(e3._responseTimeoutTimer), 4 !== n4) return;
            let r4;
            try {
              r4 = t3.status;
            } catch (e4) {
              r4 = 0;
            }
            if (!r4) {
              if (e3.timedout || e3._aborted) return;
              return e3.crossDomainError();
            }
            e3.emit("end");
          });
          const r3 = (t4, n4) => {
            n4.total > 0 && (n4.percent = n4.loaded / n4.total * 100, 100 === n4.percent && clearTimeout(e3._uploadTimeoutTimer)), n4.direction = t4, e3.emit("progress", n4);
          };
          if (this.hasListeners("progress")) try {
            t3.addEventListener("progress", r3.bind(null, "download")), t3.upload && t3.upload.addEventListener("progress", r3.bind(null, "upload"));
          } catch (e4) {
          }
          t3.upload && this._setUploadTimeout();
          try {
            this.username && this.password ? t3.open(this.method, this.url, true, this.username, this.password) : t3.open(this.method, this.url, true);
          } catch (e4) {
            return this.callback(e4);
          }
          if (this._withCredentials && (t3.withCredentials = true), !this._formData && "GET" !== this.method && "HEAD" !== this.method && "string" != typeof n3 && !this._isHost(n3)) {
            const e4 = this._header["content-type"];
            let t4 = this._serializer || y2.serialize[e4 ? e4.split(";")[0] : ""];
            !t4 && _2(e4) && (t4 = y2.serialize["application/json"]), t4 && (n3 = t4(n3));
          }
          for (const e4 in this.header) null !== this.header[e4] && p2(this.header, e4) && t3.setRequestHeader(e4, this.header[e4]);
          this._responseType && (t3.responseType = this._responseType), this.emit("request", this), t3.send(void 0 === n3 ? null : n3);
        }, y2.agent = () => new f2();
        for (var O2 = 0, P2 = ["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"]; O2 < P2.length; O2++) {
          const e3 = P2[O2];
          f2.prototype[e3.toLowerCase()] = function(t3, n3) {
            const r3 = new y2.Request(e3, t3);
            return this._setDefaults(r3), n3 && r3.end(n3), r3;
          };
        }
        function E2(e3, t3, n3) {
          const r3 = y2("DELETE", e3);
          return "function" == typeof t3 && (n3 = t3, t3 = null), t3 && r3.send(t3), n3 && r3.end(n3), r3;
        }
        f2.prototype.del = f2.prototype.delete, y2.get = (e3, t3, n3) => {
          const r3 = y2("GET", e3);
          return "function" == typeof t3 && (n3 = t3, t3 = null), t3 && r3.query(t3), n3 && r3.end(n3), r3;
        }, y2.head = (e3, t3, n3) => {
          const r3 = y2("HEAD", e3);
          return "function" == typeof t3 && (n3 = t3, t3 = null), t3 && r3.query(t3), n3 && r3.end(n3), r3;
        }, y2.options = (e3, t3, n3) => {
          const r3 = y2("OPTIONS", e3);
          return "function" == typeof t3 && (n3 = t3, t3 = null), t3 && r3.send(t3), n3 && r3.end(n3), r3;
        }, y2.del = E2, y2.delete = E2, y2.patch = (e3, t3, n3) => {
          const r3 = y2("PATCH", e3);
          return "function" == typeof t3 && (n3 = t3, t3 = null), t3 && r3.send(t3), n3 && r3.end(n3), r3;
        }, y2.post = (e3, t3, n3) => {
          const r3 = y2("POST", e3);
          return "function" == typeof t3 && (n3 = t3, t3 = null), t3 && r3.send(t3), n3 && r3.end(n3), r3;
        }, y2.put = (e3, t3, n3) => {
          const r3 = y2("PUT", e3);
          return "function" == typeof t3 && (n3 = t3, t3 = null), t3 && r3.send(t3), n3 && r3.end(n3), r3;
        };
      }(On, On.exports);
      var ki = On.exports;
      function Mi(e2) {
        var t2 = (/* @__PURE__ */ new Date()).getTime(), n2 = (/* @__PURE__ */ new Date()).toISOString(), r2 = console && console.log ? console : window && window.console && window.console.log ? window.console : console;
        r2.log("<<<<<"), r2.log("[".concat(n2, "]"), "\n", e2.url, "\n", e2.qs), r2.log("-----"), e2.on("response", function(n3) {
          var o2 = (/* @__PURE__ */ new Date()).getTime() - t2, i2 = (/* @__PURE__ */ new Date()).toISOString();
          r2.log(">>>>>>"), r2.log("[".concat(i2, " / ").concat(o2, "]"), "\n", e2.url, "\n", e2.qs, "\n", n3.text), r2.log("-----");
        });
      }
      function ji(e2, t2, n2) {
        var r2 = this;
        this._config.logVerbosity && (e2 = e2.use(Mi)), this._config.proxy && this._modules.proxy && (e2 = this._modules.proxy.call(this, e2)), this._config.keepAlive && this._modules.keepAlive && (e2 = this._modules.keepAlive(e2));
        var o2 = e2;
        if (t2.abortSignal) var i2 = t2.abortSignal.subscribe(function() {
          o2.abort(), i2();
        });
        return true === t2.forceBuffered ? o2 = "undefined" == typeof Blob ? o2.buffer().responseType("arraybuffer") : o2.responseType("arraybuffer") : false === t2.forceBuffered && (o2 = o2.buffer(false)), (o2 = o2.timeout(t2.timeout)).on("abort", function() {
          return n2({ category: k.PNUnknownCategory, error: true, operation: t2.operation, errorData: new Error("Aborted") }, null);
        }), o2.end(function(e3, o3) {
          var i3, s2 = {};
          if (s2.error = null !== e3, s2.operation = t2.operation, o3 && o3.status && (s2.statusCode = o3.status), e3) {
            if (e3.response && e3.response.text && !r2._config.logVerbosity) try {
              s2.errorData = JSON.parse(e3.response.text);
            } catch (t3) {
              s2.errorData = e3;
            }
            else s2.errorData = e3;
            return s2.category = r2._detectErrorCategory(e3), n2(s2, null);
          }
          if (t2.ignoreBody) i3 = { headers: o3.headers, redirects: o3.redirects, response: o3 };
          else try {
            i3 = JSON.parse(o3.text);
          } catch (e4) {
            return s2.errorData = o3, s2.error = true, n2(s2, null);
          }
          return i3.error && 1 === i3.error && i3.status && i3.message && i3.service ? (s2.errorData = i3, s2.statusCode = i3.status, s2.error = true, s2.category = r2._detectErrorCategory(s2), n2(s2, null)) : (i3.error && i3.error.message && (s2.errorData = i3.error), n2(s2, i3));
        }), o2;
      }
      function Ri(e2, t2, n2) {
        return o(this, void 0, void 0, function() {
          var r2;
          return i(this, function(o2) {
            switch (o2.label) {
              case 0:
                return r2 = ki.post(e2), t2.forEach(function(e3) {
                  var t3 = e3.key, n3 = e3.value;
                  r2 = r2.field(t3, n3);
                }), r2.attach("file", n2, { contentType: "application/octet-stream" }), [4, r2];
              case 1:
                return [2, o2.sent()];
            }
          });
        });
      }
      function xi(e2, t2, n2) {
        var r2 = ki.get(this.getStandardOrigin() + t2.url).set(t2.headers).query(e2);
        return ji.call(this, r2, t2, n2);
      }
      function Ui(e2, t2, n2) {
        var r2 = ki.get(this.getStandardOrigin() + t2.url).set(t2.headers).query(e2);
        return ji.call(this, r2, t2, n2);
      }
      function Ii(e2, t2, n2, r2) {
        var o2 = ki.post(this.getStandardOrigin() + n2.url).query(e2).set(n2.headers).send(t2);
        return ji.call(this, o2, n2, r2);
      }
      function Di(e2, t2, n2, r2) {
        var o2 = ki.patch(this.getStandardOrigin() + n2.url).query(e2).set(n2.headers).send(t2);
        return ji.call(this, o2, n2, r2);
      }
      function Fi(e2, t2, n2) {
        var r2 = ki.delete(this.getStandardOrigin() + t2.url).set(t2.headers).query(e2);
        return ji.call(this, r2, t2, n2);
      }
      function Li(e2, t2) {
        var n2 = new Uint8Array(e2.byteLength + t2.byteLength);
        return n2.set(new Uint8Array(e2), 0), n2.set(new Uint8Array(t2), e2.byteLength), n2.buffer;
      }
      var Gi, Ki = function() {
        function e2() {
        }
        return Object.defineProperty(e2.prototype, "algo", { get: function() {
          return "aes-256-cbc";
        }, enumerable: false, configurable: true }), e2.prototype.encrypt = function(e3, t2) {
          return o(this, void 0, void 0, function() {
            var n2;
            return i(this, function(r2) {
              switch (r2.label) {
                case 0:
                  return [4, this.getKey(e3)];
                case 1:
                  if (n2 = r2.sent(), t2 instanceof ArrayBuffer) return [2, this.encryptArrayBuffer(n2, t2)];
                  if ("string" == typeof t2) return [2, this.encryptString(n2, t2)];
                  throw new Error("Cannot encrypt this file. In browsers file encryption supports only string or ArrayBuffer");
              }
            });
          });
        }, e2.prototype.decrypt = function(e3, t2) {
          return o(this, void 0, void 0, function() {
            var n2;
            return i(this, function(r2) {
              switch (r2.label) {
                case 0:
                  return [4, this.getKey(e3)];
                case 1:
                  if (n2 = r2.sent(), t2 instanceof ArrayBuffer) return [2, this.decryptArrayBuffer(n2, t2)];
                  if ("string" == typeof t2) return [2, this.decryptString(n2, t2)];
                  throw new Error("Cannot decrypt this file. In browsers file decryption supports only string or ArrayBuffer");
              }
            });
          });
        }, e2.prototype.encryptFile = function(e3, t2, n2) {
          return o(this, void 0, void 0, function() {
            var r2, o2, s2;
            return i(this, function(i2) {
              switch (i2.label) {
                case 0:
                  if (t2.data.byteLength <= 0) throw new Error("encryption error. empty content");
                  return [4, this.getKey(e3)];
                case 1:
                  return r2 = i2.sent(), [4, t2.data.arrayBuffer()];
                case 2:
                  return o2 = i2.sent(), [4, this.encryptArrayBuffer(r2, o2)];
                case 3:
                  return s2 = i2.sent(), [2, n2.create({ name: t2.name, mimeType: "application/octet-stream", data: s2 })];
              }
            });
          });
        }, e2.prototype.decryptFile = function(e3, t2, n2) {
          return o(this, void 0, void 0, function() {
            var r2, o2, s2;
            return i(this, function(i2) {
              switch (i2.label) {
                case 0:
                  return [4, this.getKey(e3)];
                case 1:
                  return r2 = i2.sent(), [4, t2.data.arrayBuffer()];
                case 2:
                  return o2 = i2.sent(), [4, this.decryptArrayBuffer(r2, o2)];
                case 3:
                  return s2 = i2.sent(), [2, n2.create({ name: t2.name, data: s2 })];
              }
            });
          });
        }, e2.prototype.getKey = function(t2) {
          return o(this, void 0, void 0, function() {
            var n2, r2, o2;
            return i(this, function(i2) {
              switch (i2.label) {
                case 0:
                  return [4, crypto.subtle.digest("SHA-256", e2.encoder.encode(t2))];
                case 1:
                  return n2 = i2.sent(), r2 = Array.from(new Uint8Array(n2)).map(function(e3) {
                    return e3.toString(16).padStart(2, "0");
                  }).join(""), o2 = e2.encoder.encode(r2.slice(0, 32)).buffer, [2, crypto.subtle.importKey("raw", o2, "AES-CBC", true, ["encrypt", "decrypt"])];
              }
            });
          });
        }, e2.prototype.encryptArrayBuffer = function(e3, t2) {
          return o(this, void 0, void 0, function() {
            var n2, r2, o2;
            return i(this, function(i2) {
              switch (i2.label) {
                case 0:
                  return n2 = crypto.getRandomValues(new Uint8Array(16)), r2 = Li, o2 = [n2.buffer], [4, crypto.subtle.encrypt({ name: "AES-CBC", iv: n2 }, e3, t2)];
                case 1:
                  return [2, r2.apply(void 0, o2.concat([i2.sent()]))];
              }
            });
          });
        }, e2.prototype.decryptArrayBuffer = function(t2, n2) {
          return o(this, void 0, void 0, function() {
            var r2;
            return i(this, function(o2) {
              switch (o2.label) {
                case 0:
                  if (r2 = n2.slice(0, 16), n2.slice(e2.IV_LENGTH).byteLength <= 0) throw new Error("decryption error: empty content");
                  return [4, crypto.subtle.decrypt({ name: "AES-CBC", iv: r2 }, t2, n2.slice(e2.IV_LENGTH))];
                case 1:
                  return [2, o2.sent()];
              }
            });
          });
        }, e2.prototype.encryptString = function(t2, n2) {
          return o(this, void 0, void 0, function() {
            var r2, o2, s2, a2;
            return i(this, function(i2) {
              switch (i2.label) {
                case 0:
                  return r2 = crypto.getRandomValues(new Uint8Array(16)), o2 = e2.encoder.encode(n2).buffer, [4, crypto.subtle.encrypt({ name: "AES-CBC", iv: r2 }, t2, o2)];
                case 1:
                  return s2 = i2.sent(), a2 = Li(r2.buffer, s2), [2, e2.decoder.decode(a2)];
              }
            });
          });
        }, e2.prototype.decryptString = function(t2, n2) {
          return o(this, void 0, void 0, function() {
            var r2, o2, s2, a2;
            return i(this, function(i2) {
              switch (i2.label) {
                case 0:
                  return r2 = e2.encoder.encode(n2).buffer, o2 = r2.slice(0, 16), s2 = r2.slice(16), [4, crypto.subtle.decrypt({ name: "AES-CBC", iv: o2 }, t2, s2)];
                case 1:
                  return a2 = i2.sent(), [2, e2.decoder.decode(a2)];
              }
            });
          });
        }, e2.IV_LENGTH = 16, e2.encoder = new TextEncoder(), e2.decoder = new TextDecoder(), e2;
      }(), Bi = (Gi = function() {
        function e2(e3) {
          if (e3 instanceof File) this.data = e3, this.name = this.data.name, this.mimeType = this.data.type;
          else if (e3.data) {
            var t2 = e3.data;
            this.data = new File([t2], e3.name, { type: e3.mimeType }), this.name = e3.name, e3.mimeType && (this.mimeType = e3.mimeType);
          }
          if (void 0 === this.data) throw new Error("Couldn't construct a file out of supplied options.");
          if (void 0 === this.name) throw new Error("Couldn't guess filename out of the options. Please provide one.");
        }
        return e2.create = function(e3) {
          return new this(e3);
        }, e2.prototype.toBuffer = function() {
          return o(this, void 0, void 0, function() {
            return i(this, function(e3) {
              throw new Error("This feature is only supported in Node.js environments.");
            });
          });
        }, e2.prototype.toStream = function() {
          return o(this, void 0, void 0, function() {
            return i(this, function(e3) {
              throw new Error("This feature is only supported in Node.js environments.");
            });
          });
        }, e2.prototype.toFileUri = function() {
          return o(this, void 0, void 0, function() {
            return i(this, function(e3) {
              throw new Error("This feature is only supported in react native environments.");
            });
          });
        }, e2.prototype.toBlob = function() {
          return o(this, void 0, void 0, function() {
            return i(this, function(e3) {
              return [2, this.data];
            });
          });
        }, e2.prototype.toArrayBuffer = function() {
          return o(this, void 0, void 0, function() {
            var e3 = this;
            return i(this, function(t2) {
              return [2, new Promise(function(t3, n2) {
                var r2 = new FileReader();
                r2.addEventListener("load", function() {
                  if (r2.result instanceof ArrayBuffer) return t3(r2.result);
                }), r2.addEventListener("error", function() {
                  n2(r2.error);
                }), r2.readAsArrayBuffer(e3.data);
              })];
            });
          });
        }, e2.prototype.toString = function() {
          return o(this, void 0, void 0, function() {
            var e3 = this;
            return i(this, function(t2) {
              return [2, new Promise(function(t3, n2) {
                var r2 = new FileReader();
                r2.addEventListener("load", function() {
                  if ("string" == typeof r2.result) return t3(r2.result);
                }), r2.addEventListener("error", function() {
                  n2(r2.error);
                }), r2.readAsBinaryString(e3.data);
              })];
            });
          });
        }, e2.prototype.toFile = function() {
          return o(this, void 0, void 0, function() {
            return i(this, function(e3) {
              return [2, this.data];
            });
          });
        }, e2;
      }(), Gi.supportsFile = "undefined" != typeof File, Gi.supportsBlob = "undefined" != typeof Blob, Gi.supportsArrayBuffer = "undefined" != typeof ArrayBuffer, Gi.supportsBuffer = false, Gi.supportsStream = false, Gi.supportsString = true, Gi.supportsEncryptFile = true, Gi.supportsFileUri = false, Gi), Hi = function() {
        function e2(e3) {
          this.config = e3, this.cryptor = new T({ config: e3 }), this.fileCryptor = new Ki();
        }
        return Object.defineProperty(e2.prototype, "identifier", { get: function() {
          return "";
        }, enumerable: false, configurable: true }), e2.prototype.encrypt = function(e3) {
          var t2 = "string" == typeof e3 ? e3 : new TextDecoder().decode(e3);
          return { data: this.cryptor.encrypt(t2), metadata: null };
        }, e2.prototype.decrypt = function(e3) {
          var t2 = "string" == typeof e3.data ? e3.data : b(e3.data);
          return this.cryptor.decrypt(t2);
        }, e2.prototype.encryptFile = function(e3, t2) {
          var n2;
          return o(this, void 0, void 0, function() {
            return i(this, function(r2) {
              return [2, this.fileCryptor.encryptFile(null === (n2 = this.config) || void 0 === n2 ? void 0 : n2.cipherKey, e3, t2)];
            });
          });
        }, e2.prototype.decryptFile = function(e3, t2) {
          return o(this, void 0, void 0, function() {
            return i(this, function(n2) {
              return [2, this.fileCryptor.decryptFile(this.config.cipherKey, e3, t2)];
            });
          });
        }, e2;
      }(), qi = function() {
        function e2(e3) {
          this.cipherKey = e3.cipherKey, this.CryptoJS = E, this.encryptedKey = this.CryptoJS.SHA256(this.cipherKey);
        }
        return Object.defineProperty(e2.prototype, "algo", { get: function() {
          return "AES-CBC";
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "identifier", { get: function() {
          return "ACRH";
        }, enumerable: false, configurable: true }), e2.prototype.getIv = function() {
          return crypto.getRandomValues(new Uint8Array(e2.BLOCK_SIZE));
        }, e2.prototype.getKey = function() {
          return o(this, void 0, void 0, function() {
            var t2, n2;
            return i(this, function(r2) {
              switch (r2.label) {
                case 0:
                  return t2 = e2.encoder.encode(this.cipherKey), [4, crypto.subtle.digest("SHA-256", t2.buffer)];
                case 1:
                  return n2 = r2.sent(), [2, crypto.subtle.importKey("raw", n2, this.algo, true, ["encrypt", "decrypt"])];
              }
            });
          });
        }, e2.prototype.encrypt = function(t2) {
          if (0 === ("string" == typeof t2 ? t2 : e2.decoder.decode(t2)).length) throw new Error("encryption error. empty content");
          var n2 = this.getIv();
          return { metadata: n2, data: m(this.CryptoJS.AES.encrypt(t2, this.encryptedKey, { iv: this.bufferToWordArray(n2), mode: this.CryptoJS.mode.CBC }).ciphertext.toString(this.CryptoJS.enc.Base64)) };
        }, e2.prototype.decrypt = function(t2) {
          var n2 = this.bufferToWordArray(new Uint8ClampedArray(t2.metadata)), r2 = this.bufferToWordArray(new Uint8ClampedArray(t2.data));
          return e2.encoder.encode(this.CryptoJS.AES.decrypt({ ciphertext: r2 }, this.encryptedKey, { iv: n2, mode: this.CryptoJS.mode.CBC }).toString(this.CryptoJS.enc.Utf8)).buffer;
        }, e2.prototype.encryptFileData = function(e3) {
          return o(this, void 0, void 0, function() {
            var t2, n2, r2;
            return i(this, function(o2) {
              switch (o2.label) {
                case 0:
                  return [4, this.getKey()];
                case 1:
                  return t2 = o2.sent(), n2 = this.getIv(), r2 = {}, [4, crypto.subtle.encrypt({ name: this.algo, iv: n2 }, t2, e3)];
                case 2:
                  return [2, (r2.data = o2.sent(), r2.metadata = n2, r2)];
              }
            });
          });
        }, e2.prototype.decryptFileData = function(e3) {
          return o(this, void 0, void 0, function() {
            var t2;
            return i(this, function(n2) {
              switch (n2.label) {
                case 0:
                  return [4, this.getKey()];
                case 1:
                  return t2 = n2.sent(), [2, crypto.subtle.decrypt({ name: this.algo, iv: e3.metadata }, t2, e3.data)];
              }
            });
          });
        }, e2.prototype.bufferToWordArray = function(e3) {
          var t2, n2 = [];
          for (t2 = 0; t2 < e3.length; t2 += 1) n2[t2 / 4 | 0] |= e3[t2] << 24 - 8 * t2;
          return this.CryptoJS.lib.WordArray.create(n2, e3.length);
        }, e2.BLOCK_SIZE = 16, e2.encoder = new TextEncoder(), e2.decoder = new TextDecoder(), e2;
      }(), zi = function() {
        function e2(e3) {
          var t2;
          this.defaultCryptor = e3.default, this.cryptors = null !== (t2 = e3.cryptors) && void 0 !== t2 ? t2 : [];
        }
        return e2.legacyCryptoModule = function(e3) {
          var t2;
          return new this({ default: new Hi({ cipherKey: e3.cipherKey, useRandomIVs: null === (t2 = e3.useRandomIVs) || void 0 === t2 || t2 }), cryptors: [new qi({ cipherKey: e3.cipherKey })] });
        }, e2.aesCbcCryptoModule = function(e3) {
          var t2;
          return new this({ default: new qi({ cipherKey: e3.cipherKey }), cryptors: [new Hi({ cipherKey: e3.cipherKey, useRandomIVs: null === (t2 = e3.useRandomIVs) || void 0 === t2 || t2 })] });
        }, e2.withDefaultCryptor = function(e3) {
          return new this({ default: e3 });
        }, e2.prototype.getAllCryptors = function() {
          return u([this.defaultCryptor], a(this.cryptors), false);
        }, e2.prototype.encrypt = function(e3) {
          var t2 = this.defaultCryptor.encrypt(e3);
          if (!t2.metadata) return t2.data;
          var n2 = this.getHeaderData(t2);
          return this.concatArrayBuffer(n2, t2.data);
        }, e2.prototype.decrypt = function(e3) {
          var t2 = "string" == typeof e3 ? m(e3) : e3, n2 = Vi.tryParse(t2), r2 = this.getCryptor(n2), o2 = n2.length > 0 ? t2.slice(n2.length - n2.metadataLength, n2.length) : null;
          if (t2.slice(n2.length).byteLength <= 0) throw new Error("decryption error. empty content");
          return r2.decrypt({ data: t2.slice(n2.length), metadata: o2 });
        }, e2.prototype.encryptFile = function(e3, t2) {
          return o(this, void 0, void 0, function() {
            var n2, r2;
            return i(this, function(o2) {
              switch (o2.label) {
                case 0:
                  return this.defaultCryptor.identifier === Vi.LEGACY_IDENTIFIER ? [2, this.defaultCryptor.encryptFile(e3, t2)] : [4, this.getFileData(e3.data)];
                case 1:
                  return n2 = o2.sent(), [4, this.defaultCryptor.encryptFileData(n2)];
                case 2:
                  return r2 = o2.sent(), [2, t2.create({ name: e3.name, mimeType: "application/octet-stream", data: this.concatArrayBuffer(this.getHeaderData(r2), r2.data) })];
              }
            });
          });
        }, e2.prototype.decryptFile = function(t2, n2) {
          return o(this, void 0, void 0, function() {
            var r2, o2, s2, a2, u2, c2, l2, p2;
            return i(this, function(i2) {
              switch (i2.label) {
                case 0:
                  return [4, t2.data.arrayBuffer()];
                case 1:
                  return r2 = i2.sent(), o2 = Vi.tryParse(r2), (null == (s2 = this.getCryptor(o2)) ? void 0 : s2.identifier) === e2.LEGACY_IDENTIFIER ? [2, s2.decryptFile(t2, n2)] : [4, this.getFileData(r2)];
                case 2:
                  return a2 = i2.sent(), u2 = a2.slice(o2.length - o2.metadataLength, o2.length), l2 = (c2 = n2).create, p2 = { name: t2.name }, [4, this.defaultCryptor.decryptFileData({ data: r2.slice(o2.length), metadata: u2 })];
                case 3:
                  return [2, l2.apply(c2, [(p2.data = i2.sent(), p2)])];
              }
            });
          });
        }, e2.prototype.getCryptor = function(e3) {
          if ("" === e3) {
            var t2 = this.getAllCryptors().find(function(e4) {
              return "" === e4.identifier;
            });
            if (t2) return t2;
            throw new Error("unknown cryptor error");
          }
          if (e3 instanceof Wi) return this.getCryptorFromId(e3.identifier);
        }, e2.prototype.getCryptorFromId = function(e3) {
          var t2 = this.getAllCryptors().find(function(t3) {
            return e3 === t3.identifier;
          });
          if (t2) return t2;
          throw Error("unknown cryptor error");
        }, e2.prototype.concatArrayBuffer = function(e3, t2) {
          var n2 = new Uint8Array(e3.byteLength + t2.byteLength);
          return n2.set(new Uint8Array(e3), 0), n2.set(new Uint8Array(t2), e3.byteLength), n2.buffer;
        }, e2.prototype.getHeaderData = function(e3) {
          if (e3.metadata) {
            var t2 = Vi.from(this.defaultCryptor.identifier, e3.metadata), n2 = new Uint8Array(t2.length), r2 = 0;
            return n2.set(t2.data, r2), r2 += t2.length - e3.metadata.byteLength, n2.set(new Uint8Array(e3.metadata), r2), n2.buffer;
          }
        }, e2.prototype.getFileData = function(t2) {
          return o(this, void 0, void 0, function() {
            return i(this, function(n2) {
              switch (n2.label) {
                case 0:
                  return t2 instanceof Blob ? [4, t2.arrayBuffer()] : [3, 2];
                case 1:
                  return [2, n2.sent()];
                case 2:
                  if (t2 instanceof ArrayBuffer) return [2, t2];
                  if ("string" == typeof t2) return [2, e2.encoder.encode(t2)];
                  throw new Error("Cannot decrypt/encrypt file. In browsers file encrypt/decrypt supported for string, ArrayBuffer or Blob");
              }
            });
          });
        }, e2.LEGACY_IDENTIFIER = "", e2.encoder = new TextEncoder(), e2.decoder = new TextDecoder(), e2;
      }(), Vi = function() {
        function e2() {
        }
        return e2.from = function(t2, n2) {
          if (t2 !== e2.LEGACY_IDENTIFIER) return new Wi(t2, n2.byteLength);
        }, e2.tryParse = function(t2) {
          var n2 = new Uint8Array(t2), r2 = "";
          if (n2.byteLength >= 4 && (r2 = n2.slice(0, 4), this.decoder.decode(r2) !== e2.SENTINEL)) return "";
          if (!(n2.byteLength >= 5)) throw new Error("decryption error. invalid header version");
          if (n2[4] > e2.MAX_VERSION) throw new Error("unknown cryptor error");
          var o2 = "", i2 = 5 + e2.IDENTIFIER_LENGTH;
          if (!(n2.byteLength >= i2)) throw new Error("decryption error. invalid crypto identifier");
          o2 = n2.slice(5, i2);
          var s2 = null;
          if (!(n2.byteLength >= i2 + 1)) throw new Error("decryption error. invalid metadata length");
          return s2 = n2[i2], i2 += 1, 255 === s2 && n2.byteLength >= i2 + 2 && (s2 = new Uint16Array(n2.slice(i2, i2 + 2)).reduce(function(e3, t3) {
            return (e3 << 8) + t3;
          }, 0), i2 += 2), new Wi(this.decoder.decode(o2), s2);
        }, e2.SENTINEL = "PNED", e2.LEGACY_IDENTIFIER = "", e2.IDENTIFIER_LENGTH = 4, e2.VERSION = 1, e2.MAX_VERSION = 1, e2.decoder = new TextDecoder(), e2;
      }(), Wi = function() {
        function e2(e3, t2) {
          this._identifier = e3, this._metadataLength = t2;
        }
        return Object.defineProperty(e2.prototype, "identifier", { get: function() {
          return this._identifier;
        }, set: function(e3) {
          this._identifier = e3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "metadataLength", { get: function() {
          return this._metadataLength;
        }, set: function(e3) {
          this._metadataLength = e3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "version", { get: function() {
          return Vi.VERSION;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "length", { get: function() {
          return Vi.SENTINEL.length + 1 + Vi.IDENTIFIER_LENGTH + (this.metadataLength < 255 ? 1 : 3) + this.metadataLength;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "data", { get: function() {
          var e3 = 0, t2 = new Uint8Array(this.length), n2 = new TextEncoder();
          t2.set(n2.encode(Vi.SENTINEL)), t2[e3 += Vi.SENTINEL.length] = this.version, e3++, this.identifier && t2.set(n2.encode(this.identifier), e3), e3 += Vi.IDENTIFIER_LENGTH;
          var r2 = this.metadataLength;
          return r2 < 255 ? t2[e3] = r2 : t2.set([255, r2 >> 8, 255 & r2], e3), t2;
        }, enumerable: false, configurable: true }), e2.IDENTIFIER_LENGTH = 4, e2.SENTINEL = "PNED", e2;
      }();
      function Ji(e2) {
        if (!navigator || !navigator.sendBeacon) return false;
        navigator.sendBeacon(e2);
      }
      var $i = function(e2) {
        function n2(t2) {
          var n3 = this, r2 = t2.listenToBrowserNetworkEvents, o2 = void 0 === r2 || r2;
          return t2.sdkFamily = "Web", t2.networking = new _n({ del: Fi, get: Ui, post: Ii, patch: Di, sendBeacon: Ji, getfile: xi, postfile: Ri }), t2.cbor = new wn(function(e3) {
            return Sn(h.decode(e3));
          }, m), t2.PubNubFile = Bi, t2.cryptography = new Ki(), t2.initCryptoModule = function(e3) {
            return new zi({ default: new Hi({ cipherKey: e3.cipherKey, useRandomIVs: e3.useRandomIVs }), cryptors: [new qi({ cipherKey: e3.cipherKey })] });
          }, n3 = e2.call(this, t2) || this, o2 && (window.addEventListener("offline", function() {
            n3.networkDownDetected();
          }), window.addEventListener("online", function() {
            n3.networkUpDetected();
          })), n3;
        }
        return t(n2, e2), n2.CryptoModule = zi, n2;
      }(vn);
      return $i;
    });
  }
});

// node_modules/diff/dist/diff.js
var require_diff3 = __commonJS({
  "node_modules/diff/dist/diff.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.Diff = {}));
    })(exports, function(exports2) {
      "use strict";
      function Diff() {
      }
      Diff.prototype = {
        diff: function diff(oldString, newString) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var callback = options.callback;
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          this.options = options;
          var self2 = this;
          function done(value) {
            if (callback) {
              setTimeout(function() {
                callback(void 0, value);
              }, 0);
              return true;
            } else {
              return value;
            }
          }
          oldString = this.castInput(oldString);
          newString = this.castInput(newString);
          oldString = this.removeEmpty(this.tokenize(oldString));
          newString = this.removeEmpty(this.tokenize(newString));
          var newLen = newString.length, oldLen = oldString.length;
          var editLength = 1;
          var maxEditLength = newLen + oldLen;
          var bestPath = [{
            newPos: -1,
            components: []
          }];
          var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
          if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
            return done([{
              value: this.join(newString),
              count: newString.length
            }]);
          }
          function execEditLength() {
            for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
              var basePath = void 0;
              var addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
              if (addPath) {
                bestPath[diagonalPath - 1] = void 0;
              }
              var canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
              if (!canAdd && !canRemove) {
                bestPath[diagonalPath] = void 0;
                continue;
              }
              if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
                basePath = clonePath(removePath);
                self2.pushComponent(basePath.components, void 0, true);
              } else {
                basePath = addPath;
                basePath.newPos++;
                self2.pushComponent(basePath.components, true, void 0);
              }
              _oldPos = self2.extractCommon(basePath, newString, oldString, diagonalPath);
              if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
                return done(buildValues(self2, basePath.components, newString, oldString, self2.useLongestToken));
              } else {
                bestPath[diagonalPath] = basePath;
              }
            }
            editLength++;
          }
          if (callback) {
            (function exec() {
              setTimeout(function() {
                if (editLength > maxEditLength) {
                  return callback();
                }
                if (!execEditLength()) {
                  exec();
                }
              }, 0);
            })();
          } else {
            while (editLength <= maxEditLength) {
              var ret = execEditLength();
              if (ret) {
                return ret;
              }
            }
          }
        },
        pushComponent: function pushComponent(components, added, removed) {
          var last = components[components.length - 1];
          if (last && last.added === added && last.removed === removed) {
            components[components.length - 1] = {
              count: last.count + 1,
              added,
              removed
            };
          } else {
            components.push({
              count: 1,
              added,
              removed
            });
          }
        },
        extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
          var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0;
          while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
            newPos++;
            oldPos++;
            commonCount++;
          }
          if (commonCount) {
            basePath.components.push({
              count: commonCount
            });
          }
          basePath.newPos = newPos;
          return oldPos;
        },
        equals: function equals(left, right) {
          if (this.options.comparator) {
            return this.options.comparator(left, right);
          } else {
            return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
          }
        },
        removeEmpty: function removeEmpty(array) {
          var ret = [];
          for (var i = 0; i < array.length; i++) {
            if (array[i]) {
              ret.push(array[i]);
            }
          }
          return ret;
        },
        castInput: function castInput(value) {
          return value;
        },
        tokenize: function tokenize(value) {
          return value.split("");
        },
        join: function join(chars) {
          return chars.join("");
        }
      };
      function buildValues(diff, components, newString, oldString, useLongestToken) {
        var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
        for (; componentPos < componentLen; componentPos++) {
          var component = components[componentPos];
          if (!component.removed) {
            if (!component.added && useLongestToken) {
              var value = newString.slice(newPos, newPos + component.count);
              value = value.map(function(value2, i) {
                var oldValue = oldString[oldPos + i];
                return oldValue.length > value2.length ? oldValue : value2;
              });
              component.value = diff.join(value);
            } else {
              component.value = diff.join(newString.slice(newPos, newPos + component.count));
            }
            newPos += component.count;
            if (!component.added) {
              oldPos += component.count;
            }
          } else {
            component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
            oldPos += component.count;
            if (componentPos && components[componentPos - 1].added) {
              var tmp = components[componentPos - 1];
              components[componentPos - 1] = components[componentPos];
              components[componentPos] = tmp;
            }
          }
        }
        var lastComponent = components[componentLen - 1];
        if (componentLen > 1 && typeof lastComponent.value === "string" && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value)) {
          components[componentLen - 2].value += lastComponent.value;
          components.pop();
        }
        return components;
      }
      function clonePath(path) {
        return {
          newPos: path.newPos,
          components: path.components.slice(0)
        };
      }
      var characterDiff = new Diff();
      function diffChars(oldStr, newStr, options) {
        return characterDiff.diff(oldStr, newStr, options);
      }
      function generateOptions(options, defaults) {
        if (typeof options === "function") {
          defaults.callback = options;
        } else if (options) {
          for (var name in options) {
            if (options.hasOwnProperty(name)) {
              defaults[name] = options[name];
            }
          }
        }
        return defaults;
      }
      var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
      var reWhitespace = /\S/;
      var wordDiff = new Diff();
      wordDiff.equals = function(left, right) {
        if (this.options.ignoreCase) {
          left = left.toLowerCase();
          right = right.toLowerCase();
        }
        return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
      };
      wordDiff.tokenize = function(value) {
        var tokens = value.split(/(\s+|[()[\]{}'"]|\b)/);
        for (var i = 0; i < tokens.length - 1; i++) {
          if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
            tokens[i] += tokens[i + 2];
            tokens.splice(i + 1, 2);
            i--;
          }
        }
        return tokens;
      };
      function diffWords(oldStr, newStr, options) {
        options = generateOptions(options, {
          ignoreWhitespace: true
        });
        return wordDiff.diff(oldStr, newStr, options);
      }
      function diffWordsWithSpace(oldStr, newStr, options) {
        return wordDiff.diff(oldStr, newStr, options);
      }
      var lineDiff = new Diff();
      lineDiff.tokenize = function(value) {
        var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
        if (!linesAndNewlines[linesAndNewlines.length - 1]) {
          linesAndNewlines.pop();
        }
        for (var i = 0; i < linesAndNewlines.length; i++) {
          var line = linesAndNewlines[i];
          if (i % 2 && !this.options.newlineIsToken) {
            retLines[retLines.length - 1] += line;
          } else {
            if (this.options.ignoreWhitespace) {
              line = line.trim();
            }
            retLines.push(line);
          }
        }
        return retLines;
      };
      function diffLines(oldStr, newStr, callback) {
        return lineDiff.diff(oldStr, newStr, callback);
      }
      function diffTrimmedLines(oldStr, newStr, callback) {
        var options = generateOptions(callback, {
          ignoreWhitespace: true
        });
        return lineDiff.diff(oldStr, newStr, options);
      }
      var sentenceDiff = new Diff();
      sentenceDiff.tokenize = function(value) {
        return value.split(/(\S.+?[.!?])(?=\s+|$)/);
      };
      function diffSentences(oldStr, newStr, callback) {
        return sentenceDiff.diff(oldStr, newStr, callback);
      }
      var cssDiff = new Diff();
      cssDiff.tokenize = function(value) {
        return value.split(/([{}:;,]|\s+)/);
      };
      function diffCss(oldStr, newStr, callback) {
        return cssDiff.diff(oldStr, newStr, callback);
      }
      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
      }
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
          return arr2;
        }
      }
      function _iterableToArray(iter) {
        if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance");
      }
      var objectPrototypeToString = Object.prototype.toString;
      var jsonDiff = new Diff();
      jsonDiff.useLongestToken = true;
      jsonDiff.tokenize = lineDiff.tokenize;
      jsonDiff.castInput = function(value) {
        var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k, v) {
          return typeof v === "undefined" ? undefinedReplacement : v;
        } : _this$options$stringi;
        return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
      };
      jsonDiff.equals = function(left, right) {
        return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"));
      };
      function diffJson(oldObj, newObj, options) {
        return jsonDiff.diff(oldObj, newObj, options);
      }
      function canonicalize(obj, stack, replacementStack, replacer, key) {
        stack = stack || [];
        replacementStack = replacementStack || [];
        if (replacer) {
          obj = replacer(key, obj);
        }
        var i;
        for (i = 0; i < stack.length; i += 1) {
          if (stack[i] === obj) {
            return replacementStack[i];
          }
        }
        var canonicalizedObj;
        if ("[object Array]" === objectPrototypeToString.call(obj)) {
          stack.push(obj);
          canonicalizedObj = new Array(obj.length);
          replacementStack.push(canonicalizedObj);
          for (i = 0; i < obj.length; i += 1) {
            canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
          }
          stack.pop();
          replacementStack.pop();
          return canonicalizedObj;
        }
        if (obj && obj.toJSON) {
          obj = obj.toJSON();
        }
        if (_typeof(obj) === "object" && obj !== null) {
          stack.push(obj);
          canonicalizedObj = {};
          replacementStack.push(canonicalizedObj);
          var sortedKeys = [], _key;
          for (_key in obj) {
            if (obj.hasOwnProperty(_key)) {
              sortedKeys.push(_key);
            }
          }
          sortedKeys.sort();
          for (i = 0; i < sortedKeys.length; i += 1) {
            _key = sortedKeys[i];
            canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
          }
          stack.pop();
          replacementStack.pop();
        } else {
          canonicalizedObj = obj;
        }
        return canonicalizedObj;
      }
      var arrayDiff = new Diff();
      arrayDiff.tokenize = function(value) {
        return value.slice();
      };
      arrayDiff.join = arrayDiff.removeEmpty = function(value) {
        return value;
      };
      function diffArrays(oldArr, newArr, callback) {
        return arrayDiff.diff(oldArr, newArr, callback);
      }
      function parsePatch(uniDiff) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/), delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [], list = [], i = 0;
        function parseIndex() {
          var index = {};
          list.push(index);
          while (i < diffstr.length) {
            var line = diffstr[i];
            if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
              break;
            }
            var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
            if (header) {
              index.index = header[1];
            }
            i++;
          }
          parseFileHeader(index);
          parseFileHeader(index);
          index.hunks = [];
          while (i < diffstr.length) {
            var _line = diffstr[i];
            if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
              break;
            } else if (/^@@/.test(_line)) {
              index.hunks.push(parseHunk());
            } else if (_line && options.strict) {
              throw new Error("Unknown line " + (i + 1) + " " + JSON.stringify(_line));
            } else {
              i++;
            }
          }
        }
        function parseFileHeader(index) {
          var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);
          if (fileHeader) {
            var keyPrefix = fileHeader[1] === "---" ? "old" : "new";
            var data = fileHeader[2].split("	", 2);
            var fileName = data[0].replace(/\\\\/g, "\\");
            if (/^".*"$/.test(fileName)) {
              fileName = fileName.substr(1, fileName.length - 2);
            }
            index[keyPrefix + "FileName"] = fileName;
            index[keyPrefix + "Header"] = (data[1] || "").trim();
            i++;
          }
        }
        function parseHunk() {
          var chunkHeaderIndex = i, chunkHeaderLine = diffstr[i++], chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
          var hunk = {
            oldStart: +chunkHeader[1],
            oldLines: +chunkHeader[2] || 1,
            newStart: +chunkHeader[3],
            newLines: +chunkHeader[4] || 1,
            lines: [],
            linedelimiters: []
          };
          var addCount = 0, removeCount = 0;
          for (; i < diffstr.length; i++) {
            if (diffstr[i].indexOf("--- ") === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf("+++ ") === 0 && diffstr[i + 2].indexOf("@@") === 0) {
              break;
            }
            var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? " " : diffstr[i][0];
            if (operation === "+" || operation === "-" || operation === " " || operation === "\\") {
              hunk.lines.push(diffstr[i]);
              hunk.linedelimiters.push(delimiters[i] || "\n");
              if (operation === "+") {
                addCount++;
              } else if (operation === "-") {
                removeCount++;
              } else if (operation === " ") {
                addCount++;
                removeCount++;
              }
            } else {
              break;
            }
          }
          if (!addCount && hunk.newLines === 1) {
            hunk.newLines = 0;
          }
          if (!removeCount && hunk.oldLines === 1) {
            hunk.oldLines = 0;
          }
          if (options.strict) {
            if (addCount !== hunk.newLines) {
              throw new Error("Added line count did not match for hunk at line " + (chunkHeaderIndex + 1));
            }
            if (removeCount !== hunk.oldLines) {
              throw new Error("Removed line count did not match for hunk at line " + (chunkHeaderIndex + 1));
            }
          }
          return hunk;
        }
        while (i < diffstr.length) {
          parseIndex();
        }
        return list;
      }
      function distanceIterator(start, minLine, maxLine) {
        var wantForward = true, backwardExhausted = false, forwardExhausted = false, localOffset = 1;
        return function iterator() {
          if (wantForward && !forwardExhausted) {
            if (backwardExhausted) {
              localOffset++;
            } else {
              wantForward = false;
            }
            if (start + localOffset <= maxLine) {
              return localOffset;
            }
            forwardExhausted = true;
          }
          if (!backwardExhausted) {
            if (!forwardExhausted) {
              wantForward = true;
            }
            if (minLine <= start - localOffset) {
              return -localOffset++;
            }
            backwardExhausted = true;
            return iterator();
          }
        };
      }
      function applyPatch(source, uniDiff) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (typeof uniDiff === "string") {
          uniDiff = parsePatch(uniDiff);
        }
        if (Array.isArray(uniDiff)) {
          if (uniDiff.length > 1) {
            throw new Error("applyPatch only works with a single input.");
          }
          uniDiff = uniDiff[0];
        }
        var lines = source.split(/\r\n|[\n\v\f\r\x85]/), delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [], hunks = uniDiff.hunks, compareLine = options.compareLine || function(lineNumber, line2, operation2, patchContent) {
          return line2 === patchContent;
        }, errorCount = 0, fuzzFactor = options.fuzzFactor || 0, minLine = 0, offset = 0, removeEOFNL, addEOFNL;
        function hunkFits(hunk2, toPos2) {
          for (var j2 = 0; j2 < hunk2.lines.length; j2++) {
            var line2 = hunk2.lines[j2], operation2 = line2.length > 0 ? line2[0] : " ", content2 = line2.length > 0 ? line2.substr(1) : line2;
            if (operation2 === " " || operation2 === "-") {
              if (!compareLine(toPos2 + 1, lines[toPos2], operation2, content2)) {
                errorCount++;
                if (errorCount > fuzzFactor) {
                  return false;
                }
              }
              toPos2++;
            }
          }
          return true;
        }
        for (var i = 0; i < hunks.length; i++) {
          var hunk = hunks[i], maxLine = lines.length - hunk.oldLines, localOffset = 0, toPos = offset + hunk.oldStart - 1;
          var iterator = distanceIterator(toPos, minLine, maxLine);
          for (; localOffset !== void 0; localOffset = iterator()) {
            if (hunkFits(hunk, toPos + localOffset)) {
              hunk.offset = offset += localOffset;
              break;
            }
          }
          if (localOffset === void 0) {
            return false;
          }
          minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
        }
        var diffOffset = 0;
        for (var _i = 0; _i < hunks.length; _i++) {
          var _hunk = hunks[_i], _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;
          diffOffset += _hunk.newLines - _hunk.oldLines;
          if (_toPos < 0) {
            _toPos = 0;
          }
          for (var j = 0; j < _hunk.lines.length; j++) {
            var line = _hunk.lines[j], operation = line.length > 0 ? line[0] : " ", content = line.length > 0 ? line.substr(1) : line, delimiter = _hunk.linedelimiters[j];
            if (operation === " ") {
              _toPos++;
            } else if (operation === "-") {
              lines.splice(_toPos, 1);
              delimiters.splice(_toPos, 1);
            } else if (operation === "+") {
              lines.splice(_toPos, 0, content);
              delimiters.splice(_toPos, 0, delimiter);
              _toPos++;
            } else if (operation === "\\") {
              var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
              if (previousOperation === "+") {
                removeEOFNL = true;
              } else if (previousOperation === "-") {
                addEOFNL = true;
              }
            }
          }
        }
        if (removeEOFNL) {
          while (!lines[lines.length - 1]) {
            lines.pop();
            delimiters.pop();
          }
        } else if (addEOFNL) {
          lines.push("");
          delimiters.push("\n");
        }
        for (var _k = 0; _k < lines.length - 1; _k++) {
          lines[_k] = lines[_k] + delimiters[_k];
        }
        return lines.join("");
      }
      function applyPatches(uniDiff, options) {
        if (typeof uniDiff === "string") {
          uniDiff = parsePatch(uniDiff);
        }
        var currentIndex = 0;
        function processIndex() {
          var index = uniDiff[currentIndex++];
          if (!index) {
            return options.complete();
          }
          options.loadFile(index, function(err, data) {
            if (err) {
              return options.complete(err);
            }
            var updatedContent = applyPatch(data, index, options);
            options.patched(index, updatedContent, function(err2) {
              if (err2) {
                return options.complete(err2);
              }
              processIndex();
            });
          });
        }
        processIndex();
      }
      function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
        if (!options) {
          options = {};
        }
        if (typeof options.context === "undefined") {
          options.context = 4;
        }
        var diff = diffLines(oldStr, newStr, options);
        diff.push({
          value: "",
          lines: []
        });
        function contextLines(lines) {
          return lines.map(function(entry) {
            return " " + entry;
          });
        }
        var hunks = [];
        var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
        var _loop = function _loop2(i2) {
          var current = diff[i2], lines = current.lines || current.value.replace(/\n$/, "").split("\n");
          current.lines = lines;
          if (current.added || current.removed) {
            var _curRange;
            if (!oldRangeStart) {
              var prev = diff[i2 - 1];
              oldRangeStart = oldLine;
              newRangeStart = newLine;
              if (prev) {
                curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
                oldRangeStart -= curRange.length;
                newRangeStart -= curRange.length;
              }
            }
            (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function(entry) {
              return (current.added ? "+" : "-") + entry;
            })));
            if (current.added) {
              newLine += lines.length;
            } else {
              oldLine += lines.length;
            }
          } else {
            if (oldRangeStart) {
              if (lines.length <= options.context * 2 && i2 < diff.length - 2) {
                var _curRange2;
                (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));
              } else {
                var _curRange3;
                var contextSize = Math.min(lines.length, options.context);
                (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
                var hunk = {
                  oldStart: oldRangeStart,
                  oldLines: oldLine - oldRangeStart + contextSize,
                  newStart: newRangeStart,
                  newLines: newLine - newRangeStart + contextSize,
                  lines: curRange
                };
                if (i2 >= diff.length - 2 && lines.length <= options.context) {
                  var oldEOFNewline = /\n$/.test(oldStr);
                  var newEOFNewline = /\n$/.test(newStr);
                  var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;
                  if (!oldEOFNewline && noNlBeforeAdds) {
                    curRange.splice(hunk.oldLines, 0, "\\ No newline at end of file");
                  }
                  if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
                    curRange.push("\\ No newline at end of file");
                  }
                }
                hunks.push(hunk);
                oldRangeStart = 0;
                newRangeStart = 0;
                curRange = [];
              }
            }
            oldLine += lines.length;
            newLine += lines.length;
          }
        };
        for (var i = 0; i < diff.length; i++) {
          _loop(i);
        }
        return {
          oldFileName,
          newFileName,
          oldHeader,
          newHeader,
          hunks
        };
      }
      function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
        var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);
        var ret = [];
        if (oldFileName == newFileName) {
          ret.push("Index: " + oldFileName);
        }
        ret.push("===================================================================");
        ret.push("--- " + diff.oldFileName + (typeof diff.oldHeader === "undefined" ? "" : "	" + diff.oldHeader));
        ret.push("+++ " + diff.newFileName + (typeof diff.newHeader === "undefined" ? "" : "	" + diff.newHeader));
        for (var i = 0; i < diff.hunks.length; i++) {
          var hunk = diff.hunks[i];
          ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
          ret.push.apply(ret, hunk.lines);
        }
        return ret.join("\n") + "\n";
      }
      function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
        return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
      }
      function arrayEqual(a, b) {
        if (a.length !== b.length) {
          return false;
        }
        return arrayStartsWith(a, b);
      }
      function arrayStartsWith(array, start) {
        if (start.length > array.length) {
          return false;
        }
        for (var i = 0; i < start.length; i++) {
          if (start[i] !== array[i]) {
            return false;
          }
        }
        return true;
      }
      function calcLineCount(hunk) {
        var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines), oldLines = _calcOldNewLineCount.oldLines, newLines = _calcOldNewLineCount.newLines;
        if (oldLines !== void 0) {
          hunk.oldLines = oldLines;
        } else {
          delete hunk.oldLines;
        }
        if (newLines !== void 0) {
          hunk.newLines = newLines;
        } else {
          delete hunk.newLines;
        }
      }
      function merge(mine, theirs, base) {
        mine = loadPatch(mine, base);
        theirs = loadPatch(theirs, base);
        var ret = {};
        if (mine.index || theirs.index) {
          ret.index = mine.index || theirs.index;
        }
        if (mine.newFileName || theirs.newFileName) {
          if (!fileNameChanged(mine)) {
            ret.oldFileName = theirs.oldFileName || mine.oldFileName;
            ret.newFileName = theirs.newFileName || mine.newFileName;
            ret.oldHeader = theirs.oldHeader || mine.oldHeader;
            ret.newHeader = theirs.newHeader || mine.newHeader;
          } else if (!fileNameChanged(theirs)) {
            ret.oldFileName = mine.oldFileName;
            ret.newFileName = mine.newFileName;
            ret.oldHeader = mine.oldHeader;
            ret.newHeader = mine.newHeader;
          } else {
            ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
            ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
            ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
            ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
          }
        }
        ret.hunks = [];
        var mineIndex = 0, theirsIndex = 0, mineOffset = 0, theirsOffset = 0;
        while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
          var mineCurrent = mine.hunks[mineIndex] || {
            oldStart: Infinity
          }, theirsCurrent = theirs.hunks[theirsIndex] || {
            oldStart: Infinity
          };
          if (hunkBefore(mineCurrent, theirsCurrent)) {
            ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
            mineIndex++;
            theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
          } else if (hunkBefore(theirsCurrent, mineCurrent)) {
            ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
            theirsIndex++;
            mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
          } else {
            var mergedHunk = {
              oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
              oldLines: 0,
              newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
              newLines: 0,
              lines: []
            };
            mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
            theirsIndex++;
            mineIndex++;
            ret.hunks.push(mergedHunk);
          }
        }
        return ret;
      }
      function loadPatch(param, base) {
        if (typeof param === "string") {
          if (/^@@/m.test(param) || /^Index:/m.test(param)) {
            return parsePatch(param)[0];
          }
          if (!base) {
            throw new Error("Must provide a base reference or pass in a patch");
          }
          return structuredPatch(void 0, void 0, base, param);
        }
        return param;
      }
      function fileNameChanged(patch) {
        return patch.newFileName && patch.newFileName !== patch.oldFileName;
      }
      function selectField(index, mine, theirs) {
        if (mine === theirs) {
          return mine;
        } else {
          index.conflict = true;
          return {
            mine,
            theirs
          };
        }
      }
      function hunkBefore(test, check) {
        return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
      }
      function cloneHunk(hunk, offset) {
        return {
          oldStart: hunk.oldStart,
          oldLines: hunk.oldLines,
          newStart: hunk.newStart + offset,
          newLines: hunk.newLines,
          lines: hunk.lines
        };
      }
      function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
        var mine = {
          offset: mineOffset,
          lines: mineLines,
          index: 0
        }, their = {
          offset: theirOffset,
          lines: theirLines,
          index: 0
        };
        insertLeading(hunk, mine, their);
        insertLeading(hunk, their, mine);
        while (mine.index < mine.lines.length && their.index < their.lines.length) {
          var mineCurrent = mine.lines[mine.index], theirCurrent = their.lines[their.index];
          if ((mineCurrent[0] === "-" || mineCurrent[0] === "+") && (theirCurrent[0] === "-" || theirCurrent[0] === "+")) {
            mutualChange(hunk, mine, their);
          } else if (mineCurrent[0] === "+" && theirCurrent[0] === " ") {
            var _hunk$lines;
            (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));
          } else if (theirCurrent[0] === "+" && mineCurrent[0] === " ") {
            var _hunk$lines2;
            (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));
          } else if (mineCurrent[0] === "-" && theirCurrent[0] === " ") {
            removal(hunk, mine, their);
          } else if (theirCurrent[0] === "-" && mineCurrent[0] === " ") {
            removal(hunk, their, mine, true);
          } else if (mineCurrent === theirCurrent) {
            hunk.lines.push(mineCurrent);
            mine.index++;
            their.index++;
          } else {
            conflict(hunk, collectChange(mine), collectChange(their));
          }
        }
        insertTrailing(hunk, mine);
        insertTrailing(hunk, their);
        calcLineCount(hunk);
      }
      function mutualChange(hunk, mine, their) {
        var myChanges = collectChange(mine), theirChanges = collectChange(their);
        if (allRemoves(myChanges) && allRemoves(theirChanges)) {
          if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
            var _hunk$lines3;
            (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));
            return;
          } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
            var _hunk$lines4;
            (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));
            return;
          }
        } else if (arrayEqual(myChanges, theirChanges)) {
          var _hunk$lines5;
          (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));
          return;
        }
        conflict(hunk, myChanges, theirChanges);
      }
      function removal(hunk, mine, their, swap) {
        var myChanges = collectChange(mine), theirChanges = collectContext(their, myChanges);
        if (theirChanges.merged) {
          var _hunk$lines6;
          (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));
        } else {
          conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
        }
      }
      function conflict(hunk, mine, their) {
        hunk.conflict = true;
        hunk.lines.push({
          conflict: true,
          mine,
          theirs: their
        });
      }
      function insertLeading(hunk, insert, their) {
        while (insert.offset < their.offset && insert.index < insert.lines.length) {
          var line = insert.lines[insert.index++];
          hunk.lines.push(line);
          insert.offset++;
        }
      }
      function insertTrailing(hunk, insert) {
        while (insert.index < insert.lines.length) {
          var line = insert.lines[insert.index++];
          hunk.lines.push(line);
        }
      }
      function collectChange(state) {
        var ret = [], operation = state.lines[state.index][0];
        while (state.index < state.lines.length) {
          var line = state.lines[state.index];
          if (operation === "-" && line[0] === "+") {
            operation = "+";
          }
          if (operation === line[0]) {
            ret.push(line);
            state.index++;
          } else {
            break;
          }
        }
        return ret;
      }
      function collectContext(state, matchChanges) {
        var changes = [], merged = [], matchIndex = 0, contextChanges = false, conflicted = false;
        while (matchIndex < matchChanges.length && state.index < state.lines.length) {
          var change = state.lines[state.index], match = matchChanges[matchIndex];
          if (match[0] === "+") {
            break;
          }
          contextChanges = contextChanges || change[0] !== " ";
          merged.push(match);
          matchIndex++;
          if (change[0] === "+") {
            conflicted = true;
            while (change[0] === "+") {
              changes.push(change);
              change = state.lines[++state.index];
            }
          }
          if (match.substr(1) === change.substr(1)) {
            changes.push(change);
            state.index++;
          } else {
            conflicted = true;
          }
        }
        if ((matchChanges[matchIndex] || "")[0] === "+" && contextChanges) {
          conflicted = true;
        }
        if (conflicted) {
          return changes;
        }
        while (matchIndex < matchChanges.length) {
          merged.push(matchChanges[matchIndex++]);
        }
        return {
          merged,
          changes
        };
      }
      function allRemoves(changes) {
        return changes.reduce(function(prev, change) {
          return prev && change[0] === "-";
        }, true);
      }
      function skipRemoveSuperset(state, removeChanges, delta) {
        for (var i = 0; i < delta; i++) {
          var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);
          if (state.lines[state.index + i] !== " " + changeContent) {
            return false;
          }
        }
        state.index += delta;
        return true;
      }
      function calcOldNewLineCount(lines) {
        var oldLines = 0;
        var newLines = 0;
        lines.forEach(function(line) {
          if (typeof line !== "string") {
            var myCount = calcOldNewLineCount(line.mine);
            var theirCount = calcOldNewLineCount(line.theirs);
            if (oldLines !== void 0) {
              if (myCount.oldLines === theirCount.oldLines) {
                oldLines += myCount.oldLines;
              } else {
                oldLines = void 0;
              }
            }
            if (newLines !== void 0) {
              if (myCount.newLines === theirCount.newLines) {
                newLines += myCount.newLines;
              } else {
                newLines = void 0;
              }
            }
          } else {
            if (newLines !== void 0 && (line[0] === "+" || line[0] === " ")) {
              newLines++;
            }
            if (oldLines !== void 0 && (line[0] === "-" || line[0] === " ")) {
              oldLines++;
            }
          }
        });
        return {
          oldLines,
          newLines
        };
      }
      function convertChangesToDMP(changes) {
        var ret = [], change, operation;
        for (var i = 0; i < changes.length; i++) {
          change = changes[i];
          if (change.added) {
            operation = 1;
          } else if (change.removed) {
            operation = -1;
          } else {
            operation = 0;
          }
          ret.push([operation, change.value]);
        }
        return ret;
      }
      function convertChangesToXML(changes) {
        var ret = [];
        for (var i = 0; i < changes.length; i++) {
          var change = changes[i];
          if (change.added) {
            ret.push("<ins>");
          } else if (change.removed) {
            ret.push("<del>");
          }
          ret.push(escapeHTML(change.value));
          if (change.added) {
            ret.push("</ins>");
          } else if (change.removed) {
            ret.push("</del>");
          }
        }
        return ret.join("");
      }
      function escapeHTML(s) {
        var n = s;
        n = n.replace(/&/g, "&amp;");
        n = n.replace(/</g, "&lt;");
        n = n.replace(/>/g, "&gt;");
        n = n.replace(/"/g, "&quot;");
        return n;
      }
      exports2.Diff = Diff;
      exports2.diffChars = diffChars;
      exports2.diffWords = diffWords;
      exports2.diffWordsWithSpace = diffWordsWithSpace;
      exports2.diffLines = diffLines;
      exports2.diffTrimmedLines = diffTrimmedLines;
      exports2.diffSentences = diffSentences;
      exports2.diffCss = diffCss;
      exports2.diffJson = diffJson;
      exports2.diffArrays = diffArrays;
      exports2.structuredPatch = structuredPatch;
      exports2.createTwoFilesPatch = createTwoFilesPatch;
      exports2.createPatch = createPatch;
      exports2.applyPatch = applyPatch;
      exports2.applyPatches = applyPatches;
      exports2.parsePatch = parsePatch;
      exports2.merge = merge;
      exports2.convertChangesToDMP = convertChangesToDMP;
      exports2.convertChangesToXML = convertChangesToXML;
      exports2.canonicalize = canonicalize;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/ua-parser-js/src/ua-parser.js
var require_ua_parser = __commonJS({
  "node_modules/ua-parser-js/src/ua-parser.js"(exports, module) {
    (function(window2, undefined2) {
      "use strict";
      var LIBVERSION = "0.7.40", EMPTY = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 500;
      var AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", BROWSER = "Browser", CHROME = "Chrome", EDGE = "Edge", FIREFOX = "Firefox", GOOGLE = "Google", HUAWEI = "Huawei", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", OPERA = "Opera", SAMSUNG = "Samsung", SHARP = "Sharp", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", FACEBOOK = "Facebook", CHROMIUM_OS = "Chromium OS", MAC_OS = "Mac OS", SUFFIX_BROWSER = " Browser";
      var extend = function(regexes2, extensions) {
        var mergedRegexes = {};
        for (var i in regexes2) {
          if (extensions[i] && extensions[i].length % 2 === 0) {
            mergedRegexes[i] = extensions[i].concat(regexes2[i]);
          } else {
            mergedRegexes[i] = regexes2[i];
          }
        }
        return mergedRegexes;
      }, enumerize = function(arr) {
        var enums = {};
        for (var i = 0; i < arr.length; i++) {
          enums[arr[i].toUpperCase()] = arr[i];
        }
        return enums;
      }, has = function(str1, str2) {
        return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
      }, lowerize = function(str) {
        return str.toLowerCase();
      }, majorize = function(version) {
        return typeof version === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split(".")[0] : undefined2;
      }, trim = function(str, len) {
        if (typeof str === STR_TYPE) {
          str = str.replace(/^\s\s*/, EMPTY);
          return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
        }
      };
      var rgxMapper = function(ua, arrays) {
        var i = 0, j, k, p, q, matches, match;
        while (i < arrays.length && !matches) {
          var regex = arrays[i], props = arrays[i + 1];
          j = k = 0;
          while (j < regex.length && !matches) {
            if (!regex[j]) {
              break;
            }
            matches = regex[j++].exec(ua);
            if (!!matches) {
              for (p = 0; p < props.length; p++) {
                match = matches[++k];
                q = props[p];
                if (typeof q === OBJ_TYPE && q.length > 0) {
                  if (q.length === 2) {
                    if (typeof q[1] == FUNC_TYPE) {
                      this[q[0]] = q[1].call(this, match);
                    } else {
                      this[q[0]] = q[1];
                    }
                  } else if (q.length === 3) {
                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                      this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined2;
                    } else {
                      this[q[0]] = match ? match.replace(q[1], q[2]) : undefined2;
                    }
                  } else if (q.length === 4) {
                    this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined2;
                  }
                } else {
                  this[q] = match ? match : undefined2;
                }
              }
            }
          }
          i += 2;
        }
      }, strMapper = function(str, map) {
        for (var i in map) {
          if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
            for (var j = 0; j < map[i].length; j++) {
              if (has(map[i][j], str)) {
                return i === UNKNOWN ? undefined2 : i;
              }
            }
          } else if (has(map[i], str)) {
            return i === UNKNOWN ? undefined2 : i;
          }
        }
        return map.hasOwnProperty("*") ? map["*"] : str;
      };
      var oldSafariMap = {
        "1.0": "/8",
        "1.2": "/1",
        "1.3": "/3",
        "2.0": "/412",
        "2.0.2": "/416",
        "2.0.3": "/417",
        "2.0.4": "/419",
        "?": "/"
      }, windowsVersionMap = {
        "ME": "4.90",
        "NT 3.11": "NT3.51",
        "NT 4.0": "NT4.0",
        "2000": "NT 5.0",
        "XP": ["NT 5.1", "NT 5.2"],
        "Vista": "NT 6.0",
        "7": "NT 6.1",
        "8": "NT 6.2",
        "8.1": "NT 6.3",
        "10": ["NT 6.4", "NT 10.0"],
        "RT": "ARM"
      };
      var regexes = {
        browser: [
          [
            /\b(?:crmo|crios)\/([\w\.]+)/i
            // Chrome for Android/iOS
          ],
          [VERSION, [NAME, "Chrome"]],
          [
            /edg(?:e|ios|a)?\/([\w\.]+)/i
            // Microsoft Edge
          ],
          [VERSION, [NAME, "Edge"]],
          [
            // Presto based
            /(opera mini)\/([-\w\.]+)/i,
            // Opera Mini
            /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
            // Opera Mobi/Tablet
            /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
            // Opera
          ],
          [NAME, VERSION],
          [
            /opios[\/ ]+([\w\.]+)/i
            // Opera mini on iphone >= 8.0
          ],
          [VERSION, [NAME, OPERA + " Mini"]],
          [
            /\bop(?:rg)?x\/([\w\.]+)/i
            // Opera GX
          ],
          [VERSION, [NAME, OPERA + " GX"]],
          [
            /\bopr\/([\w\.]+)/i
            // Opera Webkit
          ],
          [VERSION, [NAME, OPERA]],
          [
            // Mixed
            /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i
            // Baidu
          ],
          [VERSION, [NAME, "Baidu"]],
          [
            /\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i
            // Maxthon
          ],
          [VERSION, [NAME, "Maxthon"]],
          [
            /(kindle)\/([\w\.]+)/i,
            // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i,
            // Lunascape/Maxthon/Netfront/Jasmine/Blazer/Sleipnir
            // Trident based
            /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i,
            // Avant/IEMobile/SlimBrowser/SlimBoat/Slimjet
            /(?:ms|\()(ie) ([\w\.]+)/i,
            // Internet Explorer
            // Blink/Webkit/KHTML based                                         // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
            /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon)\/([-\w\.]+)/i,
            // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ//Vivaldi/DuckDuckGo/Klar/Helio/Dragon
            /(heytap|ovi|115)browser\/([\d\.]+)/i,
            // HeyTap/Ovi/115
            /(weibo)__([\d\.]+)/i
            // Weibo
          ],
          [NAME, VERSION],
          [
            /quark(?:pc)?\/([-\w\.]+)/i
            // Quark
          ],
          [VERSION, [NAME, "Quark"]],
          [
            /\bddg\/([\w\.]+)/i
            // DuckDuckGo
          ],
          [VERSION, [NAME, "DuckDuckGo"]],
          [
            /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i
            // UCBrowser
          ],
          [VERSION, [NAME, "UC" + BROWSER]],
          [
            /microm.+\bqbcore\/([\w\.]+)/i,
            // WeChat Desktop for Windows Built-in Browser
            /\bqbcore\/([\w\.]+).+microm/i,
            /micromessenger\/([\w\.]+)/i
            // WeChat
          ],
          [VERSION, [NAME, "WeChat"]],
          [
            /konqueror\/([\w\.]+)/i
            // Konqueror
          ],
          [VERSION, [NAME, "Konqueror"]],
          [
            /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i
            // IE11
          ],
          [VERSION, [NAME, "IE"]],
          [
            /ya(?:search)?browser\/([\w\.]+)/i
            // Yandex
          ],
          [VERSION, [NAME, "Yandex"]],
          [
            /slbrowser\/([\w\.]+)/i
            // Smart Lenovo Browser
          ],
          [VERSION, [NAME, "Smart Lenovo " + BROWSER]],
          [
            /(avast|avg)\/([\w\.]+)/i
            // Avast/AVG Secure Browser
          ],
          [[NAME, /(.+)/, "$1 Secure " + BROWSER], VERSION],
          [
            /\bfocus\/([\w\.]+)/i
            // Firefox Focus
          ],
          [VERSION, [NAME, FIREFOX + " Focus"]],
          [
            /\bopt\/([\w\.]+)/i
            // Opera Touch
          ],
          [VERSION, [NAME, OPERA + " Touch"]],
          [
            /coc_coc\w+\/([\w\.]+)/i
            // Coc Coc Browser
          ],
          [VERSION, [NAME, "Coc Coc"]],
          [
            /dolfin\/([\w\.]+)/i
            // Dolphin
          ],
          [VERSION, [NAME, "Dolphin"]],
          [
            /coast\/([\w\.]+)/i
            // Opera Coast
          ],
          [VERSION, [NAME, OPERA + " Coast"]],
          [
            /miuibrowser\/([\w\.]+)/i
            // MIUI Browser
          ],
          [VERSION, [NAME, "MIUI" + SUFFIX_BROWSER]],
          [
            /fxios\/([\w\.-]+)/i
            // Firefox for iOS
          ],
          [VERSION, [NAME, FIREFOX]],
          [
            /\bqihoobrowser\/?([\w\.]*)/i
            // 360
          ],
          [VERSION, [NAME, "360"]],
          [
            /\b(qq)\/([\w\.]+)/i
            // QQ
          ],
          [[NAME, /(.+)/, "$1Browser"], VERSION],
          [
            /(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i
          ],
          [[NAME, /(.+)/, "$1" + SUFFIX_BROWSER], VERSION],
          [
            // Oculus/Sailfish/HuaweiBrowser/VivoBrowser/PicoBrowser
            /samsungbrowser\/([\w\.]+)/i
            // Samsung Internet
          ],
          [VERSION, [NAME, SAMSUNG + " Internet"]],
          [
            /metasr[\/ ]?([\d\.]+)/i
            // Sogou Explorer
          ],
          [VERSION, [NAME, "Sogou Explorer"]],
          [
            /(sogou)mo\w+\/([\d\.]+)/i
            // Sogou Mobile
          ],
          [[NAME, "Sogou Mobile"], VERSION],
          [
            /(electron)\/([\w\.]+) safari/i,
            // Electron-based App
            /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
            // Tesla
            /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i
            // QQ/2345
          ],
          [NAME, VERSION],
          [
            /(lbbrowser|rekonq)/i,
            // LieBao Browser/Rekonq
            /\[(linkedin)app\]/i
            // LinkedIn App for iOS & Android
          ],
          [NAME],
          [
            /ome\/([\w\.]+) \w* ?(iron) saf/i,
            // Iron
            /ome\/([\w\.]+).+qihu (360)[es]e/i
            // 360
          ],
          [VERSION, NAME],
          [
            // WebView
            /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i
            // Facebook App for iOS & Android
          ],
          [[NAME, FACEBOOK], VERSION],
          [
            /(Klarna)\/([\w\.]+)/i,
            // Klarna Shopping Browser for iOS & Android
            /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
            // Kakao App
            /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
            // Naver InApp
            /safari (line)\/([\w\.]+)/i,
            // Line App for iOS
            /\b(line)\/([\w\.]+)\/iab/i,
            // Line App for Android
            /(alipay)client\/([\w\.]+)/i,
            // Alipay
            /(twitter)(?:and| f.+e\/([\w\.]+))/i,
            // Twitter
            /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i
            // Chromium/Instagram/Snapchat
          ],
          [NAME, VERSION],
          [
            /\bgsa\/([\w\.]+) .*safari\//i
            // Google Search Appliance on iOS
          ],
          [VERSION, [NAME, "GSA"]],
          [
            /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i
            // TikTok
          ],
          [VERSION, [NAME, "TikTok"]],
          [
            /headlesschrome(?:\/([\w\.]+)| )/i
            // Chrome Headless
          ],
          [VERSION, [NAME, CHROME + " Headless"]],
          [
            / wv\).+(chrome)\/([\w\.]+)/i
            // Chrome WebView
          ],
          [[NAME, CHROME + " WebView"], VERSION],
          [
            /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i
            // Android Browser
          ],
          [VERSION, [NAME, "Android " + BROWSER]],
          [
            /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i
            // Chrome/OmniWeb/Arora/Tizen/Nokia
          ],
          [NAME, VERSION],
          [
            /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i
            // Mobile Safari
          ],
          [VERSION, [NAME, "Mobile Safari"]],
          [
            /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i
            // Safari & Safari Mobile
          ],
          [VERSION, NAME],
          [
            /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i
            // Safari < 3.0
          ],
          [NAME, [VERSION, strMapper, oldSafariMap]],
          [
            /(webkit|khtml)\/([\w\.]+)/i
          ],
          [NAME, VERSION],
          [
            // Gecko based
            /(navigator|netscape\d?)\/([-\w\.]+)/i
            // Netscape
          ],
          [[NAME, "Netscape"], VERSION],
          [
            /(wolvic|librewolf)\/([\w\.]+)/i
            // Wolvic/LibreWolf
          ],
          [NAME, VERSION],
          [
            /mobile vr; rv:([\w\.]+)\).+firefox/i
            // Firefox Reality
          ],
          [VERSION, [NAME, FIREFOX + " Reality"]],
          [
            /ekiohf.+(flow)\/([\w\.]+)/i,
            // Flow
            /(swiftfox)/i,
            // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i,
            // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
            /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
            // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(firefox)\/([\w\.]+)/i,
            // Other Firefox-based
            /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
            // Mozilla
            // Other
            /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
            // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Obigo/Mosaic/Go/ICE/UP.Browser
            /(links) \(([\w\.]+)/i
            // Links
          ],
          [NAME, [VERSION, /_/g, "."]],
          [
            /(cobalt)\/([\w\.]+)/i
            // Cobalt
          ],
          [NAME, [VERSION, /master.|lts./, ""]]
        ],
        cpu: [
          [
            /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i
            // AMD64 (x64)
          ],
          [[ARCHITECTURE, "amd64"]],
          [
            /(ia32(?=;))/i
            // IA32 (quicktime)
          ],
          [[ARCHITECTURE, lowerize]],
          [
            /((?:i[346]|x)86)[;\)]/i
            // IA32 (x86)
          ],
          [[ARCHITECTURE, "ia32"]],
          [
            /\b(aarch64|arm(v?8e?l?|_?64))\b/i
            // ARM64
          ],
          [[ARCHITECTURE, "arm64"]],
          [
            /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i
            // ARMHF
          ],
          [[ARCHITECTURE, "armhf"]],
          [
            // PocketPC mistakenly identified as PowerPC
            /windows (ce|mobile); ppc;/i
          ],
          [[ARCHITECTURE, "arm"]],
          [
            /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i
            // PowerPC
          ],
          [[ARCHITECTURE, /ower/, EMPTY, lowerize]],
          [
            /(sun4\w)[;\)]/i
            // SPARC
          ],
          [[ARCHITECTURE, "sparc"]],
          [
            /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
            // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
          ],
          [[ARCHITECTURE, lowerize]]
        ],
        device: [
          [
            //////////////////////////
            // MOBILES & TABLETS
            /////////////////////////
            // Samsung
            /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]],
          [
            /\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
            /samsung[- ]((?!sm-[lr])[-\w]+)/i,
            /sec-(sgh\w+)/i
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]],
          [
            // Apple
            /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i
            // iPod/iPhone
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]],
          [
            /\((ipad);[-\w\),; ]+apple/i,
            // iPad
            /applecoremedia\/[\w\.]+ \((ipad)/i,
            /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, TABLET]],
          [
            /(macintosh);/i
          ],
          [MODEL, [VENDOR, APPLE]],
          [
            // Sharp
            /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
          ],
          [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]],
          [
            // Honor
            /(?:honor)([-\w ]+)[;\)]/i
          ],
          [MODEL, [VENDOR, "Honor"], [TYPE, MOBILE]],
          [
            // Huawei
            /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
          ],
          [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]],
          [
            /(?:huawei)([-\w ]+)[;\)]/i,
            /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
          ],
          [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]],
          [
            // Xiaomi
            /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,
            // Xiaomi POCO
            /\b; (\w+) build\/hm\1/i,
            // Xiaomi Hongmi 'numeric' models
            /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
            // Xiaomi Hongmi
            /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
            // Xiaomi Redmi
            /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,
            // Xiaomi Redmi 'numeric' models
            /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i
            // Xiaomi Mi
          ],
          [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]],
          [
            /oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i,
            // Redmi Pad
            /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i
            // Mi Pad tablets
          ],
          [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]],
          [
            // OPPO
            /; (\w+) bui.+ oppo/i,
            /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
          ],
          [MODEL, [VENDOR, "OPPO"], [TYPE, MOBILE]],
          [
            /\b(opd2\d{3}a?) bui/i
          ],
          [MODEL, [VENDOR, "OPPO"], [TYPE, TABLET]],
          [
            // Vivo
            /vivo (\w+)(?: bui|\))/i,
            /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
          ],
          [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]],
          [
            // Realme
            /\b(rmx[1-3]\d{3})(?: bui|;|\))/i
          ],
          [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]],
          [
            // Motorola
            /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
            /\bmot(?:orola)?[- ](\w*)/i,
            /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]],
          [
            /\b(mz60\d|xoom[2 ]{0,2}) build\//i
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]],
          [
            // LG
            /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
          ],
          [MODEL, [VENDOR, LG], [TYPE, TABLET]],
          [
            /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
            /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
            /\blg-?([\d\w]+) bui/i
          ],
          [MODEL, [VENDOR, LG], [TYPE, MOBILE]],
          [
            // Lenovo
            /(ideatab[-\w ]+)/i,
            /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
          ],
          [MODEL, [VENDOR, "Lenovo"], [TYPE, TABLET]],
          [
            // Nokia
            /(?:maemo|nokia).*(n900|lumia \d+)/i,
            /nokia[-_ ]?([-\w\.]*)/i
          ],
          [[MODEL, /_/g, " "], [VENDOR, "Nokia"], [TYPE, MOBILE]],
          [
            // Google
            /(pixel c)\b/i
            // Google Pixel C
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]],
          [
            /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i
            // Google Pixel
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]],
          [
            // Sony
            /droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
          ],
          [MODEL, [VENDOR, SONY], [TYPE, MOBILE]],
          [
            /sony tablet [ps]/i,
            /\b(?:sony)?sgp\w+(?: bui|\))/i
          ],
          [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]],
          [
            // OnePlus
            / (kb2005|in20[12]5|be20[12][59])\b/i,
            /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
          ],
          [MODEL, [VENDOR, "OnePlus"], [TYPE, MOBILE]],
          [
            // Amazon
            /(alexa)webm/i,
            /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i,
            // Kindle Fire without Silk / Echo Show
            /(kf[a-z]+)( bui|\)).+silk\//i
            // Kindle Fire HD
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]],
          [
            /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i
            // Fire Phone
          ],
          [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]],
          [
            // BlackBerry
            /(playbook);[-\w\),; ]+(rim)/i
            // BlackBerry PlayBook
          ],
          [MODEL, VENDOR, [TYPE, TABLET]],
          [
            /\b((?:bb[a-f]|st[hv])100-\d)/i,
            /\(bb10; (\w+)/i
            // BlackBerry 10
          ],
          [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]],
          [
            // Asus
            /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
          ],
          [MODEL, [VENDOR, ASUS], [TYPE, TABLET]],
          [
            / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
          ],
          [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]],
          [
            // HTC
            /(nexus 9)/i
            // HTC Nexus 9
          ],
          [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]],
          [
            /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
            // HTC
            // ZTE
            /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
            /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i
            // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
          ],
          [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]],
          [
            // TCL
            /droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\w*(\)| bui)/i
          ],
          [MODEL, [VENDOR, "TCL"], [TYPE, TABLET]],
          [
            // itel
            /(itel) ((\w+))/i
          ],
          [[VENDOR, lowerize], MODEL, [TYPE, strMapper, { "tablet": ["p10001l", "w7001"], "*": "mobile" }]],
          [
            // Acer
            /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
          ],
          [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]],
          [
            // Meizu
            /droid.+; (m[1-5] note) bui/i,
            /\bmz-([-\w]{2,})/i
          ],
          [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]],
          [
            // Ulefone
            /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Ulefone"], [TYPE, MOBILE]],
          [
            // Energizer
            /; (energy ?\w+)(?: bui|\))/i,
            /; energizer ([\w ]+)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Energizer"], [TYPE, MOBILE]],
          [
            // Cat
            /; cat (b35);/i,
            /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Cat"], [TYPE, MOBILE]],
          [
            // Smartfren
            /((?:new )?andromax[\w- ]+)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Smartfren"], [TYPE, MOBILE]],
          [
            // Nothing
            /droid.+; (a(?:015|06[35]|142p?))/i
          ],
          [MODEL, [VENDOR, "Nothing"], [TYPE, MOBILE]],
          [
            // MIXED
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\w]*)/i,
            // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron/Infinix/Tecno/Micromax/Advan
            /; (imo) ((?!tab)[\w ]+?)(?: bui|\))/i,
            // IMO
            /(hp) ([\w ]+\w)/i,
            // HP iPAQ
            /(asus)-?(\w+)/i,
            // Asus
            /(microsoft); (lumia[\w ]+)/i,
            // Microsoft Lumia
            /(lenovo)[-_ ]?([-\w]+)/i,
            // Lenovo
            /(jolla)/i,
            // Jolla
            /(oppo) ?([\w ]+) bui/i
            // OPPO
          ],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [
            /(imo) (tab \w+)/i,
            // IMO
            /(kobo)\s(ereader|touch)/i,
            // Kobo
            /(archos) (gamepad2?)/i,
            // Archos
            /(hp).+(touchpad(?!.+tablet)|tablet)/i,
            // HP TouchPad
            /(kindle)\/([\w\.]+)/i,
            // Kindle
            /(nook)[\w ]+build\/(\w+)/i,
            // Nook
            /(dell) (strea[kpr\d ]*[\dko])/i,
            // Dell Streak
            /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
            // Le Pan Tablets
            /(trinity)[- ]*(t\d{3}) bui/i,
            // Trinity Tablets
            /(gigaset)[- ]+(q\w{1,9}) bui/i,
            // Gigaset Tablets
            /(vodafone) ([\w ]+)(?:\)| bui)/i
            // Vodafone
          ],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [
            /(surface duo)/i
            // Surface Duo
          ],
          [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]],
          [
            /droid [\d\.]+; (fp\du?)(?: b|\))/i
            // Fairphone
          ],
          [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]],
          [
            /(u304aa)/i
            // AT&T
          ],
          [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]],
          [
            /\bsie-(\w*)/i
            // Siemens
          ],
          [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]],
          [
            /\b(rct\w+) b/i
            // RCA Tablets
          ],
          [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]],
          [
            /\b(venue[\d ]{2,7}) b/i
            // Dell Venue Tablets
          ],
          [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]],
          [
            /\b(q(?:mv|ta)\w+) b/i
            // Verizon Tablet
          ],
          [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]],
          [
            /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i
            // Barnes & Noble Tablet
          ],
          [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]],
          [
            /\b(tm\d{3}\w+) b/i
          ],
          [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]],
          [
            /\b(k88) b/i
            // ZTE K Series Tablet
          ],
          [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]],
          [
            /\b(nx\d{3}j) b/i
            // ZTE Nubia
          ],
          [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]],
          [
            /\b(gen\d{3}) b.+49h/i
            // Swiss GEN Mobile
          ],
          [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]],
          [
            /\b(zur\d{3}) b/i
            // Swiss ZUR Tablet
          ],
          [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]],
          [
            /\b((zeki)?tb.*\b) b/i
            // Zeki Tablets
          ],
          [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]],
          [
            /\b([yr]\d{2}) b/i,
            /\b(dragon[- ]+touch |dt)(\w{5}) b/i
            // Dragon Touch Tablet
          ],
          [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]],
          [
            /\b(ns-?\w{0,9}) b/i
            // Insignia Tablets
          ],
          [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]],
          [
            /\b((nxa|next)-?\w{0,9}) b/i
            // NextBook Tablets
          ],
          [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]],
          [
            /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i
            // Voice Xtreme Phones
          ],
          [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]],
          [
            /\b(lvtel\-)?(v1[12]) b/i
            // LvTel Phones
          ],
          [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]],
          [
            /\b(ph-1) /i
            // Essential PH-1
          ],
          [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]],
          [
            /\b(v(100md|700na|7011|917g).*\b) b/i
            // Envizen Tablets
          ],
          [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]],
          [
            /\b(trio[-\w\. ]+) b/i
            // MachSpeed Tablets
          ],
          [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]],
          [
            /\btu_(1491) b/i
            // Rotor Tablets
          ],
          [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]],
          [
            /(shield[\w ]+) b/i
            // Nvidia Shield Tablets
          ],
          [MODEL, [VENDOR, "Nvidia"], [TYPE, TABLET]],
          [
            /(sprint) (\w+)/i
            // Sprint Phones
          ],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [
            /(kin\.[onetw]{3})/i
            // Microsoft Kin
          ],
          [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]],
          [
            /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i
            // Zebra
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]],
          [
            /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]],
          [
            ///////////////////
            // SMARTTVS
            ///////////////////
            /smart-tv.+(samsung)/i
            // Samsung
          ],
          [VENDOR, [TYPE, SMARTTV]],
          [
            /hbbtv.+maple;(\d+)/i
          ],
          [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]],
          [
            /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
            // LG SmartTV
          ],
          [[VENDOR, LG], [TYPE, SMARTTV]],
          [
            /(apple) ?tv/i
            // Apple TV
          ],
          [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]],
          [
            /crkey/i
            // Google Chromecast
          ],
          [[MODEL, CHROME + "cast"], [VENDOR, GOOGLE], [TYPE, SMARTTV]],
          [
            /droid.+aft(\w+)( bui|\))/i
            // Fire TV
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]],
          [
            /\(dtv[\);].+(aquos)/i,
            /(aquos-tv[\w ]+)\)/i
            // Sharp
          ],
          [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],
          [
            /(bravia[\w ]+)( bui|\))/i
            // Sony
          ],
          [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]],
          [
            /(mitv-\w{5}) bui/i
            // Xiaomi
          ],
          [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]],
          [
            /Hbbtv.*(technisat) (.*);/i
            // TechniSAT
          ],
          [VENDOR, MODEL, [TYPE, SMARTTV]],
          [
            /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
            // Roku
            /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i
            // HbbTV devices
          ],
          [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]],
          [
            /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i
            // SmartTV from Unidentified Vendors
          ],
          [[TYPE, SMARTTV]],
          [
            ///////////////////
            // CONSOLES
            ///////////////////
            /(ouya)/i,
            // Ouya
            /(nintendo) ([wids3utch]+)/i
            // Nintendo
          ],
          [VENDOR, MODEL, [TYPE, CONSOLE]],
          [
            /droid.+; (shield) bui/i
            // Nvidia
          ],
          [MODEL, [VENDOR, "Nvidia"], [TYPE, CONSOLE]],
          [
            /(playstation [345portablevi]+)/i
            // Playstation
          ],
          [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]],
          [
            /\b(xbox(?: one)?(?!; xbox))[\); ]/i
            // Microsoft Xbox
          ],
          [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]],
          [
            ///////////////////
            // WEARABLES
            ///////////////////
            /\b(sm-[lr]\d\d[05][fnuw]?s?)\b/i
            // Samsung Galaxy Watch
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, WEARABLE]],
          [
            /((pebble))app/i
            // Pebble
          ],
          [VENDOR, MODEL, [TYPE, WEARABLE]],
          [
            /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i
            // Apple Watch
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]],
          [
            /droid.+; (glass) \d/i
            // Google Glass
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]],
          [
            /droid.+; (wt63?0{2,3})\)/i
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]],
          [
            ///////////////////
            // XR
            ///////////////////
            /droid.+; (glass) \d/i
            // Google Glass
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]],
          [
            /(pico) (4|neo3(?: link|pro)?)/i
            // Pico
          ],
          [VENDOR, MODEL, [TYPE, WEARABLE]],
          [
            /; (quest( \d| pro)?)/i
            // Oculus Quest
          ],
          [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]],
          [
            ///////////////////
            // EMBEDDED
            ///////////////////
            /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i
            // Tesla
          ],
          [VENDOR, [TYPE, EMBEDDED]],
          [
            /(aeobc)\b/i
            // Echo Dot
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]],
          [
            ////////////////////
            // MIXED (GENERIC)
            ///////////////////
            /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i
            // Android Phones from Unidentified Vendors
          ],
          [MODEL, [TYPE, MOBILE]],
          [
            /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i
            // Android Tablets from Unidentified Vendors
          ],
          [MODEL, [TYPE, TABLET]],
          [
            /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i
            // Unidentifiable Tablet
          ],
          [[TYPE, TABLET]],
          [
            /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i
            // Unidentifiable Mobile
          ],
          [[TYPE, MOBILE]],
          [
            /(android[-\w\. ]{0,9});.+buil/i
            // Generic Android Device
          ],
          [MODEL, [VENDOR, "Generic"]]
        ],
        engine: [
          [
            /windows.+ edge\/([\w\.]+)/i
            // EdgeHTML
          ],
          [VERSION, [NAME, EDGE + "HTML"]],
          [
            /(arkweb)\/([\w\.]+)/i
            // ArkWeb
          ],
          [NAME, VERSION],
          [
            /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i
            // Blink
          ],
          [VERSION, [NAME, "Blink"]],
          [
            /(presto)\/([\w\.]+)/i,
            // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i,
            // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna/Servo
            /ekioh(flow)\/([\w\.]+)/i,
            // Flow
            /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
            // KHTML/Tasman/Links
            /(icab)[\/ ]([23]\.[\d\.]+)/i,
            // iCab
            /\b(libweb)/i
          ],
          [NAME, VERSION],
          [
            /rv\:([\w\.]{1,9})\b.+(gecko)/i
            // Gecko
          ],
          [VERSION, NAME]
        ],
        os: [
          [
            // Windows
            /microsoft (windows) (vista|xp)/i
            // Windows (iTunes)
          ],
          [NAME, VERSION],
          [
            /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i
            // Windows Phone
          ],
          [NAME, [VERSION, strMapper, windowsVersionMap]],
          [
            /windows nt 6\.2; (arm)/i,
            // Windows RT
            /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i,
            /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i
          ],
          [[VERSION, strMapper, windowsVersionMap], [NAME, "Windows"]],
          [
            // iOS/macOS
            /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
            // iOS
            /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i,
            /cfnetwork\/.+darwin/i
          ],
          [[VERSION, /_/g, "."], [NAME, "iOS"]],
          [
            /(mac os x) ?([\w\. ]*)/i,
            /(macintosh|mac_powerpc\b)(?!.+haiku)/i
            // Mac OS
          ],
          [[NAME, MAC_OS], [VERSION, /_/g, "."]],
          [
            // Mobile OSes
            /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i
            // Android-x86/HarmonyOS
          ],
          [VERSION, NAME],
          [
            // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS/OpenHarmony
            /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish|openharmony)[-\/ ]?([\w\.]*)/i,
            /(blackberry)\w*\/([\w\.]*)/i,
            // Blackberry
            /(tizen|kaios)[\/ ]([\w\.]+)/i,
            // Tizen/KaiOS
            /\((series40);/i
            // Series 40
          ],
          [NAME, VERSION],
          [
            /\(bb(10);/i
            // BlackBerry 10
          ],
          [VERSION, [NAME, BLACKBERRY]],
          [
            /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i
            // Symbian
          ],
          [VERSION, [NAME, "Symbian"]],
          [
            /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i
            // Firefox OS
          ],
          [VERSION, [NAME, FIREFOX + " OS"]],
          [
            /web0s;.+rt(tv)/i,
            /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i
            // WebOS
          ],
          [VERSION, [NAME, "webOS"]],
          [
            /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i
            // watchOS
          ],
          [VERSION, [NAME, "watchOS"]],
          [
            // Google Chromecast
            /crkey\/([\d\.]+)/i
            // Google Chromecast
          ],
          [VERSION, [NAME, CHROME + "cast"]],
          [
            /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i
            // Chromium OS
          ],
          [[NAME, CHROMIUM_OS], VERSION],
          [
            // Smart TVs
            /panasonic;(viera)/i,
            // Panasonic Viera
            /(netrange)mmh/i,
            // Netrange
            /(nettv)\/(\d+\.[\w\.]+)/i,
            // NetTV
            // Console
            /(nintendo|playstation) ([wids345portablevuch]+)/i,
            // Nintendo/Playstation
            /(xbox); +xbox ([^\);]+)/i,
            // Microsoft Xbox (360, One, X, S, Series X, Series S)
            // Other
            /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
            // Joli/Palm
            /(mint)[\/\(\) ]?(\w*)/i,
            // Mint
            /(mageia|vectorlinux)[; ]/i,
            // Mageia/VectorLinux
            /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
            // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
            /(hurd|linux) ?([\w\.]*)/i,
            // Hurd/Linux
            /(gnu) ?([\w\.]*)/i,
            // GNU
            /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
            // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
            /(haiku) (\w+)/i
            // Haiku
          ],
          [NAME, VERSION],
          [
            /(sunos) ?([\w\.\d]*)/i
            // Solaris
          ],
          [[NAME, "Solaris"], VERSION],
          [
            /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
            // Solaris
            /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
            // AIX
            /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,
            // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS
            /(unix) ?([\w\.]*)/i
            // UNIX
          ],
          [NAME, VERSION]
        ]
      };
      var UAParser = function(ua, extensions) {
        if (typeof ua === OBJ_TYPE) {
          extensions = ua;
          ua = undefined2;
        }
        if (!(this instanceof UAParser)) {
          return new UAParser(ua, extensions).getResult();
        }
        var _navigator = typeof window2 !== UNDEF_TYPE && window2.navigator ? window2.navigator : undefined2;
        var _ua = ua || (_navigator && _navigator.userAgent ? _navigator.userAgent : EMPTY);
        var _uach = _navigator && _navigator.userAgentData ? _navigator.userAgentData : undefined2;
        var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
        var _isSelfNav = _navigator && _navigator.userAgent == _ua;
        this.getBrowser = function() {
          var _browser = {};
          _browser[NAME] = undefined2;
          _browser[VERSION] = undefined2;
          rgxMapper.call(_browser, _ua, _rgxmap.browser);
          _browser[MAJOR] = majorize(_browser[VERSION]);
          if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {
            _browser[NAME] = "Brave";
          }
          return _browser;
        };
        this.getCPU = function() {
          var _cpu = {};
          _cpu[ARCHITECTURE] = undefined2;
          rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
          return _cpu;
        };
        this.getDevice = function() {
          var _device = {};
          _device[VENDOR] = undefined2;
          _device[MODEL] = undefined2;
          _device[TYPE] = undefined2;
          rgxMapper.call(_device, _ua, _rgxmap.device);
          if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {
            _device[TYPE] = MOBILE;
          }
          if (_isSelfNav && _device[MODEL] == "Macintosh" && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {
            _device[MODEL] = "iPad";
            _device[TYPE] = TABLET;
          }
          return _device;
        };
        this.getEngine = function() {
          var _engine = {};
          _engine[NAME] = undefined2;
          _engine[VERSION] = undefined2;
          rgxMapper.call(_engine, _ua, _rgxmap.engine);
          return _engine;
        };
        this.getOS = function() {
          var _os = {};
          _os[NAME] = undefined2;
          _os[VERSION] = undefined2;
          rgxMapper.call(_os, _ua, _rgxmap.os);
          if (_isSelfNav && !_os[NAME] && _uach && _uach.platform && _uach.platform != "Unknown") {
            _os[NAME] = _uach.platform.replace(/chrome os/i, CHROMIUM_OS).replace(/macos/i, MAC_OS);
          }
          return _os;
        };
        this.getResult = function() {
          return {
            ua: this.getUA(),
            browser: this.getBrowser(),
            engine: this.getEngine(),
            os: this.getOS(),
            device: this.getDevice(),
            cpu: this.getCPU()
          };
        };
        this.getUA = function() {
          return _ua;
        };
        this.setUA = function(ua2) {
          _ua = typeof ua2 === STR_TYPE && ua2.length > UA_MAX_LENGTH ? trim(ua2, UA_MAX_LENGTH) : ua2;
          return this;
        };
        this.setUA(_ua);
        return this;
      };
      UAParser.VERSION = LIBVERSION;
      UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR]);
      UAParser.CPU = enumerize([ARCHITECTURE]);
      UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
      UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);
      if (typeof exports !== UNDEF_TYPE) {
        if (typeof module !== UNDEF_TYPE && module.exports) {
          exports = module.exports = UAParser;
        }
        exports.UAParser = UAParser;
      } else {
        if (typeof define === FUNC_TYPE && define.amd) {
          define(function() {
            return UAParser;
          });
        } else if (typeof window2 !== UNDEF_TYPE) {
          window2.UAParser = UAParser;
        }
      }
      var $ = typeof window2 !== UNDEF_TYPE && (window2.jQuery || window2.Zepto);
      if ($ && !$.ua) {
        var parser = new UAParser();
        $.ua = parser.getResult();
        $.ua.get = function() {
          return parser.getUA();
        };
        $.ua.set = function(ua) {
          parser.setUA(ua);
          var result = parser.getResult();
          for (var prop in result) {
            $.ua[prop] = result[prop];
          }
        };
      }
    })(typeof window === "object" ? window : exports);
  }
});

// node_modules/snack-sdk/build/transports/CodeMessageBuilder.js
var require_CodeMessageBuilder = __commonJS({
  "node_modules/snack-sdk/build/transports/CodeMessageBuilder.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFileDiff = void 0;
    var diff_1 = require_diff3();
    var snack_content_1 = require_build();
    var ua_parser_js_1 = require_ua_parser();
    var FileUploader_1 = __importDefault(require_FileUploader());
    var defaultConfig_1 = require_defaultConfig();
    var SnackIdentityCode = {
      files: defaultConfig_1.SnackIdentityState.files,
      dependencies: defaultConfig_1.SnackIdentityState.dependencies,
      sdkVersion: defaultConfig_1.SnackIdentityState.sdkVersion
    };
    function getFileDiff(oldCode, newCode) {
      var patch = diff_1.createPatch("code", oldCode, newCode, "", "", {
        context: 0
      });
      if (patch) {
        return patch;
      } else {
        throw new Error("Error creating a file diff");
      }
    }
    exports.getFileDiff = getFileDiff;
    var PLACEHOLDER_URL = "https://snack-code-uploads.s3.us-west-1.amazonaws.com/~asset/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
    var CodeMessageBuilder = (
      /** @class */
      function() {
        function CodeMessageBuilder2(options) {
          var _this = this;
          this.code = SnackIdentityCode;
          this.placeholderURLs = {};
          this.uploadedURLs = {};
          this.onFileUploaded = function(request, resultURL, _error) {
            var path = request.path;
            delete _this.placeholderURLs[path];
            if (resultURL) {
              _this.uploadedURLs[path] = resultURL;
              if (!Object.keys(_this.placeholderURLs).length) {
                var codeMessage = _this.createCodeMessage(_this.code, _this.codeMessage, _this.code);
                if (_this.verifyCodeMessageSize(codeMessage)) {
                  _this.callback(codeMessage, _this.code);
                }
              }
            }
          };
          this.logger = options.logger;
          this.callback = options.callback;
          this.verifyCodeMessageSize = options.verifyCodeMessageSize;
          this.maxDiffPlaceholder = options.maxDiffPlaceholder;
          this.codeUploader = options.apiURL ? new FileUploader_1.default({
            apiURL: options.apiURL,
            logger: options.logger,
            callback: this.onFileUploaded
          }) : void 0;
        }
        CodeMessageBuilder2.prototype.setCode = function(code) {
          var _a, _b, _c;
          if (code === this.code) {
            return;
          }
          var prevCode = this.code;
          var files = code.files;
          this.code = code;
          for (var path in prevCode.files) {
            if (prevCode.files[path].contents !== ((_a = files[path]) === null || _a === void 0 ? void 0 : _a.contents)) {
              delete this.placeholderURLs[path];
              delete this.uploadedURLs[path];
              (_b = this.codeUploader) === null || _b === void 0 ? void 0 : _b.remove(path, prevCode.files[path]);
            }
          }
          var codeMessage = this.createCodeMessage(code, this.codeMessage, prevCode);
          this.codeMessage = codeMessage;
          if (this.verifyCodeMessageSize(codeMessage)) {
            if (!Object.keys(this.placeholderURLs).length) {
              this.callback(codeMessage, code);
            }
            return;
          }
          if (this.codeUploader) {
            var paths = Object.keys(files).filter(function(path2) {
              return files[path2].type === "CODE";
            }).sort(function(a, b) {
              return files[b].contents.length - files[a].contents.length;
            });
            for (var i = 0; i < paths.length; i++) {
              var path = paths[i];
              if (!this.uploadedURLs[path] && !this.placeholderURLs[path]) {
                var file = files[path];
                this.placeholderURLs[path] = PLACEHOLDER_URL;
                this.codeUploader.add(path, file);
                codeMessage.diff[path] = "";
                codeMessage.s3url[path] = this.placeholderURLs[path];
                if (this.verifyCodeMessageSize(codeMessage)) {
                  return;
                }
              }
            }
          }
          (_c = this.logger) === null || _c === void 0 ? void 0 : _c.error("Message size is too large");
        };
        CodeMessageBuilder2.prototype.createCodeMessage = function(code, prevCodeMessage, prevCode) {
          var files = code.files, dependencies = code.dependencies, sdkVersion = code.sdkVersion;
          var diff = __assign({}, files);
          var s3url = {};
          for (var path in files) {
            var file = files[path];
            if (this.uploadedURLs[path] || this.placeholderURLs[path]) {
              diff[path] = "";
              s3url[path] = this.uploadedURLs[path] || this.placeholderURLs[path];
            } else {
              if (file.type === "CODE") {
                if ((prevCodeMessage === null || prevCodeMessage === void 0 ? void 0 : prevCodeMessage.diff[path]) && (prevCode === null || prevCode === void 0 ? void 0 : prevCode.files[path].contents) === code.files[path].contents) {
                  diff[path] = prevCodeMessage.diff[path];
                } else {
                  if (this.maxDiffPlaceholder && file.contents.length >= this.maxDiffPlaceholder.length) {
                    diff[path] = this.maxDiffPlaceholder;
                  } else {
                    diff[path] = getFileDiff("", file.contents);
                  }
                }
              } else {
                diff[path] = "";
              }
              if (file.type === "ASSET" && typeof file.contents === "string") {
                s3url[path] = file.contents;
              }
            }
          }
          var deps = {};
          for (var name_1 in dependencies) {
            var dep = dependencies[name_1];
            if (dep.handle && !snack_content_1.isModulePreloaded(name_1, sdkVersion)) {
              deps[name_1] = {
                version: dep.version,
                handle: dep.handle,
                // Resolved has been replaced by handle. It is still needed for pre SDK 37 runtimes
                resolved: dep.handle.substring(dep.handle.lastIndexOf("@") + 1)
              };
            }
          }
          var metadata = {
            expoSDKVersion: code.sdkVersion
          };
          if (typeof navigator !== "undefined" && navigator.userAgent) {
            var ua = new ua_parser_js_1.UAParser(navigator.userAgent).getResult();
            metadata.webHostName = window.location.hostname;
            metadata.webOSArchitecture = ua.cpu.architecture;
            metadata.webOSFamily = ua.os.name;
            metadata.webOSVersion = ua.os.version;
            metadata.webLayoutEngine = ua.engine.name;
            metadata.webDeviceType = ua.device.type;
            metadata.webBrowser = ua.browser.name;
            metadata.webBrowserVersion = ua.browser.version;
          }
          return {
            type: "CODE",
            diff,
            s3url,
            dependencies: deps,
            metadata
          };
        };
        return CodeMessageBuilder2;
      }()
    );
    exports.default = CodeMessageBuilder;
  }
});

// node_modules/snack-sdk/build/transports/TransportImplBase.js
var require_TransportImplBase = __commonJS({
  "node_modules/snack-sdk/build/transports/TransportImplBase.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var CodeMessageBuilder_1 = __importDefault(require_CodeMessageBuilder());
    var Logger_1 = require_Logger();
    var TransportImplBase = (
      /** @class */
      function() {
        function TransportImplBase2(options) {
          var _this = this;
          this.connectionsCount = 0;
          this.onCodeMessageReady = function(codeMessage) {
            var _a;
            _this.codeMessage = codeMessage;
            (_a = _this.logger) === null || _a === void 0 ? void 0 : _a.comm("Sending code...", _this.logSuffix);
            _this.publish(codeMessage);
          };
          var apiURL = options.apiURL, channel = options.channel, verbose = options.verbose;
          this.channel = channel !== null && channel !== void 0 ? channel : "";
          this.logger = verbose ? Logger_1.createLogger(true) : void 0;
          this.logSuffix = options.name ? " (" + options.name + ")" : "";
          if (channel) {
            this.codeMessageBuilder = new CodeMessageBuilder_1.default({
              verifyCodeMessageSize: this.onVerifyCodeMessageSize,
              callback: this.onCodeMessageReady,
              apiURL,
              logger: this.logger,
              maxDiffPlaceholder: "X".repeat(TransportImplBase2.CODE_SIZE_LIMIT_FOR_DIFF)
            });
          } else {
            this.codeMessageBuilder = new CodeMessageBuilder_1.default({
              verifyCodeMessageSize: function() {
                return true;
              },
              callback: this.onCodeMessageReady,
              logger: this.logger
            });
          }
        }
        TransportImplBase2.prototype.addEventListener = function(_type, callback) {
          this.callback = callback;
        };
        TransportImplBase2.prototype.removeEventListener = function(_type, _callback) {
          this.callback = void 0;
        };
        TransportImplBase2.prototype.postMessage = function(message) {
          switch (message.type) {
            case "start":
              this.start();
              break;
            case "stop":
              this.stop();
              break;
            case "update_code":
              this.codeMessageBuilder.setCode(message.data);
              break;
            case "protocol_message":
              this.publish(message.data);
              break;
            case "synthetic_event":
              this.onSyntheticEvent(message.data);
              break;
          }
        };
        TransportImplBase2.prototype.handleMessage = function(senderConnectionId, message) {
          this.onProtocolMessage(senderConnectionId, message);
        };
        TransportImplBase2.prototype.handleChannelEvent = function(event, connectionId) {
          var _a, _b, _c;
          if (event === "join") {
            try {
              var device = JSON.parse(connectionId);
              this.connectionsCount++;
              (_a = this.callback) === null || _a === void 0 ? void 0 : _a.call(this, {
                type: "connect",
                connectionId,
                data: device
              });
              if (this.codeMessage) {
                (_b = this.logger) === null || _b === void 0 ? void 0 : _b.comm("Sending code...", this.logSuffix);
                this.publish(this.codeMessage);
              }
            } catch (_d) {
            }
          } else {
            this.connectionsCount = Math.max(this.connectionsCount - 1, 0);
            (_c = this.callback) === null || _c === void 0 ? void 0 : _c.call(this, {
              type: "disconnect",
              connectionId,
              data: {}
            });
          }
        };
        TransportImplBase2.prototype.onProtocolMessage = function(connectionId, message) {
          var _a, _b;
          if (message.type === "RESEND_CODE") {
            if (this.codeMessage) {
              (_a = this.logger) === null || _a === void 0 ? void 0 : _a.comm("Resending code...", this.logSuffix);
              this.publish(this.codeMessage);
            }
          } else {
            (_b = this.callback) === null || _b === void 0 ? void 0 : _b.call(this, {
              type: "protocol_message",
              connectionId,
              data: message
            });
          }
        };
        TransportImplBase2.prototype.publish = function(message) {
          var _a, _b, _c;
          return __awaiter(this, void 0, void 0, function() {
            var e_1;
            return __generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  if (!this.connectionsCount) {
                    return [
                      2
                      /*return*/
                    ];
                  }
                  if (!this.isStarted()) return [3, 5];
                  _d.label = 1;
                case 1:
                  _d.trys.push([1, 3, , 4]);
                  return [4, this.sendAsync(this.channel, message)];
                case 2:
                  _d.sent();
                  return [3, 4];
                case 3:
                  e_1 = _d.sent();
                  (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error("Failed to publish message", message.type, e_1, this.logSuffix);
                  return [3, 4];
                case 4:
                  return [3, 6];
                case 5:
                  (_b = this.callback) === null || _b === void 0 ? void 0 : _b.call(this, {
                    type: "synthetic_event",
                    data: message
                  });
                  _d.label = 6;
                case 6:
                  (_c = this.callback) === null || _c === void 0 ? void 0 : _c.call(this, {
                    type: "send_message",
                    data: message
                  });
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        TransportImplBase2.prototype.onSyntheticEvent = function(data) {
          var _a, _b, _c;
          if (typeof data !== "string") {
            return;
          }
          try {
            var message = JSON.parse(data);
            switch (message.type) {
              case "CONNECT":
                this.connectionsCount++;
                (_a = this.callback) === null || _a === void 0 ? void 0 : _a.call(this, {
                  type: "connect",
                  connectionId: JSON.stringify(message.device),
                  data: message.device
                });
                break;
              case "DISCONNECT":
                this.connectionsCount = Math.max(this.connectionsCount - 1, 0);
                (_b = this.callback) === null || _b === void 0 ? void 0 : _b.call(this, {
                  type: "disconnect",
                  connectionId: JSON.stringify(message.device),
                  data: {}
                });
                break;
              case "MESSAGE":
                this.onProtocolMessage(JSON.stringify(message.message.device), message.message);
                break;
            }
          } catch (e) {
            (_c = this.logger) === null || _c === void 0 ? void 0 : _c.error("Failed to parse postMessage", e, data, this.logSuffix);
          }
        };
        TransportImplBase2.CODE_SIZE_LIMIT_FOR_DIFF = 32768;
        return TransportImplBase2;
      }()
    );
    exports.default = TransportImplBase;
  }
});

// node_modules/snack-sdk/build/transports/TransportImplPubNub.js
var require_TransportImplPubNub = __commonJS({
  "node_modules/snack-sdk/build/transports/TransportImplPubNub.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.calcPubNubCodeMessageSize = void 0;
    var pubnub_1 = __importDefault(require_pubnub_min());
    var TransportImplBase_1 = __importDefault(require_TransportImplBase());
    function calcPubNubCodeMessageSize(channel, codeMessage) {
      return encodeURIComponent(channel + JSON.stringify(codeMessage).replace(/[!~*'()]/g, function(x) {
        return "%" + x.charCodeAt(0).toString(16).toUpperCase();
      })).length + 200;
    }
    exports.calcPubNubCodeMessageSize = calcPubNubCodeMessageSize;
    var TransportImplPubNub = (
      /** @class */
      function(_super) {
        __extends(TransportImplPubNub2, _super);
        function TransportImplPubNub2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.onPubNubPresence = function(event) {
            switch (event.action) {
              case "join":
                _this.handleChannelEvent("join", event.uuid);
                break;
              case "timeout":
              case "leave":
                _this.handleChannelEvent("leave", event.uuid);
                break;
            }
          };
          _this.onPubNubMessage = function(event) {
            var message = event.message;
            _this.handleMessage(event.publisher, message);
          };
          _this.onPubNubStatus = function(_event) {
          };
          return _this;
        }
        TransportImplPubNub2.prototype.start = function() {
          var _a;
          this.stop();
          if (!this.pubNubClientId) {
            this.pubNubClientId = pubnub_1.default.generateUUID();
          }
          if (this.channel) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.comm("Starting channel...", this.channel, this.logSuffix);
            this.pubNub = new pubnub_1.default({
              publishKey: "pub-c-2a7fd67b-333d-40db-ad2d-3255f8835f70",
              subscribeKey: "sub-c-0b655000-d784-11e6-b950-02ee2ddab7fe",
              uuid: this.pubNubClientId,
              ssl: true,
              presenceTimeout: 600,
              heartbeatInterval: 60
            });
            this.pubNub.addListener({
              presence: this.onPubNubPresence,
              message: this.onPubNubMessage,
              status: this.onPubNubStatus
            });
            this.pubNub.subscribe({
              channels: [this.channel],
              withPresence: true
            });
          }
        };
        TransportImplPubNub2.prototype.stop = function() {
          var _a;
          if (this.pubNub) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.comm("Stopping...", this.logSuffix);
            this.pubNub.removeListener({
              presence: this.onPubNubPresence,
              message: this.onPubNubMessage,
              status: this.onPubNubStatus
            });
            this.pubNub.unsubscribe({
              channels: [this.channel]
            });
            this.pubNub.stop();
            this.pubNub = void 0;
          }
        };
        TransportImplPubNub2.prototype.isStarted = function() {
          return this.pubNub != null;
        };
        TransportImplPubNub2.prototype.sendAsync = function(channel, message) {
          var _a;
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, (_a = this.pubNub) === null || _a === void 0 ? void 0 : _a.publish({
                    channel,
                    message
                  })];
                case 1:
                  _b.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        TransportImplPubNub2.prototype.onVerifyCodeMessageSize = function(codeMessage) {
          var approxSize = 0;
          for (var path in codeMessage.diff) {
            approxSize += path.length + codeMessage.diff[path].length;
          }
          if (approxSize >= TransportImplBase_1.default.CODE_SIZE_LIMIT_FOR_DIFF) {
            return false;
          }
          var size = calcPubNubCodeMessageSize(this.channel, codeMessage);
          return size < TransportImplBase_1.default.CODE_SIZE_LIMIT_FOR_DIFF;
        };
        return TransportImplPubNub2;
      }(TransportImplBase_1.default)
    );
    exports.default = TransportImplPubNub;
  }
});

// node_modules/engine.io-parser/build/cjs/commons.js
var require_commons = __commonJS({
  "node_modules/engine.io-parser/build/cjs/commons.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ERROR_PACKET = exports.PACKET_TYPES_REVERSE = exports.PACKET_TYPES = void 0;
    var PACKET_TYPES = /* @__PURE__ */ Object.create(null);
    exports.PACKET_TYPES = PACKET_TYPES;
    PACKET_TYPES["open"] = "0";
    PACKET_TYPES["close"] = "1";
    PACKET_TYPES["ping"] = "2";
    PACKET_TYPES["pong"] = "3";
    PACKET_TYPES["message"] = "4";
    PACKET_TYPES["upgrade"] = "5";
    PACKET_TYPES["noop"] = "6";
    var PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
    exports.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
    Object.keys(PACKET_TYPES).forEach((key) => {
      PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
    });
    var ERROR_PACKET = { type: "error", data: "parser error" };
    exports.ERROR_PACKET = ERROR_PACKET;
  }
});

// node_modules/engine.io-parser/build/cjs/encodePacket.browser.js
var require_encodePacket_browser = __commonJS({
  "node_modules/engine.io-parser/build/cjs/encodePacket.browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var commons_js_1 = require_commons();
    var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
    var withNativeArrayBuffer = typeof ArrayBuffer === "function";
    var isView = (obj) => {
      return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
    };
    var encodePacket = ({ type, data }, supportsBinary, callback) => {
      if (withNativeBlob && data instanceof Blob) {
        if (supportsBinary) {
          return callback(data);
        } else {
          return encodeBlobAsBase64(data, callback);
        }
      } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
        if (supportsBinary) {
          return callback(data);
        } else {
          return encodeBlobAsBase64(new Blob([data]), callback);
        }
      }
      return callback(commons_js_1.PACKET_TYPES[type] + (data || ""));
    };
    var encodeBlobAsBase64 = (data, callback) => {
      const fileReader = new FileReader();
      fileReader.onload = function() {
        const content = fileReader.result.split(",")[1];
        callback("b" + (content || ""));
      };
      return fileReader.readAsDataURL(data);
    };
    exports.default = encodePacket;
  }
});

// node_modules/engine.io-parser/build/cjs/contrib/base64-arraybuffer.js
var require_base64_arraybuffer = __commonJS({
  "node_modules/engine.io-parser/build/cjs/contrib/base64-arraybuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decode = exports.encode = void 0;
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (let i = 0; i < chars.length; i++) {
      lookup[chars.charCodeAt(i)] = i;
    }
    var encode = (arraybuffer) => {
      let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = "";
      for (i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
        base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
        base64 += chars[bytes[i + 2] & 63];
      }
      if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + "=";
      } else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + "==";
      }
      return base64;
    };
    exports.encode = encode;
    var decode = (base64) => {
      let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base64[base64.length - 1] === "=") {
        bufferLength--;
        if (base64[base64.length - 2] === "=") {
          bufferLength--;
        }
      }
      const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
      for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return arraybuffer;
    };
    exports.decode = decode;
  }
});

// node_modules/engine.io-parser/build/cjs/decodePacket.browser.js
var require_decodePacket_browser = __commonJS({
  "node_modules/engine.io-parser/build/cjs/decodePacket.browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var commons_js_1 = require_commons();
    var base64_arraybuffer_js_1 = require_base64_arraybuffer();
    var withNativeArrayBuffer = typeof ArrayBuffer === "function";
    var decodePacket = (encodedPacket, binaryType) => {
      if (typeof encodedPacket !== "string") {
        return {
          type: "message",
          data: mapBinary(encodedPacket, binaryType)
        };
      }
      const type = encodedPacket.charAt(0);
      if (type === "b") {
        return {
          type: "message",
          data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
        };
      }
      const packetType = commons_js_1.PACKET_TYPES_REVERSE[type];
      if (!packetType) {
        return commons_js_1.ERROR_PACKET;
      }
      return encodedPacket.length > 1 ? {
        type: commons_js_1.PACKET_TYPES_REVERSE[type],
        data: encodedPacket.substring(1)
      } : {
        type: commons_js_1.PACKET_TYPES_REVERSE[type]
      };
    };
    var decodeBase64Packet = (data, binaryType) => {
      if (withNativeArrayBuffer) {
        const decoded = (0, base64_arraybuffer_js_1.decode)(data);
        return mapBinary(decoded, binaryType);
      } else {
        return { base64: true, data };
      }
    };
    var mapBinary = (data, binaryType) => {
      switch (binaryType) {
        case "blob":
          return data instanceof ArrayBuffer ? new Blob([data]) : data;
        case "arraybuffer":
        default:
          return data;
      }
    };
    exports.default = decodePacket;
  }
});

// node_modules/engine.io-parser/build/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/engine.io-parser/build/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodePayload = exports.decodePacket = exports.encodePayload = exports.encodePacket = exports.protocol = void 0;
    var encodePacket_js_1 = require_encodePacket_browser();
    exports.encodePacket = encodePacket_js_1.default;
    var decodePacket_js_1 = require_decodePacket_browser();
    exports.decodePacket = decodePacket_js_1.default;
    var SEPARATOR = String.fromCharCode(30);
    var encodePayload = (packets, callback) => {
      const length = packets.length;
      const encodedPackets = new Array(length);
      let count = 0;
      packets.forEach((packet, i) => {
        (0, encodePacket_js_1.default)(packet, false, (encodedPacket) => {
          encodedPackets[i] = encodedPacket;
          if (++count === length) {
            callback(encodedPackets.join(SEPARATOR));
          }
        });
      });
    };
    exports.encodePayload = encodePayload;
    var decodePayload = (encodedPayload, binaryType) => {
      const encodedPackets = encodedPayload.split(SEPARATOR);
      const packets = [];
      for (let i = 0; i < encodedPackets.length; i++) {
        const decodedPacket = (0, decodePacket_js_1.default)(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
          break;
        }
      }
      return packets;
    };
    exports.decodePayload = decodePayload;
    exports.protocol = 4;
  }
});

// node_modules/@socket.io/component-emitter/lib/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Emitter: () => Emitter
});
function Emitter(obj) {
  if (obj) return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
var init_esm = __esm({
  "node_modules/@socket.io/component-emitter/lib/esm/index.js"() {
    Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
      return this;
    };
    Emitter.prototype.once = function(event, fn) {
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }
      var callbacks = this._callbacks["$" + event];
      if (!callbacks) return this;
      if (1 == arguments.length) {
        delete this._callbacks["$" + event];
        return this;
      }
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      if (callbacks.length === 0) {
        delete this._callbacks["$" + event];
      }
      return this;
    };
    Emitter.prototype.emit = function(event) {
      this._callbacks = this._callbacks || {};
      var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
      return this;
    };
    Emitter.prototype.emitReserved = Emitter.prototype.emit;
    Emitter.prototype.listeners = function(event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks["$" + event] || [];
    };
    Emitter.prototype.hasListeners = function(event) {
      return !!this.listeners(event).length;
    };
  }
});

// node_modules/engine.io-client/build/cjs/globalThis.browser.js
var require_globalThis_browser = __commonJS({
  "node_modules/engine.io-client/build/cjs/globalThis.browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.globalThisShim = void 0;
    exports.globalThisShim = (() => {
      if (typeof self !== "undefined") {
        return self;
      } else if (typeof window !== "undefined") {
        return window;
      } else {
        return Function("return this")();
      }
    })();
  }
});

// node_modules/engine.io-client/build/cjs/util.js
var require_util = __commonJS({
  "node_modules/engine.io-client/build/cjs/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.byteLength = exports.installTimerFunctions = exports.pick = void 0;
    var globalThis_js_1 = require_globalThis_browser();
    function pick(obj, ...attr) {
      return attr.reduce((acc, k) => {
        if (obj.hasOwnProperty(k)) {
          acc[k] = obj[k];
        }
        return acc;
      }, {});
    }
    exports.pick = pick;
    var NATIVE_SET_TIMEOUT = setTimeout;
    var NATIVE_CLEAR_TIMEOUT = clearTimeout;
    function installTimerFunctions(obj, opts) {
      if (opts.useNativeTimers) {
        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis_js_1.globalThisShim);
        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis_js_1.globalThisShim);
      } else {
        obj.setTimeoutFn = setTimeout.bind(globalThis_js_1.globalThisShim);
        obj.clearTimeoutFn = clearTimeout.bind(globalThis_js_1.globalThisShim);
      }
    }
    exports.installTimerFunctions = installTimerFunctions;
    var BASE64_OVERHEAD = 1.33;
    function byteLength(obj) {
      if (typeof obj === "string") {
        return utf8Length(obj);
      }
      return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
    }
    exports.byteLength = byteLength;
    function utf8Length(str) {
      let c = 0, length = 0;
      for (let i = 0, l = str.length; i < l; i++) {
        c = str.charCodeAt(i);
        if (c < 128) {
          length += 1;
        } else if (c < 2048) {
          length += 2;
        } else if (c < 55296 || c >= 57344) {
          length += 3;
        } else {
          i++;
          length += 4;
        }
      }
      return length;
    }
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/engine.io-client/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/engine.io-client/node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/engine.io-client/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/engine.io-client/node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/engine.io-client/build/cjs/transport.js
var require_transport = __commonJS({
  "node_modules/engine.io-client/build/cjs/transport.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transport = void 0;
    var engine_io_parser_1 = require_cjs();
    var component_emitter_1 = (init_esm(), __toCommonJS(esm_exports));
    var util_js_1 = require_util();
    var debug_1 = __importDefault(require_browser());
    var debug = (0, debug_1.default)("engine.io-client:transport");
    var TransportError = class extends Error {
      constructor(reason, description, context) {
        super(reason);
        this.description = description;
        this.context = context;
        this.type = "TransportError";
      }
    };
    var Transport = class extends component_emitter_1.Emitter {
      /**
       * Transport abstract constructor.
       *
       * @param {Object} options.
       * @api private
       */
      constructor(opts) {
        super();
        this.writable = false;
        (0, util_js_1.installTimerFunctions)(this, opts);
        this.opts = opts;
        this.query = opts.query;
        this.readyState = "";
        this.socket = opts.socket;
      }
      /**
       * Emits an error.
       *
       * @param {String} reason
       * @param description
       * @param context - the error context
       * @return {Transport} for chaining
       * @api protected
       */
      onError(reason, description, context) {
        super.emitReserved("error", new TransportError(reason, description, context));
        return this;
      }
      /**
       * Opens the transport.
       *
       * @api public
       */
      open() {
        if ("closed" === this.readyState || "" === this.readyState) {
          this.readyState = "opening";
          this.doOpen();
        }
        return this;
      }
      /**
       * Closes the transport.
       *
       * @api public
       */
      close() {
        if ("opening" === this.readyState || "open" === this.readyState) {
          this.doClose();
          this.onClose();
        }
        return this;
      }
      /**
       * Sends multiple packets.
       *
       * @param {Array} packets
       * @api public
       */
      send(packets) {
        if ("open" === this.readyState) {
          this.write(packets);
        } else {
          debug("transport is not open, discarding packets");
        }
      }
      /**
       * Called upon open
       *
       * @api protected
       */
      onOpen() {
        this.readyState = "open";
        this.writable = true;
        super.emitReserved("open");
      }
      /**
       * Called with data.
       *
       * @param {String} data
       * @api protected
       */
      onData(data) {
        const packet = (0, engine_io_parser_1.decodePacket)(data, this.socket.binaryType);
        this.onPacket(packet);
      }
      /**
       * Called with a decoded packet.
       *
       * @api protected
       */
      onPacket(packet) {
        super.emitReserved("packet", packet);
      }
      /**
       * Called upon close.
       *
       * @api protected
       */
      onClose(details) {
        this.readyState = "closed";
        super.emitReserved("close", details);
      }
    };
    exports.Transport = Transport;
  }
});

// node_modules/engine.io-client/build/cjs/contrib/yeast.js
var require_yeast = __commonJS({
  "node_modules/engine.io-client/build/cjs/contrib/yeast.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.yeast = exports.decode = exports.encode = void 0;
    var alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
    var length = 64;
    var map = {};
    var seed = 0;
    var i = 0;
    var prev;
    function encode(num) {
      let encoded = "";
      do {
        encoded = alphabet[num % length] + encoded;
        num = Math.floor(num / length);
      } while (num > 0);
      return encoded;
    }
    exports.encode = encode;
    function decode(str) {
      let decoded = 0;
      for (i = 0; i < str.length; i++) {
        decoded = decoded * length + map[str.charAt(i)];
      }
      return decoded;
    }
    exports.decode = decode;
    function yeast() {
      const now = encode(+/* @__PURE__ */ new Date());
      if (now !== prev)
        return seed = 0, prev = now;
      return now + "." + encode(seed++);
    }
    exports.yeast = yeast;
    for (; i < length; i++)
      map[alphabet[i]] = i;
  }
});

// node_modules/engine.io-client/build/cjs/contrib/parseqs.js
var require_parseqs = __commonJS({
  "node_modules/engine.io-client/build/cjs/contrib/parseqs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decode = exports.encode = void 0;
    function encode(obj) {
      let str = "";
      for (let i in obj) {
        if (obj.hasOwnProperty(i)) {
          if (str.length)
            str += "&";
          str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
        }
      }
      return str;
    }
    exports.encode = encode;
    function decode(qs) {
      let qry = {};
      let pairs = qs.split("&");
      for (let i = 0, l = pairs.length; i < l; i++) {
        let pair = pairs[i].split("=");
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
      }
      return qry;
    }
    exports.decode = decode;
  }
});

// node_modules/engine.io-client/build/cjs/contrib/has-cors.js
var require_has_cors = __commonJS({
  "node_modules/engine.io-client/build/cjs/contrib/has-cors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasCORS = void 0;
    var value = false;
    try {
      value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
    } catch (err) {
    }
    exports.hasCORS = value;
  }
});

// node_modules/engine.io-client/build/cjs/transports/xmlhttprequest.browser.js
var require_xmlhttprequest_browser = __commonJS({
  "node_modules/engine.io-client/build/cjs/transports/xmlhttprequest.browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.XHR = void 0;
    var has_cors_js_1 = require_has_cors();
    var globalThis_js_1 = require_globalThis_browser();
    function XHR(opts) {
      const xdomain = opts.xdomain;
      try {
        if ("undefined" !== typeof XMLHttpRequest && (!xdomain || has_cors_js_1.hasCORS)) {
          return new XMLHttpRequest();
        }
      } catch (e) {
      }
      if (!xdomain) {
        try {
          return new globalThis_js_1.globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
        } catch (e) {
        }
      }
    }
    exports.XHR = XHR;
  }
});

// node_modules/engine.io-client/build/cjs/transports/polling.js
var require_polling = __commonJS({
  "node_modules/engine.io-client/build/cjs/transports/polling.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Request = exports.Polling = void 0;
    var transport_js_1 = require_transport();
    var debug_1 = __importDefault(require_browser());
    var yeast_js_1 = require_yeast();
    var parseqs_js_1 = require_parseqs();
    var engine_io_parser_1 = require_cjs();
    var xmlhttprequest_js_1 = require_xmlhttprequest_browser();
    var component_emitter_1 = (init_esm(), __toCommonJS(esm_exports));
    var util_js_1 = require_util();
    var globalThis_js_1 = require_globalThis_browser();
    var debug = (0, debug_1.default)("engine.io-client:polling");
    function empty() {
    }
    var hasXHR2 = function() {
      const xhr = new xmlhttprequest_js_1.XHR({
        xdomain: false
      });
      return null != xhr.responseType;
    }();
    var Polling = class extends transport_js_1.Transport {
      /**
       * XHR Polling constructor.
       *
       * @param {Object} opts
       * @api public
       */
      constructor(opts) {
        super(opts);
        this.polling = false;
        if (typeof location !== "undefined") {
          const isSSL = "https:" === location.protocol;
          let port = location.port;
          if (!port) {
            port = isSSL ? "443" : "80";
          }
          this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
          this.xs = opts.secure !== isSSL;
        }
        const forceBase64 = opts && opts.forceBase64;
        this.supportsBinary = hasXHR2 && !forceBase64;
      }
      /**
       * Transport name.
       */
      get name() {
        return "polling";
      }
      /**
       * Opens the socket (triggers polling). We write a PING message to determine
       * when the transport is open.
       *
       * @api private
       */
      doOpen() {
        this.poll();
      }
      /**
       * Pauses polling.
       *
       * @param {Function} callback upon buffers are flushed and transport is paused
       * @api private
       */
      pause(onPause) {
        this.readyState = "pausing";
        const pause = () => {
          debug("paused");
          this.readyState = "paused";
          onPause();
        };
        if (this.polling || !this.writable) {
          let total = 0;
          if (this.polling) {
            debug("we are currently polling - waiting to pause");
            total++;
            this.once("pollComplete", function() {
              debug("pre-pause polling complete");
              --total || pause();
            });
          }
          if (!this.writable) {
            debug("we are currently writing - waiting to pause");
            total++;
            this.once("drain", function() {
              debug("pre-pause writing complete");
              --total || pause();
            });
          }
        } else {
          pause();
        }
      }
      /**
       * Starts polling cycle.
       *
       * @api public
       */
      poll() {
        debug("polling");
        this.polling = true;
        this.doPoll();
        this.emitReserved("poll");
      }
      /**
       * Overloads onData to detect payloads.
       *
       * @api private
       */
      onData(data) {
        debug("polling got data %s", data);
        const callback = (packet) => {
          if ("opening" === this.readyState && packet.type === "open") {
            this.onOpen();
          }
          if ("close" === packet.type) {
            this.onClose({ description: "transport closed by the server" });
            return false;
          }
          this.onPacket(packet);
        };
        (0, engine_io_parser_1.decodePayload)(data, this.socket.binaryType).forEach(callback);
        if ("closed" !== this.readyState) {
          this.polling = false;
          this.emitReserved("pollComplete");
          if ("open" === this.readyState) {
            this.poll();
          } else {
            debug('ignoring poll - transport state "%s"', this.readyState);
          }
        }
      }
      /**
       * For polling, send a close packet.
       *
       * @api private
       */
      doClose() {
        const close = () => {
          debug("writing close packet");
          this.write([{ type: "close" }]);
        };
        if ("open" === this.readyState) {
          debug("transport open - closing");
          close();
        } else {
          debug("transport not open - deferring close");
          this.once("open", close);
        }
      }
      /**
       * Writes a packets payload.
       *
       * @param {Array} data packets
       * @param {Function} drain callback
       * @api private
       */
      write(packets) {
        this.writable = false;
        (0, engine_io_parser_1.encodePayload)(packets, (data) => {
          this.doWrite(data, () => {
            this.writable = true;
            this.emitReserved("drain");
          });
        });
      }
      /**
       * Generates uri for connection.
       *
       * @api private
       */
      uri() {
        let query = this.query || {};
        const schema = this.opts.secure ? "https" : "http";
        let port = "";
        if (false !== this.opts.timestampRequests) {
          query[this.opts.timestampParam] = (0, yeast_js_1.yeast)();
        }
        if (!this.supportsBinary && !query.sid) {
          query.b64 = 1;
        }
        if (this.opts.port && ("https" === schema && Number(this.opts.port) !== 443 || "http" === schema && Number(this.opts.port) !== 80)) {
          port = ":" + this.opts.port;
        }
        const encodedQuery = (0, parseqs_js_1.encode)(query);
        const ipv6 = this.opts.hostname.indexOf(":") !== -1;
        return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
      }
      /**
       * Creates a request.
       *
       * @param {String} method
       * @api private
       */
      request(opts = {}) {
        Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
        return new Request(this.uri(), opts);
      }
      /**
       * Sends data.
       *
       * @param {String} data to send.
       * @param {Function} called upon flush.
       * @api private
       */
      doWrite(data, fn) {
        const req = this.request({
          method: "POST",
          data
        });
        req.on("success", fn);
        req.on("error", (xhrStatus, context) => {
          this.onError("xhr post error", xhrStatus, context);
        });
      }
      /**
       * Starts a poll cycle.
       *
       * @api private
       */
      doPoll() {
        debug("xhr poll");
        const req = this.request();
        req.on("data", this.onData.bind(this));
        req.on("error", (xhrStatus, context) => {
          this.onError("xhr poll error", xhrStatus, context);
        });
        this.pollXhr = req;
      }
    };
    exports.Polling = Polling;
    var Request = class _Request extends component_emitter_1.Emitter {
      /**
       * Request constructor
       *
       * @param {Object} options
       * @api public
       */
      constructor(uri, opts) {
        super();
        (0, util_js_1.installTimerFunctions)(this, opts);
        this.opts = opts;
        this.method = opts.method || "GET";
        this.uri = uri;
        this.async = false !== opts.async;
        this.data = void 0 !== opts.data ? opts.data : null;
        this.create();
      }
      /**
       * Creates the XHR object and sends the request.
       *
       * @api private
       */
      create() {
        const opts = (0, util_js_1.pick)(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        opts.xdomain = !!this.opts.xd;
        opts.xscheme = !!this.opts.xs;
        const xhr = this.xhr = new xmlhttprequest_js_1.XHR(opts);
        try {
          debug("xhr open %s: %s", this.method, this.uri);
          xhr.open(this.method, this.uri, this.async);
          try {
            if (this.opts.extraHeaders) {
              xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
              for (let i in this.opts.extraHeaders) {
                if (this.opts.extraHeaders.hasOwnProperty(i)) {
                  xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
                }
              }
            }
          } catch (e) {
          }
          if ("POST" === this.method) {
            try {
              xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
            } catch (e) {
            }
          }
          try {
            xhr.setRequestHeader("Accept", "*/*");
          } catch (e) {
          }
          if ("withCredentials" in xhr) {
            xhr.withCredentials = this.opts.withCredentials;
          }
          if (this.opts.requestTimeout) {
            xhr.timeout = this.opts.requestTimeout;
          }
          xhr.onreadystatechange = () => {
            if (4 !== xhr.readyState)
              return;
            if (200 === xhr.status || 1223 === xhr.status) {
              this.onLoad();
            } else {
              this.setTimeoutFn(() => {
                this.onError(typeof xhr.status === "number" ? xhr.status : 0);
              }, 0);
            }
          };
          debug("xhr data %s", this.data);
          xhr.send(this.data);
        } catch (e) {
          this.setTimeoutFn(() => {
            this.onError(e);
          }, 0);
          return;
        }
        if (typeof document !== "undefined") {
          this.index = _Request.requestsCount++;
          _Request.requests[this.index] = this;
        }
      }
      /**
       * Called upon error.
       *
       * @api private
       */
      onError(err) {
        this.emitReserved("error", err, this.xhr);
        this.cleanup(true);
      }
      /**
       * Cleans up house.
       *
       * @api private
       */
      cleanup(fromError) {
        if ("undefined" === typeof this.xhr || null === this.xhr) {
          return;
        }
        this.xhr.onreadystatechange = empty;
        if (fromError) {
          try {
            this.xhr.abort();
          } catch (e) {
          }
        }
        if (typeof document !== "undefined") {
          delete _Request.requests[this.index];
        }
        this.xhr = null;
      }
      /**
       * Called upon load.
       *
       * @api private
       */
      onLoad() {
        const data = this.xhr.responseText;
        if (data !== null) {
          this.emitReserved("data", data);
          this.emitReserved("success");
          this.cleanup();
        }
      }
      /**
       * Aborts the request.
       *
       * @api public
       */
      abort() {
        this.cleanup();
      }
    };
    exports.Request = Request;
    Request.requestsCount = 0;
    Request.requests = {};
    if (typeof document !== "undefined") {
      if (typeof attachEvent === "function") {
        attachEvent("onunload", unloadHandler);
      } else if (typeof addEventListener === "function") {
        const terminationEvent = "onpagehide" in globalThis_js_1.globalThisShim ? "pagehide" : "unload";
        addEventListener(terminationEvent, unloadHandler, false);
      }
    }
    function unloadHandler() {
      for (let i in Request.requests) {
        if (Request.requests.hasOwnProperty(i)) {
          Request.requests[i].abort();
        }
      }
    }
  }
});

// node_modules/engine.io-client/build/cjs/transports/websocket-constructor.browser.js
var require_websocket_constructor_browser = __commonJS({
  "node_modules/engine.io-client/build/cjs/transports/websocket-constructor.browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultBinaryType = exports.usingBrowserWebSocket = exports.WebSocket = exports.nextTick = void 0;
    var globalThis_js_1 = require_globalThis_browser();
    exports.nextTick = (() => {
      const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
      if (isPromiseAvailable) {
        return (cb) => Promise.resolve().then(cb);
      } else {
        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
      }
    })();
    exports.WebSocket = globalThis_js_1.globalThisShim.WebSocket || globalThis_js_1.globalThisShim.MozWebSocket;
    exports.usingBrowserWebSocket = true;
    exports.defaultBinaryType = "arraybuffer";
  }
});

// node_modules/engine.io-client/build/cjs/transports/websocket.js
var require_websocket = __commonJS({
  "node_modules/engine.io-client/build/cjs/transports/websocket.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WS = void 0;
    var transport_js_1 = require_transport();
    var parseqs_js_1 = require_parseqs();
    var yeast_js_1 = require_yeast();
    var util_js_1 = require_util();
    var websocket_constructor_js_1 = require_websocket_constructor_browser();
    var debug_1 = __importDefault(require_browser());
    var engine_io_parser_1 = require_cjs();
    var debug = (0, debug_1.default)("engine.io-client:websocket");
    var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
    var WS = class extends transport_js_1.Transport {
      /**
       * WebSocket transport constructor.
       *
       * @api {Object} connection options
       * @api public
       */
      constructor(opts) {
        super(opts);
        this.supportsBinary = !opts.forceBase64;
      }
      /**
       * Transport name.
       *
       * @api public
       */
      get name() {
        return "websocket";
      }
      /**
       * Opens socket.
       *
       * @api private
       */
      doOpen() {
        if (!this.check()) {
          return;
        }
        const uri = this.uri();
        const protocols = this.opts.protocols;
        const opts = isReactNative ? {} : (0, util_js_1.pick)(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        if (this.opts.extraHeaders) {
          opts.headers = this.opts.extraHeaders;
        }
        try {
          this.ws = websocket_constructor_js_1.usingBrowserWebSocket && !isReactNative ? protocols ? new websocket_constructor_js_1.WebSocket(uri, protocols) : new websocket_constructor_js_1.WebSocket(uri) : new websocket_constructor_js_1.WebSocket(uri, protocols, opts);
        } catch (err) {
          return this.emitReserved("error", err);
        }
        this.ws.binaryType = this.socket.binaryType || websocket_constructor_js_1.defaultBinaryType;
        this.addEventListeners();
      }
      /**
       * Adds event listeners to the socket
       *
       * @api private
       */
      addEventListeners() {
        this.ws.onopen = () => {
          if (this.opts.autoUnref) {
            this.ws._socket.unref();
          }
          this.onOpen();
        };
        this.ws.onclose = (closeEvent) => this.onClose({
          description: "websocket connection closed",
          context: closeEvent
        });
        this.ws.onmessage = (ev) => this.onData(ev.data);
        this.ws.onerror = (e) => this.onError("websocket error", e);
      }
      /**
       * Writes data to socket.
       *
       * @param {Array} array of packets.
       * @api private
       */
      write(packets) {
        this.writable = false;
        for (let i = 0; i < packets.length; i++) {
          const packet = packets[i];
          const lastPacket = i === packets.length - 1;
          (0, engine_io_parser_1.encodePacket)(packet, this.supportsBinary, (data) => {
            const opts = {};
            if (!websocket_constructor_js_1.usingBrowserWebSocket) {
              if (packet.options) {
                opts.compress = packet.options.compress;
              }
              if (this.opts.perMessageDeflate) {
                const len = (
                  // @ts-ignore
                  "string" === typeof data ? Buffer.byteLength(data) : data.length
                );
                if (len < this.opts.perMessageDeflate.threshold) {
                  opts.compress = false;
                }
              }
            }
            try {
              if (websocket_constructor_js_1.usingBrowserWebSocket) {
                this.ws.send(data);
              } else {
                this.ws.send(data, opts);
              }
            } catch (e) {
              debug("websocket closed before onclose event");
            }
            if (lastPacket) {
              (0, websocket_constructor_js_1.nextTick)(() => {
                this.writable = true;
                this.emitReserved("drain");
              }, this.setTimeoutFn);
            }
          });
        }
      }
      /**
       * Closes socket.
       *
       * @api private
       */
      doClose() {
        if (typeof this.ws !== "undefined") {
          this.ws.close();
          this.ws = null;
        }
      }
      /**
       * Generates uri for connection.
       *
       * @api private
       */
      uri() {
        let query = this.query || {};
        const schema = this.opts.secure ? "wss" : "ws";
        let port = "";
        if (this.opts.port && ("wss" === schema && Number(this.opts.port) !== 443 || "ws" === schema && Number(this.opts.port) !== 80)) {
          port = ":" + this.opts.port;
        }
        if (this.opts.timestampRequests) {
          query[this.opts.timestampParam] = (0, yeast_js_1.yeast)();
        }
        if (!this.supportsBinary) {
          query.b64 = 1;
        }
        const encodedQuery = (0, parseqs_js_1.encode)(query);
        const ipv6 = this.opts.hostname.indexOf(":") !== -1;
        return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
      }
      /**
       * Feature detection for WebSocket.
       *
       * @return {Boolean} whether this transport is available.
       * @api public
       */
      check() {
        return !!websocket_constructor_js_1.WebSocket;
      }
    };
    exports.WS = WS;
  }
});

// node_modules/engine.io-client/build/cjs/transports/index.js
var require_transports = __commonJS({
  "node_modules/engine.io-client/build/cjs/transports/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transports = void 0;
    var polling_js_1 = require_polling();
    var websocket_js_1 = require_websocket();
    exports.transports = {
      websocket: websocket_js_1.WS,
      polling: polling_js_1.Polling
    };
  }
});

// node_modules/engine.io-client/build/cjs/contrib/parseuri.js
var require_parseuri = __commonJS({
  "node_modules/engine.io-client/build/cjs/contrib/parseuri.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = void 0;
    var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
    var parts = [
      "source",
      "protocol",
      "authority",
      "userInfo",
      "user",
      "password",
      "host",
      "port",
      "relative",
      "path",
      "directory",
      "file",
      "query",
      "anchor"
    ];
    function parse(str) {
      const src = str, b = str.indexOf("["), e = str.indexOf("]");
      if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
      }
      let m = re.exec(str || ""), uri = {}, i = 14;
      while (i--) {
        uri[parts[i]] = m[i] || "";
      }
      if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
        uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
        uri.ipv6uri = true;
      }
      uri.pathNames = pathNames(uri, uri["path"]);
      uri.queryKey = queryKey(uri, uri["query"]);
      return uri;
    }
    exports.parse = parse;
    function pathNames(obj, path) {
      const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
      if (path.slice(0, 1) == "/" || path.length === 0) {
        names.splice(0, 1);
      }
      if (path.slice(-1) == "/") {
        names.splice(names.length - 1, 1);
      }
      return names;
    }
    function queryKey(uri, query) {
      const data = {};
      query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
        if ($1) {
          data[$1] = $2;
        }
      });
      return data;
    }
  }
});

// node_modules/engine.io-client/build/cjs/socket.js
var require_socket = __commonJS({
  "node_modules/engine.io-client/build/cjs/socket.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Socket = void 0;
    var index_js_1 = require_transports();
    var util_js_1 = require_util();
    var parseqs_js_1 = require_parseqs();
    var parseuri_js_1 = require_parseuri();
    var debug_1 = __importDefault(require_browser());
    var component_emitter_1 = (init_esm(), __toCommonJS(esm_exports));
    var engine_io_parser_1 = require_cjs();
    var debug = (0, debug_1.default)("engine.io-client:socket");
    var Socket = class _Socket extends component_emitter_1.Emitter {
      /**
       * Socket constructor.
       *
       * @param {String|Object} uri or options
       * @param {Object} opts - options
       * @api public
       */
      constructor(uri, opts = {}) {
        super();
        if (uri && "object" === typeof uri) {
          opts = uri;
          uri = null;
        }
        if (uri) {
          uri = (0, parseuri_js_1.parse)(uri);
          opts.hostname = uri.host;
          opts.secure = uri.protocol === "https" || uri.protocol === "wss";
          opts.port = uri.port;
          if (uri.query)
            opts.query = uri.query;
        } else if (opts.host) {
          opts.hostname = (0, parseuri_js_1.parse)(opts.host).host;
        }
        (0, util_js_1.installTimerFunctions)(this, opts);
        this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
        if (opts.hostname && !opts.port) {
          opts.port = this.secure ? "443" : "80";
        }
        this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
        this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
        this.transports = opts.transports || ["polling", "websocket"];
        this.readyState = "";
        this.writeBuffer = [];
        this.prevBufferLen = 0;
        this.opts = Object.assign({
          path: "/engine.io",
          agent: false,
          withCredentials: false,
          upgrade: true,
          timestampParam: "t",
          rememberUpgrade: false,
          rejectUnauthorized: true,
          perMessageDeflate: {
            threshold: 1024
          },
          transportOptions: {},
          closeOnBeforeunload: true
        }, opts);
        this.opts.path = this.opts.path.replace(/\/$/, "") + "/";
        if (typeof this.opts.query === "string") {
          this.opts.query = (0, parseqs_js_1.decode)(this.opts.query);
        }
        this.id = null;
        this.upgrades = null;
        this.pingInterval = null;
        this.pingTimeout = null;
        this.pingTimeoutTimer = null;
        if (typeof addEventListener === "function") {
          if (this.opts.closeOnBeforeunload) {
            this.beforeunloadEventListener = () => {
              if (this.transport) {
                this.transport.removeAllListeners();
                this.transport.close();
              }
            };
            addEventListener("beforeunload", this.beforeunloadEventListener, false);
          }
          if (this.hostname !== "localhost") {
            this.offlineEventListener = () => {
              this.onClose("transport close", {
                description: "network connection lost"
              });
            };
            addEventListener("offline", this.offlineEventListener, false);
          }
        }
        this.open();
      }
      /**
       * Creates transport of the given type.
       *
       * @param {String} transport name
       * @return {Transport}
       * @api private
       */
      createTransport(name) {
        debug('creating transport "%s"', name);
        const query = Object.assign({}, this.opts.query);
        query.EIO = engine_io_parser_1.protocol;
        query.transport = name;
        if (this.id)
          query.sid = this.id;
        const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {
          query,
          socket: this,
          hostname: this.hostname,
          secure: this.secure,
          port: this.port
        });
        debug("options: %j", opts);
        return new index_js_1.transports[name](opts);
      }
      /**
       * Initializes transport to use and starts probe.
       *
       * @api private
       */
      open() {
        let transport;
        if (this.opts.rememberUpgrade && _Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
          transport = "websocket";
        } else if (0 === this.transports.length) {
          this.setTimeoutFn(() => {
            this.emitReserved("error", "No transports available");
          }, 0);
          return;
        } else {
          transport = this.transports[0];
        }
        this.readyState = "opening";
        try {
          transport = this.createTransport(transport);
        } catch (e) {
          debug("error while creating transport: %s", e);
          this.transports.shift();
          this.open();
          return;
        }
        transport.open();
        this.setTransport(transport);
      }
      /**
       * Sets the current transport. Disables the existing one (if any).
       *
       * @api private
       */
      setTransport(transport) {
        debug("setting transport %s", transport.name);
        if (this.transport) {
          debug("clearing existing transport %s", this.transport.name);
          this.transport.removeAllListeners();
        }
        this.transport = transport;
        transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (reason) => this.onClose("transport close", reason));
      }
      /**
       * Probes a transport.
       *
       * @param {String} transport name
       * @api private
       */
      probe(name) {
        debug('probing transport "%s"', name);
        let transport = this.createTransport(name);
        let failed = false;
        _Socket.priorWebsocketSuccess = false;
        const onTransportOpen = () => {
          if (failed)
            return;
          debug('probe transport "%s" opened', name);
          transport.send([{ type: "ping", data: "probe" }]);
          transport.once("packet", (msg) => {
            if (failed)
              return;
            if ("pong" === msg.type && "probe" === msg.data) {
              debug('probe transport "%s" pong', name);
              this.upgrading = true;
              this.emitReserved("upgrading", transport);
              if (!transport)
                return;
              _Socket.priorWebsocketSuccess = "websocket" === transport.name;
              debug('pausing current transport "%s"', this.transport.name);
              this.transport.pause(() => {
                if (failed)
                  return;
                if ("closed" === this.readyState)
                  return;
                debug("changing transport and sending upgrade packet");
                cleanup();
                this.setTransport(transport);
                transport.send([{ type: "upgrade" }]);
                this.emitReserved("upgrade", transport);
                transport = null;
                this.upgrading = false;
                this.flush();
              });
            } else {
              debug('probe transport "%s" failed', name);
              const err = new Error("probe error");
              err.transport = transport.name;
              this.emitReserved("upgradeError", err);
            }
          });
        };
        function freezeTransport() {
          if (failed)
            return;
          failed = true;
          cleanup();
          transport.close();
          transport = null;
        }
        const onerror = (err) => {
          const error = new Error("probe error: " + err);
          error.transport = transport.name;
          freezeTransport();
          debug('probe transport "%s" failed because of error: %s', name, err);
          this.emitReserved("upgradeError", error);
        };
        function onTransportClose() {
          onerror("transport closed");
        }
        function onclose() {
          onerror("socket closed");
        }
        function onupgrade(to) {
          if (transport && to.name !== transport.name) {
            debug('"%s" works - aborting "%s"', to.name, transport.name);
            freezeTransport();
          }
        }
        const cleanup = () => {
          transport.removeListener("open", onTransportOpen);
          transport.removeListener("error", onerror);
          transport.removeListener("close", onTransportClose);
          this.off("close", onclose);
          this.off("upgrading", onupgrade);
        };
        transport.once("open", onTransportOpen);
        transport.once("error", onerror);
        transport.once("close", onTransportClose);
        this.once("close", onclose);
        this.once("upgrading", onupgrade);
        transport.open();
      }
      /**
       * Called when connection is deemed open.
       *
       * @api private
       */
      onOpen() {
        debug("socket open");
        this.readyState = "open";
        _Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
        this.emitReserved("open");
        this.flush();
        if ("open" === this.readyState && this.opts.upgrade && this.transport.pause) {
          debug("starting upgrade probes");
          let i = 0;
          const l = this.upgrades.length;
          for (; i < l; i++) {
            this.probe(this.upgrades[i]);
          }
        }
      }
      /**
       * Handles a packet.
       *
       * @api private
       */
      onPacket(packet) {
        if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
          debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
          this.emitReserved("packet", packet);
          this.emitReserved("heartbeat");
          switch (packet.type) {
            case "open":
              this.onHandshake(JSON.parse(packet.data));
              break;
            case "ping":
              this.resetPingTimeout();
              this.sendPacket("pong");
              this.emitReserved("ping");
              this.emitReserved("pong");
              break;
            case "error":
              const err = new Error("server error");
              err.code = packet.data;
              this.onError(err);
              break;
            case "message":
              this.emitReserved("data", packet.data);
              this.emitReserved("message", packet.data);
              break;
          }
        } else {
          debug('packet received with socket readyState "%s"', this.readyState);
        }
      }
      /**
       * Called upon handshake completion.
       *
       * @param {Object} data - handshake obj
       * @api private
       */
      onHandshake(data) {
        this.emitReserved("handshake", data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this.upgrades = this.filterUpgrades(data.upgrades);
        this.pingInterval = data.pingInterval;
        this.pingTimeout = data.pingTimeout;
        this.maxPayload = data.maxPayload;
        this.onOpen();
        if ("closed" === this.readyState)
          return;
        this.resetPingTimeout();
      }
      /**
       * Sets and resets ping timeout timer based on server pings.
       *
       * @api private
       */
      resetPingTimeout() {
        this.clearTimeoutFn(this.pingTimeoutTimer);
        this.pingTimeoutTimer = this.setTimeoutFn(() => {
          this.onClose("ping timeout");
        }, this.pingInterval + this.pingTimeout);
        if (this.opts.autoUnref) {
          this.pingTimeoutTimer.unref();
        }
      }
      /**
       * Called on `drain` event
       *
       * @api private
       */
      onDrain() {
        this.writeBuffer.splice(0, this.prevBufferLen);
        this.prevBufferLen = 0;
        if (0 === this.writeBuffer.length) {
          this.emitReserved("drain");
        } else {
          this.flush();
        }
      }
      /**
       * Flush write buffers.
       *
       * @api private
       */
      flush() {
        if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
          const packets = this.getWritablePackets();
          debug("flushing %d packets in socket", packets.length);
          this.transport.send(packets);
          this.prevBufferLen = packets.length;
          this.emitReserved("flush");
        }
      }
      /**
       * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
       * long-polling)
       *
       * @private
       */
      getWritablePackets() {
        const shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
        if (!shouldCheckPayloadSize) {
          return this.writeBuffer;
        }
        let payloadSize = 1;
        for (let i = 0; i < this.writeBuffer.length; i++) {
          const data = this.writeBuffer[i].data;
          if (data) {
            payloadSize += (0, util_js_1.byteLength)(data);
          }
          if (i > 0 && payloadSize > this.maxPayload) {
            debug("only send %d out of %d packets", i, this.writeBuffer.length);
            return this.writeBuffer.slice(0, i);
          }
          payloadSize += 2;
        }
        debug("payload size is %d (max: %d)", payloadSize, this.maxPayload);
        return this.writeBuffer;
      }
      /**
       * Sends a message.
       *
       * @param {String} message.
       * @param {Function} callback function.
       * @param {Object} options.
       * @return {Socket} for chaining.
       * @api public
       */
      write(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
      }
      send(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
      }
      /**
       * Sends a packet.
       *
       * @param {String} packet type.
       * @param {String} data.
       * @param {Object} options.
       * @param {Function} callback function.
       * @api private
       */
      sendPacket(type, data, options, fn) {
        if ("function" === typeof data) {
          fn = data;
          data = void 0;
        }
        if ("function" === typeof options) {
          fn = options;
          options = null;
        }
        if ("closing" === this.readyState || "closed" === this.readyState) {
          return;
        }
        options = options || {};
        options.compress = false !== options.compress;
        const packet = {
          type,
          data,
          options
        };
        this.emitReserved("packetCreate", packet);
        this.writeBuffer.push(packet);
        if (fn)
          this.once("flush", fn);
        this.flush();
      }
      /**
       * Closes the connection.
       *
       * @api public
       */
      close() {
        const close = () => {
          this.onClose("forced close");
          debug("socket closing - telling transport to close");
          this.transport.close();
        };
        const cleanupAndClose = () => {
          this.off("upgrade", cleanupAndClose);
          this.off("upgradeError", cleanupAndClose);
          close();
        };
        const waitForUpgrade = () => {
          this.once("upgrade", cleanupAndClose);
          this.once("upgradeError", cleanupAndClose);
        };
        if ("opening" === this.readyState || "open" === this.readyState) {
          this.readyState = "closing";
          if (this.writeBuffer.length) {
            this.once("drain", () => {
              if (this.upgrading) {
                waitForUpgrade();
              } else {
                close();
              }
            });
          } else if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        }
        return this;
      }
      /**
       * Called upon transport error
       *
       * @api private
       */
      onError(err) {
        debug("socket error %j", err);
        _Socket.priorWebsocketSuccess = false;
        this.emitReserved("error", err);
        this.onClose("transport error", err);
      }
      /**
       * Called upon transport close.
       *
       * @api private
       */
      onClose(reason, description) {
        if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
          debug('socket close with reason: "%s"', reason);
          this.clearTimeoutFn(this.pingTimeoutTimer);
          this.transport.removeAllListeners("close");
          this.transport.close();
          this.transport.removeAllListeners();
          if (typeof removeEventListener === "function") {
            removeEventListener("beforeunload", this.beforeunloadEventListener, false);
            removeEventListener("offline", this.offlineEventListener, false);
          }
          this.readyState = "closed";
          this.id = null;
          this.emitReserved("close", reason, description);
          this.writeBuffer = [];
          this.prevBufferLen = 0;
        }
      }
      /**
       * Filters upgrades, returning only those matching client transports.
       *
       * @param {Array} server upgrades
       * @api private
       *
       */
      filterUpgrades(upgrades) {
        const filteredUpgrades = [];
        let i = 0;
        const j = upgrades.length;
        for (; i < j; i++) {
          if (~this.transports.indexOf(upgrades[i]))
            filteredUpgrades.push(upgrades[i]);
        }
        return filteredUpgrades;
      }
    };
    exports.Socket = Socket;
    Socket.protocol = engine_io_parser_1.protocol;
  }
});

// node_modules/engine.io-client/build/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/engine.io-client/build/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nextTick = exports.parse = exports.installTimerFunctions = exports.transports = exports.Transport = exports.protocol = exports.Socket = void 0;
    var socket_js_1 = require_socket();
    Object.defineProperty(exports, "Socket", { enumerable: true, get: function() {
      return socket_js_1.Socket;
    } });
    exports.protocol = socket_js_1.Socket.protocol;
    var transport_js_1 = require_transport();
    Object.defineProperty(exports, "Transport", { enumerable: true, get: function() {
      return transport_js_1.Transport;
    } });
    var index_js_1 = require_transports();
    Object.defineProperty(exports, "transports", { enumerable: true, get: function() {
      return index_js_1.transports;
    } });
    var util_js_1 = require_util();
    Object.defineProperty(exports, "installTimerFunctions", { enumerable: true, get: function() {
      return util_js_1.installTimerFunctions;
    } });
    var parseuri_js_1 = require_parseuri();
    Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
      return parseuri_js_1.parse;
    } });
    var websocket_constructor_js_1 = require_websocket_constructor_browser();
    Object.defineProperty(exports, "nextTick", { enumerable: true, get: function() {
      return websocket_constructor_js_1.nextTick;
    } });
  }
});

// node_modules/socket.io-client/node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "node_modules/socket.io-client/node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/socket.io-client/node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/socket.io-client/node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common2()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/socket.io-client/build/cjs/url.js
var require_url = __commonJS({
  "node_modules/socket.io-client/build/cjs/url.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.url = void 0;
    var engine_io_client_1 = require_cjs2();
    var debug_1 = __importDefault(require_browser2());
    var debug = debug_1.default("socket.io-client:url");
    function url(uri, path = "", loc) {
      let obj = uri;
      loc = loc || typeof location !== "undefined" && location;
      if (null == uri)
        uri = loc.protocol + "//" + loc.host;
      if (typeof uri === "string") {
        if ("/" === uri.charAt(0)) {
          if ("/" === uri.charAt(1)) {
            uri = loc.protocol + uri;
          } else {
            uri = loc.host + uri;
          }
        }
        if (!/^(https?|wss?):\/\//.test(uri)) {
          debug("protocol-less url %s", uri);
          if ("undefined" !== typeof loc) {
            uri = loc.protocol + "//" + uri;
          } else {
            uri = "https://" + uri;
          }
        }
        debug("parse %s", uri);
        obj = engine_io_client_1.parse(uri);
      }
      if (!obj.port) {
        if (/^(http|ws)$/.test(obj.protocol)) {
          obj.port = "80";
        } else if (/^(http|ws)s$/.test(obj.protocol)) {
          obj.port = "443";
        }
      }
      obj.path = obj.path || "/";
      const ipv6 = obj.host.indexOf(":") !== -1;
      const host = ipv6 ? "[" + obj.host + "]" : obj.host;
      obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
      obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
      return obj;
    }
    exports.url = url;
  }
});

// node_modules/socket.io-parser/build/cjs/is-binary.js
var require_is_binary = __commonJS({
  "node_modules/socket.io-parser/build/cjs/is-binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasBinary = exports.isBinary = void 0;
    var withNativeArrayBuffer = typeof ArrayBuffer === "function";
    var isView = (obj) => {
      return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
    };
    var toString = Object.prototype.toString;
    var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
    var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
    function isBinary(obj) {
      return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
    }
    exports.isBinary = isBinary;
    function hasBinary(obj, toJSON) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      if (Array.isArray(obj)) {
        for (let i = 0, l = obj.length; i < l; i++) {
          if (hasBinary(obj[i])) {
            return true;
          }
        }
        return false;
      }
      if (isBinary(obj)) {
        return true;
      }
      if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
        return hasBinary(obj.toJSON(), true);
      }
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
          return true;
        }
      }
      return false;
    }
    exports.hasBinary = hasBinary;
  }
});

// node_modules/socket.io-parser/build/cjs/binary.js
var require_binary = __commonJS({
  "node_modules/socket.io-parser/build/cjs/binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reconstructPacket = exports.deconstructPacket = void 0;
    var is_binary_js_1 = require_is_binary();
    function deconstructPacket(packet) {
      const buffers = [];
      const packetData = packet.data;
      const pack = packet;
      pack.data = _deconstructPacket(packetData, buffers);
      pack.attachments = buffers.length;
      return { packet: pack, buffers };
    }
    exports.deconstructPacket = deconstructPacket;
    function _deconstructPacket(data, buffers) {
      if (!data)
        return data;
      if ((0, is_binary_js_1.isBinary)(data)) {
        const placeholder = { _placeholder: true, num: buffers.length };
        buffers.push(data);
        return placeholder;
      } else if (Array.isArray(data)) {
        const newData = new Array(data.length);
        for (let i = 0; i < data.length; i++) {
          newData[i] = _deconstructPacket(data[i], buffers);
        }
        return newData;
      } else if (typeof data === "object" && !(data instanceof Date)) {
        const newData = {};
        for (const key in data) {
          if (Object.prototype.hasOwnProperty.call(data, key)) {
            newData[key] = _deconstructPacket(data[key], buffers);
          }
        }
        return newData;
      }
      return data;
    }
    function reconstructPacket(packet, buffers) {
      packet.data = _reconstructPacket(packet.data, buffers);
      delete packet.attachments;
      return packet;
    }
    exports.reconstructPacket = reconstructPacket;
    function _reconstructPacket(data, buffers) {
      if (!data)
        return data;
      if (data && data._placeholder === true) {
        const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
        if (isIndexValid) {
          return buffers[data.num];
        } else {
          throw new Error("illegal attachments");
        }
      } else if (Array.isArray(data)) {
        for (let i = 0; i < data.length; i++) {
          data[i] = _reconstructPacket(data[i], buffers);
        }
      } else if (typeof data === "object") {
        for (const key in data) {
          if (Object.prototype.hasOwnProperty.call(data, key)) {
            data[key] = _reconstructPacket(data[key], buffers);
          }
        }
      }
      return data;
    }
  }
});

// node_modules/socket.io-parser/node_modules/debug/src/common.js
var require_common3 = __commonJS({
  "node_modules/socket.io-parser/node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/socket.io-parser/node_modules/debug/src/browser.js
var require_browser3 = __commonJS({
  "node_modules/socket.io-parser/node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common3()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/socket.io-parser/build/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/socket.io-parser/build/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;
    var component_emitter_1 = (init_esm(), __toCommonJS(esm_exports));
    var binary_js_1 = require_binary();
    var is_binary_js_1 = require_is_binary();
    var debug_1 = require_browser3();
    var debug = (0, debug_1.default)("socket.io-parser");
    var RESERVED_EVENTS = [
      "connect",
      "connect_error",
      "disconnect",
      "disconnecting",
      "newListener",
      "removeListener"
      // used by the Node.js EventEmitter
    ];
    exports.protocol = 5;
    var PacketType;
    (function(PacketType2) {
      PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
      PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
      PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
      PacketType2[PacketType2["ACK"] = 3] = "ACK";
      PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
      PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
      PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
    })(PacketType = exports.PacketType || (exports.PacketType = {}));
    var Encoder = class {
      /**
       * Encoder constructor
       *
       * @param {function} replacer - custom replacer to pass down to JSON.parse
       */
      constructor(replacer) {
        this.replacer = replacer;
      }
      /**
       * Encode a packet as a single string if non-binary, or as a
       * buffer sequence, depending on packet type.
       *
       * @param {Object} obj - packet object
       */
      encode(obj) {
        debug("encoding packet %j", obj);
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
          if ((0, is_binary_js_1.hasBinary)(obj)) {
            return this.encodeAsBinary({
              type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
              nsp: obj.nsp,
              data: obj.data,
              id: obj.id
            });
          }
        }
        return [this.encodeAsString(obj)];
      }
      /**
       * Encode packet as string.
       */
      encodeAsString(obj) {
        let str = "" + obj.type;
        if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
          str += obj.attachments + "-";
        }
        if (obj.nsp && "/" !== obj.nsp) {
          str += obj.nsp + ",";
        }
        if (null != obj.id) {
          str += obj.id;
        }
        if (null != obj.data) {
          str += JSON.stringify(obj.data, this.replacer);
        }
        debug("encoded %j as %s", obj, str);
        return str;
      }
      /**
       * Encode packet as 'buffer sequence' by removing blobs, and
       * deconstructing packet into object with placeholders and
       * a list of buffers.
       */
      encodeAsBinary(obj) {
        const deconstruction = (0, binary_js_1.deconstructPacket)(obj);
        const pack = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack);
        return buffers;
      }
    };
    exports.Encoder = Encoder;
    function isObject(value) {
      return Object.prototype.toString.call(value) === "[object Object]";
    }
    var Decoder = class _Decoder extends component_emitter_1.Emitter {
      /**
       * Decoder constructor
       *
       * @param {function} reviver - custom reviver to pass down to JSON.stringify
       */
      constructor(reviver) {
        super();
        this.reviver = reviver;
      }
      /**
       * Decodes an encoded packet string into packet JSON.
       *
       * @param {String} obj - encoded packet
       */
      add(obj) {
        let packet;
        if (typeof obj === "string") {
          if (this.reconstructor) {
            throw new Error("got plaintext data when reconstructing a packet");
          }
          packet = this.decodeString(obj);
          const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
          if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
            packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
            this.reconstructor = new BinaryReconstructor(packet);
            if (packet.attachments === 0) {
              super.emitReserved("decoded", packet);
            }
          } else {
            super.emitReserved("decoded", packet);
          }
        } else if ((0, is_binary_js_1.isBinary)(obj) || obj.base64) {
          if (!this.reconstructor) {
            throw new Error("got binary data when not reconstructing a packet");
          } else {
            packet = this.reconstructor.takeBinaryData(obj);
            if (packet) {
              this.reconstructor = null;
              super.emitReserved("decoded", packet);
            }
          }
        } else {
          throw new Error("Unknown type: " + obj);
        }
      }
      /**
       * Decode a packet String (JSON data)
       *
       * @param {String} str
       * @return {Object} packet
       */
      decodeString(str) {
        let i = 0;
        const p = {
          type: Number(str.charAt(0))
        };
        if (PacketType[p.type] === void 0) {
          throw new Error("unknown packet type " + p.type);
        }
        if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
          const start = i + 1;
          while (str.charAt(++i) !== "-" && i != str.length) {
          }
          const buf = str.substring(start, i);
          if (buf != Number(buf) || str.charAt(i) !== "-") {
            throw new Error("Illegal attachments");
          }
          p.attachments = Number(buf);
        }
        if ("/" === str.charAt(i + 1)) {
          const start = i + 1;
          while (++i) {
            const c = str.charAt(i);
            if ("," === c)
              break;
            if (i === str.length)
              break;
          }
          p.nsp = str.substring(start, i);
        } else {
          p.nsp = "/";
        }
        const next = str.charAt(i + 1);
        if ("" !== next && Number(next) == next) {
          const start = i + 1;
          while (++i) {
            const c = str.charAt(i);
            if (null == c || Number(c) != c) {
              --i;
              break;
            }
            if (i === str.length)
              break;
          }
          p.id = Number(str.substring(start, i + 1));
        }
        if (str.charAt(++i)) {
          const payload = this.tryParse(str.substr(i));
          if (_Decoder.isPayloadValid(p.type, payload)) {
            p.data = payload;
          } else {
            throw new Error("invalid payload");
          }
        }
        debug("decoded %s as %j", str, p);
        return p;
      }
      tryParse(str) {
        try {
          return JSON.parse(str, this.reviver);
        } catch (e) {
          return false;
        }
      }
      static isPayloadValid(type, payload) {
        switch (type) {
          case PacketType.CONNECT:
            return isObject(payload);
          case PacketType.DISCONNECT:
            return payload === void 0;
          case PacketType.CONNECT_ERROR:
            return typeof payload === "string" || isObject(payload);
          case PacketType.EVENT:
          case PacketType.BINARY_EVENT:
            return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS.indexOf(payload[0]) === -1);
          case PacketType.ACK:
          case PacketType.BINARY_ACK:
            return Array.isArray(payload);
        }
      }
      /**
       * Deallocates a parser's resources
       */
      destroy() {
        if (this.reconstructor) {
          this.reconstructor.finishedReconstruction();
          this.reconstructor = null;
        }
      }
    };
    exports.Decoder = Decoder;
    var BinaryReconstructor = class {
      constructor(packet) {
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
      }
      /**
       * Method to be called when binary data received from connection
       * after a BINARY_EVENT packet.
       *
       * @param {Buffer | ArrayBuffer} binData - the raw binary data received
       * @return {null | Object} returns null if more binary data is expected or
       *   a reconstructed packet object if all buffers have been received.
       */
      takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
          const packet = (0, binary_js_1.reconstructPacket)(this.reconPack, this.buffers);
          this.finishedReconstruction();
          return packet;
        }
        return null;
      }
      /**
       * Cleans up binary packet reconstruction variables.
       */
      finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
      }
    };
  }
});

// node_modules/socket.io-client/build/cjs/on.js
var require_on = __commonJS({
  "node_modules/socket.io-client/build/cjs/on.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.on = void 0;
    function on(obj, ev, fn) {
      obj.on(ev, fn);
      return function subDestroy() {
        obj.off(ev, fn);
      };
    }
    exports.on = on;
  }
});

// node_modules/socket.io-client/build/cjs/socket.js
var require_socket2 = __commonJS({
  "node_modules/socket.io-client/build/cjs/socket.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Socket = void 0;
    var socket_io_parser_1 = require_cjs3();
    var on_js_1 = require_on();
    var component_emitter_1 = (init_esm(), __toCommonJS(esm_exports));
    var debug_1 = __importDefault(require_browser2());
    var debug = debug_1.default("socket.io-client:socket");
    var RESERVED_EVENTS = Object.freeze({
      connect: 1,
      connect_error: 1,
      disconnect: 1,
      disconnecting: 1,
      // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
      newListener: 1,
      removeListener: 1
    });
    var Socket = class extends component_emitter_1.Emitter {
      /**
       * `Socket` constructor.
       */
      constructor(io, nsp, opts) {
        super();
        this.connected = false;
        this.receiveBuffer = [];
        this.sendBuffer = [];
        this.ids = 0;
        this.acks = {};
        this.flags = {};
        this.io = io;
        this.nsp = nsp;
        if (opts && opts.auth) {
          this.auth = opts.auth;
        }
        if (this.io._autoConnect)
          this.open();
      }
      /**
       * Whether the socket is currently disconnected
       *
       * @example
       * const socket = io();
       *
       * socket.on("connect", () => {
       *   console.log(socket.disconnected); // false
       * });
       *
       * socket.on("disconnect", () => {
       *   console.log(socket.disconnected); // true
       * });
       */
      get disconnected() {
        return !this.connected;
      }
      /**
       * Subscribe to open, close and packet events
       *
       * @private
       */
      subEvents() {
        if (this.subs)
          return;
        const io = this.io;
        this.subs = [
          on_js_1.on(io, "open", this.onopen.bind(this)),
          on_js_1.on(io, "packet", this.onpacket.bind(this)),
          on_js_1.on(io, "error", this.onerror.bind(this)),
          on_js_1.on(io, "close", this.onclose.bind(this))
        ];
      }
      /**
       * Whether the Socket will try to reconnect when its Manager connects or reconnects.
       *
       * @example
       * const socket = io();
       *
       * console.log(socket.active); // true
       *
       * socket.on("disconnect", (reason) => {
       *   if (reason === "io server disconnect") {
       *     // the disconnection was initiated by the server, you need to manually reconnect
       *     console.log(socket.active); // false
       *   }
       *   // else the socket will automatically try to reconnect
       *   console.log(socket.active); // true
       * });
       */
      get active() {
        return !!this.subs;
      }
      /**
       * "Opens" the socket.
       *
       * @example
       * const socket = io({
       *   autoConnect: false
       * });
       *
       * socket.connect();
       */
      connect() {
        if (this.connected)
          return this;
        this.subEvents();
        if (!this.io["_reconnecting"])
          this.io.open();
        if ("open" === this.io._readyState)
          this.onopen();
        return this;
      }
      /**
       * Alias for {@link connect()}.
       */
      open() {
        return this.connect();
      }
      /**
       * Sends a `message` event.
       *
       * This method mimics the WebSocket.send() method.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
       *
       * @example
       * socket.send("hello");
       *
       * // this is equivalent to
       * socket.emit("message", "hello");
       *
       * @return self
       */
      send(...args) {
        args.unshift("message");
        this.emit.apply(this, args);
        return this;
      }
      /**
       * Override `emit`.
       * If the event is in `events`, it's emitted normally.
       *
       * @example
       * socket.emit("hello", "world");
       *
       * // all serializable datastructures are supported (no need to call JSON.stringify)
       * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
       *
       * // with an acknowledgement from the server
       * socket.emit("hello", "world", (val) => {
       *   // ...
       * });
       *
       * @return self
       */
      emit(ev, ...args) {
        if (RESERVED_EVENTS.hasOwnProperty(ev)) {
          throw new Error('"' + ev.toString() + '" is a reserved event name');
        }
        args.unshift(ev);
        const packet = {
          type: socket_io_parser_1.PacketType.EVENT,
          data: args
        };
        packet.options = {};
        packet.options.compress = this.flags.compress !== false;
        if ("function" === typeof args[args.length - 1]) {
          const id = this.ids++;
          debug("emitting packet with ack id %d", id);
          const ack = args.pop();
          this._registerAckCallback(id, ack);
          packet.id = id;
        }
        const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
        if (discardPacket) {
          debug("discard packet as the transport is not currently writable");
        } else if (this.connected) {
          this.notifyOutgoingListeners(packet);
          this.packet(packet);
        } else {
          this.sendBuffer.push(packet);
        }
        this.flags = {};
        return this;
      }
      /**
       * @private
       */
      _registerAckCallback(id, ack) {
        const timeout = this.flags.timeout;
        if (timeout === void 0) {
          this.acks[id] = ack;
          return;
        }
        const timer = this.io.setTimeoutFn(() => {
          delete this.acks[id];
          for (let i = 0; i < this.sendBuffer.length; i++) {
            if (this.sendBuffer[i].id === id) {
              debug("removing packet with ack id %d from the buffer", id);
              this.sendBuffer.splice(i, 1);
            }
          }
          debug("event with ack id %d has timed out after %d ms", id, timeout);
          ack.call(this, new Error("operation has timed out"));
        }, timeout);
        this.acks[id] = (...args) => {
          this.io.clearTimeoutFn(timer);
          ack.apply(this, [null, ...args]);
        };
      }
      /**
       * Sends a packet.
       *
       * @param packet
       * @private
       */
      packet(packet) {
        packet.nsp = this.nsp;
        this.io._packet(packet);
      }
      /**
       * Called upon engine `open`.
       *
       * @private
       */
      onopen() {
        debug("transport is open - connecting");
        if (typeof this.auth == "function") {
          this.auth((data) => {
            this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data });
          });
        } else {
          this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data: this.auth });
        }
      }
      /**
       * Called upon engine or manager `error`.
       *
       * @param err
       * @private
       */
      onerror(err) {
        if (!this.connected) {
          this.emitReserved("connect_error", err);
        }
      }
      /**
       * Called upon engine `close`.
       *
       * @param reason
       * @param description
       * @private
       */
      onclose(reason, description) {
        debug("close (%s)", reason);
        this.connected = false;
        delete this.id;
        this.emitReserved("disconnect", reason, description);
      }
      /**
       * Called with socket packet.
       *
       * @param packet
       * @private
       */
      onpacket(packet) {
        const sameNamespace = packet.nsp === this.nsp;
        if (!sameNamespace)
          return;
        switch (packet.type) {
          case socket_io_parser_1.PacketType.CONNECT:
            if (packet.data && packet.data.sid) {
              const id = packet.data.sid;
              this.onconnect(id);
            } else {
              this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
            }
            break;
          case socket_io_parser_1.PacketType.EVENT:
          case socket_io_parser_1.PacketType.BINARY_EVENT:
            this.onevent(packet);
            break;
          case socket_io_parser_1.PacketType.ACK:
          case socket_io_parser_1.PacketType.BINARY_ACK:
            this.onack(packet);
            break;
          case socket_io_parser_1.PacketType.DISCONNECT:
            this.ondisconnect();
            break;
          case socket_io_parser_1.PacketType.CONNECT_ERROR:
            this.destroy();
            const err = new Error(packet.data.message);
            err.data = packet.data.data;
            this.emitReserved("connect_error", err);
            break;
        }
      }
      /**
       * Called upon a server event.
       *
       * @param packet
       * @private
       */
      onevent(packet) {
        const args = packet.data || [];
        debug("emitting event %j", args);
        if (null != packet.id) {
          debug("attaching ack callback to event");
          args.push(this.ack(packet.id));
        }
        if (this.connected) {
          this.emitEvent(args);
        } else {
          this.receiveBuffer.push(Object.freeze(args));
        }
      }
      emitEvent(args) {
        if (this._anyListeners && this._anyListeners.length) {
          const listeners = this._anyListeners.slice();
          for (const listener of listeners) {
            listener.apply(this, args);
          }
        }
        super.emit.apply(this, args);
      }
      /**
       * Produces an ack callback to emit with an event.
       *
       * @private
       */
      ack(id) {
        const self2 = this;
        let sent = false;
        return function(...args) {
          if (sent)
            return;
          sent = true;
          debug("sending ack %j", args);
          self2.packet({
            type: socket_io_parser_1.PacketType.ACK,
            id,
            data: args
          });
        };
      }
      /**
       * Called upon a server acknowlegement.
       *
       * @param packet
       * @private
       */
      onack(packet) {
        const ack = this.acks[packet.id];
        if ("function" === typeof ack) {
          debug("calling ack %s with %j", packet.id, packet.data);
          ack.apply(this, packet.data);
          delete this.acks[packet.id];
        } else {
          debug("bad ack %s", packet.id);
        }
      }
      /**
       * Called upon server connect.
       *
       * @private
       */
      onconnect(id) {
        debug("socket connected with id %s", id);
        this.id = id;
        this.connected = true;
        this.emitBuffered();
        this.emitReserved("connect");
      }
      /**
       * Emit buffered events (received and emitted).
       *
       * @private
       */
      emitBuffered() {
        this.receiveBuffer.forEach((args) => this.emitEvent(args));
        this.receiveBuffer = [];
        this.sendBuffer.forEach((packet) => {
          this.notifyOutgoingListeners(packet);
          this.packet(packet);
        });
        this.sendBuffer = [];
      }
      /**
       * Called upon server disconnect.
       *
       * @private
       */
      ondisconnect() {
        debug("server disconnect (%s)", this.nsp);
        this.destroy();
        this.onclose("io server disconnect");
      }
      /**
       * Called upon forced client/server side disconnections,
       * this method ensures the manager stops tracking us and
       * that reconnections don't get triggered for this.
       *
       * @private
       */
      destroy() {
        if (this.subs) {
          this.subs.forEach((subDestroy) => subDestroy());
          this.subs = void 0;
        }
        this.io["_destroy"](this);
      }
      /**
       * Disconnects the socket manually. In that case, the socket will not try to reconnect.
       *
       * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
       *
       * @example
       * const socket = io();
       *
       * socket.on("disconnect", (reason) => {
       *   // console.log(reason); prints "io client disconnect"
       * });
       *
       * socket.disconnect();
       *
       * @return self
       */
      disconnect() {
        if (this.connected) {
          debug("performing disconnect (%s)", this.nsp);
          this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
        }
        this.destroy();
        if (this.connected) {
          this.onclose("io client disconnect");
        }
        return this;
      }
      /**
       * Alias for {@link disconnect()}.
       *
       * @return self
       */
      close() {
        return this.disconnect();
      }
      /**
       * Sets the compress flag.
       *
       * @example
       * socket.compress(false).emit("hello");
       *
       * @param compress - if `true`, compresses the sending data
       * @return self
       */
      compress(compress) {
        this.flags.compress = compress;
        return this;
      }
      /**
       * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
       * ready to send messages.
       *
       * @example
       * socket.volatile.emit("hello"); // the server may or may not receive it
       *
       * @returns self
       */
      get volatile() {
        this.flags.volatile = true;
        return this;
      }
      /**
       * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
       * given number of milliseconds have elapsed without an acknowledgement from the server:
       *
       * @example
       * socket.timeout(5000).emit("my-event", (err) => {
       *   if (err) {
       *     // the server did not acknowledge the event in the given delay
       *   }
       * });
       *
       * @returns self
       */
      timeout(timeout) {
        this.flags.timeout = timeout;
        return this;
      }
      /**
       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
       * callback.
       *
       * @example
       * socket.onAny((event, ...args) => {
       *   console.log(`got ${event}`);
       * });
       *
       * @param listener
       */
      onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
      }
      /**
       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
       * callback. The listener is added to the beginning of the listeners array.
       *
       * @example
       * socket.prependAny((event, ...args) => {
       *   console.log(`got event ${event}`);
       * });
       *
       * @param listener
       */
      prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
      }
      /**
       * Removes the listener that will be fired when any event is emitted.
       *
       * @example
       * const catchAllListener = (event, ...args) => {
       *   console.log(`got event ${event}`);
       * }
       *
       * socket.onAny(catchAllListener);
       *
       * // remove a specific listener
       * socket.offAny(catchAllListener);
       *
       * // or remove all listeners
       * socket.offAny();
       *
       * @param listener
       */
      offAny(listener) {
        if (!this._anyListeners) {
          return this;
        }
        if (listener) {
          const listeners = this._anyListeners;
          for (let i = 0; i < listeners.length; i++) {
            if (listener === listeners[i]) {
              listeners.splice(i, 1);
              return this;
            }
          }
        } else {
          this._anyListeners = [];
        }
        return this;
      }
      /**
       * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
       * e.g. to remove listeners.
       */
      listenersAny() {
        return this._anyListeners || [];
      }
      /**
       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
       * callback.
       *
       * Note: acknowledgements sent to the server are not included.
       *
       * @example
       * socket.onAnyOutgoing((event, ...args) => {
       *   console.log(`sent event ${event}`);
       * });
       *
       * @param listener
       */
      onAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.push(listener);
        return this;
      }
      /**
       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
       * callback. The listener is added to the beginning of the listeners array.
       *
       * Note: acknowledgements sent to the server are not included.
       *
       * @example
       * socket.prependAnyOutgoing((event, ...args) => {
       *   console.log(`sent event ${event}`);
       * });
       *
       * @param listener
       */
      prependAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.unshift(listener);
        return this;
      }
      /**
       * Removes the listener that will be fired when any event is emitted.
       *
       * @example
       * const catchAllListener = (event, ...args) => {
       *   console.log(`sent event ${event}`);
       * }
       *
       * socket.onAnyOutgoing(catchAllListener);
       *
       * // remove a specific listener
       * socket.offAnyOutgoing(catchAllListener);
       *
       * // or remove all listeners
       * socket.offAnyOutgoing();
       *
       * @param [listener] - the catch-all listener (optional)
       */
      offAnyOutgoing(listener) {
        if (!this._anyOutgoingListeners) {
          return this;
        }
        if (listener) {
          const listeners = this._anyOutgoingListeners;
          for (let i = 0; i < listeners.length; i++) {
            if (listener === listeners[i]) {
              listeners.splice(i, 1);
              return this;
            }
          }
        } else {
          this._anyOutgoingListeners = [];
        }
        return this;
      }
      /**
       * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
       * e.g. to remove listeners.
       */
      listenersAnyOutgoing() {
        return this._anyOutgoingListeners || [];
      }
      /**
       * Notify the listeners for each packet sent
       *
       * @param packet
       *
       * @private
       */
      notifyOutgoingListeners(packet) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
          const listeners = this._anyOutgoingListeners.slice();
          for (const listener of listeners) {
            listener.apply(this, packet.data);
          }
        }
      }
    };
    exports.Socket = Socket;
  }
});

// node_modules/socket.io-client/build/cjs/contrib/backo2.js
var require_backo2 = __commonJS({
  "node_modules/socket.io-client/build/cjs/contrib/backo2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Backoff = void 0;
    function Backoff(opts) {
      opts = opts || {};
      this.ms = opts.min || 100;
      this.max = opts.max || 1e4;
      this.factor = opts.factor || 2;
      this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
      this.attempts = 0;
    }
    exports.Backoff = Backoff;
    Backoff.prototype.duration = function() {
      var ms = this.ms * Math.pow(this.factor, this.attempts++);
      if (this.jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
      }
      return Math.min(ms, this.max) | 0;
    };
    Backoff.prototype.reset = function() {
      this.attempts = 0;
    };
    Backoff.prototype.setMin = function(min) {
      this.ms = min;
    };
    Backoff.prototype.setMax = function(max) {
      this.max = max;
    };
    Backoff.prototype.setJitter = function(jitter) {
      this.jitter = jitter;
    };
  }
});

// node_modules/socket.io-client/build/cjs/manager.js
var require_manager = __commonJS({
  "node_modules/socket.io-client/build/cjs/manager.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Manager = void 0;
    var engine_io_client_1 = require_cjs2();
    var socket_js_1 = require_socket2();
    var parser = __importStar(require_cjs3());
    var on_js_1 = require_on();
    var backo2_js_1 = require_backo2();
    var component_emitter_1 = (init_esm(), __toCommonJS(esm_exports));
    var debug_1 = __importDefault(require_browser2());
    var debug = debug_1.default("socket.io-client:manager");
    var Manager = class extends component_emitter_1.Emitter {
      constructor(uri, opts) {
        var _a;
        super();
        this.nsps = {};
        this.subs = [];
        if (uri && "object" === typeof uri) {
          opts = uri;
          uri = void 0;
        }
        opts = opts || {};
        opts.path = opts.path || "/socket.io";
        this.opts = opts;
        engine_io_client_1.installTimerFunctions(this, opts);
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1e3);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
        this.backoff = new backo2_js_1.Backoff({
          min: this.reconnectionDelay(),
          max: this.reconnectionDelayMax(),
          jitter: this.randomizationFactor()
        });
        this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
        this._readyState = "closed";
        this.uri = uri;
        const _parser = opts.parser || parser;
        this.encoder = new _parser.Encoder();
        this.decoder = new _parser.Decoder();
        this._autoConnect = opts.autoConnect !== false;
        if (this._autoConnect)
          this.open();
      }
      reconnection(v) {
        if (!arguments.length)
          return this._reconnection;
        this._reconnection = !!v;
        return this;
      }
      reconnectionAttempts(v) {
        if (v === void 0)
          return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
      }
      reconnectionDelay(v) {
        var _a;
        if (v === void 0)
          return this._reconnectionDelay;
        this._reconnectionDelay = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
        return this;
      }
      randomizationFactor(v) {
        var _a;
        if (v === void 0)
          return this._randomizationFactor;
        this._randomizationFactor = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
        return this;
      }
      reconnectionDelayMax(v) {
        var _a;
        if (v === void 0)
          return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
        return this;
      }
      timeout(v) {
        if (!arguments.length)
          return this._timeout;
        this._timeout = v;
        return this;
      }
      /**
       * Starts trying to reconnect if reconnection is enabled and we have not
       * started reconnecting yet
       *
       * @private
       */
      maybeReconnectOnOpen() {
        if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
          this.reconnect();
        }
      }
      /**
       * Sets the current transport `socket`.
       *
       * @param {Function} fn - optional, callback
       * @return self
       * @public
       */
      open(fn) {
        debug("readyState %s", this._readyState);
        if (~this._readyState.indexOf("open"))
          return this;
        debug("opening %s", this.uri);
        this.engine = new engine_io_client_1.Socket(this.uri, this.opts);
        const socket = this.engine;
        const self2 = this;
        this._readyState = "opening";
        this.skipReconnect = false;
        const openSubDestroy = on_js_1.on(socket, "open", function() {
          self2.onopen();
          fn && fn();
        });
        const errorSub = on_js_1.on(socket, "error", (err) => {
          debug("error");
          self2.cleanup();
          self2._readyState = "closed";
          this.emitReserved("error", err);
          if (fn) {
            fn(err);
          } else {
            self2.maybeReconnectOnOpen();
          }
        });
        if (false !== this._timeout) {
          const timeout = this._timeout;
          debug("connect attempt will timeout after %d", timeout);
          if (timeout === 0) {
            openSubDestroy();
          }
          const timer = this.setTimeoutFn(() => {
            debug("connect attempt timed out after %d", timeout);
            openSubDestroy();
            socket.close();
            socket.emit("error", new Error("timeout"));
          }, timeout);
          if (this.opts.autoUnref) {
            timer.unref();
          }
          this.subs.push(function subDestroy() {
            clearTimeout(timer);
          });
        }
        this.subs.push(openSubDestroy);
        this.subs.push(errorSub);
        return this;
      }
      /**
       * Alias for open()
       *
       * @return self
       * @public
       */
      connect(fn) {
        return this.open(fn);
      }
      /**
       * Called upon transport open.
       *
       * @private
       */
      onopen() {
        debug("open");
        this.cleanup();
        this._readyState = "open";
        this.emitReserved("open");
        const socket = this.engine;
        this.subs.push(on_js_1.on(socket, "ping", this.onping.bind(this)), on_js_1.on(socket, "data", this.ondata.bind(this)), on_js_1.on(socket, "error", this.onerror.bind(this)), on_js_1.on(socket, "close", this.onclose.bind(this)), on_js_1.on(this.decoder, "decoded", this.ondecoded.bind(this)));
      }
      /**
       * Called upon a ping.
       *
       * @private
       */
      onping() {
        this.emitReserved("ping");
      }
      /**
       * Called with data.
       *
       * @private
       */
      ondata(data) {
        try {
          this.decoder.add(data);
        } catch (e) {
          this.onclose("parse error", e);
        }
      }
      /**
       * Called when parser fully decodes a packet.
       *
       * @private
       */
      ondecoded(packet) {
        engine_io_client_1.nextTick(() => {
          this.emitReserved("packet", packet);
        }, this.setTimeoutFn);
      }
      /**
       * Called upon socket error.
       *
       * @private
       */
      onerror(err) {
        debug("error", err);
        this.emitReserved("error", err);
      }
      /**
       * Creates a new socket for the given `nsp`.
       *
       * @return {Socket}
       * @public
       */
      socket(nsp, opts) {
        let socket = this.nsps[nsp];
        if (!socket) {
          socket = new socket_js_1.Socket(this, nsp, opts);
          this.nsps[nsp] = socket;
        }
        return socket;
      }
      /**
       * Called upon a socket close.
       *
       * @param socket
       * @private
       */
      _destroy(socket) {
        const nsps = Object.keys(this.nsps);
        for (const nsp of nsps) {
          const socket2 = this.nsps[nsp];
          if (socket2.active) {
            debug("socket %s is still active, skipping close", nsp);
            return;
          }
        }
        this._close();
      }
      /**
       * Writes a packet.
       *
       * @param packet
       * @private
       */
      _packet(packet) {
        debug("writing packet %j", packet);
        const encodedPackets = this.encoder.encode(packet);
        for (let i = 0; i < encodedPackets.length; i++) {
          this.engine.write(encodedPackets[i], packet.options);
        }
      }
      /**
       * Clean up transport subscriptions and packet buffer.
       *
       * @private
       */
      cleanup() {
        debug("cleanup");
        this.subs.forEach((subDestroy) => subDestroy());
        this.subs.length = 0;
        this.decoder.destroy();
      }
      /**
       * Close the current socket.
       *
       * @private
       */
      _close() {
        debug("disconnect");
        this.skipReconnect = true;
        this._reconnecting = false;
        this.onclose("forced close");
        if (this.engine)
          this.engine.close();
      }
      /**
       * Alias for close()
       *
       * @private
       */
      disconnect() {
        return this._close();
      }
      /**
       * Called upon engine close.
       *
       * @private
       */
      onclose(reason, description) {
        debug("closed due to %s", reason);
        this.cleanup();
        this.backoff.reset();
        this._readyState = "closed";
        this.emitReserved("close", reason, description);
        if (this._reconnection && !this.skipReconnect) {
          this.reconnect();
        }
      }
      /**
       * Attempt a reconnection.
       *
       * @private
       */
      reconnect() {
        if (this._reconnecting || this.skipReconnect)
          return this;
        const self2 = this;
        if (this.backoff.attempts >= this._reconnectionAttempts) {
          debug("reconnect failed");
          this.backoff.reset();
          this.emitReserved("reconnect_failed");
          this._reconnecting = false;
        } else {
          const delay = this.backoff.duration();
          debug("will wait %dms before reconnect attempt", delay);
          this._reconnecting = true;
          const timer = this.setTimeoutFn(() => {
            if (self2.skipReconnect)
              return;
            debug("attempting reconnect");
            this.emitReserved("reconnect_attempt", self2.backoff.attempts);
            if (self2.skipReconnect)
              return;
            self2.open((err) => {
              if (err) {
                debug("reconnect attempt error");
                self2._reconnecting = false;
                self2.reconnect();
                this.emitReserved("reconnect_error", err);
              } else {
                debug("reconnect success");
                self2.onreconnect();
              }
            });
          }, delay);
          if (this.opts.autoUnref) {
            timer.unref();
          }
          this.subs.push(function subDestroy() {
            clearTimeout(timer);
          });
        }
      }
      /**
       * Called upon successful reconnect.
       *
       * @private
       */
      onreconnect() {
        const attempt = this.backoff.attempts;
        this._reconnecting = false;
        this.backoff.reset();
        this.emitReserved("reconnect", attempt);
      }
    };
    exports.Manager = Manager;
  }
});

// node_modules/socket.io-client/build/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/socket.io-client/build/cjs/index.js"(exports, module) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = exports.connect = exports.io = exports.Socket = exports.Manager = exports.protocol = void 0;
    var url_js_1 = require_url();
    var manager_js_1 = require_manager();
    Object.defineProperty(exports, "Manager", { enumerable: true, get: function() {
      return manager_js_1.Manager;
    } });
    var socket_js_1 = require_socket2();
    Object.defineProperty(exports, "Socket", { enumerable: true, get: function() {
      return socket_js_1.Socket;
    } });
    var debug_1 = __importDefault(require_browser2());
    var debug = debug_1.default("socket.io-client");
    var cache = {};
    function lookup(uri, opts) {
      if (typeof uri === "object") {
        opts = uri;
        uri = void 0;
      }
      opts = opts || {};
      const parsed = url_js_1.url(uri, opts.path || "/socket.io");
      const source = parsed.source;
      const id = parsed.id;
      const path = parsed.path;
      const sameNamespace = cache[id] && path in cache[id]["nsps"];
      const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
      let io;
      if (newConnection) {
        debug("ignoring socket cache for %s", source);
        io = new manager_js_1.Manager(source, opts);
      } else {
        if (!cache[id]) {
          debug("new io instance for %s", source);
          cache[id] = new manager_js_1.Manager(source, opts);
        }
        io = cache[id];
      }
      if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
      }
      return io.socket(parsed.path, opts);
    }
    exports.io = lookup;
    exports.connect = lookup;
    exports.default = lookup;
    Object.assign(lookup, {
      Manager: manager_js_1.Manager,
      Socket: socket_js_1.Socket,
      io: lookup,
      connect: lookup
    });
    var socket_io_parser_1 = require_cjs3();
    Object.defineProperty(exports, "protocol", { enumerable: true, get: function() {
      return socket_io_parser_1.protocol;
    } });
    module.exports = lookup;
  }
});

// node_modules/snack-sdk/build/transports/ConnectionMetricsEmitter.js
var require_ConnectionMetricsEmitter = __commonJS({
  "node_modules/snack-sdk/build/transports/ConnectionMetricsEmitter.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var METRICS_FAILED_FOR_RECONNECT_ATTEMPTS = 5;
    var ConnectionMetricsEmitter = (
      /** @class */
      function() {
        function ConnectionMetricsEmitter2() {
          this.listener = null;
        }
        ConnectionMetricsEmitter2.prototype.emitSuccessed = function(payload) {
          if (this.lastEmitState === void 0 || this.lastEmitState === "TRANSPORT_CONNECTION_FAILED") {
            this.emit(__assign({ name: "TRANSPORT_CONNECTION_SUCCEEDED" }, payload));
            this.lastEmitState = "TRANSPORT_CONNECTION_SUCCEEDED";
          }
        };
        ConnectionMetricsEmitter2.prototype.emitFailed = function(payload) {
          if (this.lastEmitState === void 0 && payload.attempts >= METRICS_FAILED_FOR_RECONNECT_ATTEMPTS) {
            this.emit(__assign({ name: "TRANSPORT_CONNECTION_FAILED" }, payload));
            this.lastEmitState = "TRANSPORT_CONNECTION_FAILED";
          }
        };
        ConnectionMetricsEmitter2.prototype.resetState = function() {
          this.lastEmitState = void 0;
        };
        ConnectionMetricsEmitter2.prototype.setUpdateListener = function(listener) {
          this.listener = listener;
        };
        ConnectionMetricsEmitter2.prototype.emit = function(event) {
          var _a;
          (_a = this.listener) === null || _a === void 0 ? void 0 : _a.call(this, event);
        };
        return ConnectionMetricsEmitter2;
      }()
    );
    exports.default = new ConnectionMetricsEmitter();
  }
});

// node_modules/snack-sdk/build/transports/TransportImplSocketIO.js
var require_TransportImplSocketIO = __commonJS({
  "node_modules/snack-sdk/build/transports/TransportImplSocketIO.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var socket_io_client_1 = require_cjs4();
    var ConnectionMetricsEmitter_1 = __importDefault(require_ConnectionMetricsEmitter());
    var TransportImplBase_1 = __importDefault(require_TransportImplBase());
    var TransportImplSocketIO = (
      /** @class */
      function(_super) {
        __extends(TransportImplSocketIO2, _super);
        function TransportImplSocketIO2(options) {
          var _this = _super.call(this, options) || this;
          _this.socket = null;
          _this.onMessage = function(data) {
            var sender = data.sender, message = data.message;
            _this.handleMessage(sender, message);
          };
          _this.onJoinChannel = function(data) {
            var _a;
            var sender = data.sender;
            if (sender !== "" && sender !== ((_a = _this.socket) === null || _a === void 0 ? void 0 : _a.id)) {
              _this.handleChannelEvent("join", sender);
            }
          };
          _this.onLeaveChannel = function(data) {
            var _a;
            var sender = data.sender;
            if (sender !== "" && sender !== ((_a = _this.socket) === null || _a === void 0 ? void 0 : _a.id)) {
              _this.handleChannelEvent("leave", sender);
            }
          };
          var snackpubURL = options.snackpubURL;
          if (!snackpubURL) {
            throw new Error("The `snackpubURL` option is unspecified.");
          }
          _this.snackpubURL = snackpubURL;
          _this.connectionAttempts = 0;
          return _this;
        }
        TransportImplSocketIO2.prototype.start = function() {
          var _this = this;
          this.stop();
          this.startTime = Date.now();
          this.socket = socket_io_client_1.io(this.snackpubURL, { transports: ["websocket"] });
          this.socket.on("connect", function() {
            var _a, _b;
            (_a = _this.socket) === null || _a === void 0 ? void 0 : _a.emit("subscribeChannel", { channel: _this.channel, sender: (_b = _this.socket) === null || _b === void 0 ? void 0 : _b.id });
            if (_this.startTime) {
              ConnectionMetricsEmitter_1.default.emitSuccessed({
                timeMs: Date.now() - _this.startTime,
                attempts: _this.connectionAttempts
              });
            }
          });
          this.socket.io.on("reconnect_attempt", function(attempts) {
            _this.connectionAttempts = attempts;
            if (_this.startTime) {
              ConnectionMetricsEmitter_1.default.emitFailed({
                timeMs: Date.now() - _this.startTime,
                attempts
              });
            }
          });
          this.socket.on("message", this.onMessage);
          this.socket.on("joinChannel", this.onJoinChannel);
          this.socket.on("leaveChannel", this.onLeaveChannel);
          this.socket.on("terminate", function(reason) {
            var _a, _b;
            (_a = _this.logger) === null || _a === void 0 ? void 0 : _a.comm("Terminating connection: " + reason);
            (_b = _this.socket) === null || _b === void 0 ? void 0 : _b.disconnect();
          });
        };
        TransportImplSocketIO2.prototype.stop = function() {
          var _a;
          if (this.socket != null) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.comm("Stopping...", this.logSuffix);
            this.socket.offAny();
            this.socket.close();
            this.socket = null;
          }
          this.startTime = void 0;
        };
        TransportImplSocketIO2.prototype.isStarted = function() {
          return this.socket != null;
        };
        TransportImplSocketIO2.prototype.sendAsync = function(channel, message) {
          var _a;
          (_a = this.socket) === null || _a === void 0 ? void 0 : _a.emit("message", {
            channel,
            message,
            sender: this.socket.id
          });
          return Promise.resolve();
        };
        TransportImplSocketIO2.prototype.onVerifyCodeMessageSize = function(codeMessage) {
          var approxSize = 0;
          for (var path in codeMessage.diff) {
            approxSize += path.length + codeMessage.diff[path].length;
          }
          return approxSize < TransportImplBase_1.default.CODE_SIZE_LIMIT_FOR_DIFF;
        };
        return TransportImplSocketIO2;
      }(TransportImplBase_1.default)
    );
    exports.default = TransportImplSocketIO;
  }
});

// node_modules/snack-sdk/build/transports/TrafficMirroringTransport.js
var require_TrafficMirroringTransport = __commonJS({
  "node_modules/snack-sdk/build/transports/TrafficMirroringTransport.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var TransportImplPubNub_1 = __importDefault(require_TransportImplPubNub());
    var TransportImplSocketIO_1 = __importDefault(require_TransportImplSocketIO());
    var TrafficMirroringTransport = (
      /** @class */
      function() {
        function TrafficMirroringTransport2(options) {
          this.transports = [new TransportImplPubNub_1.default(options), new TransportImplSocketIO_1.default(options)];
        }
        TrafficMirroringTransport2.prototype.addEventListener = function(type, listener) {
          for (var _i = 0, _a = this.transports; _i < _a.length; _i++) {
            var transport = _a[_i];
            transport.addEventListener(type, listener);
          }
        };
        TrafficMirroringTransport2.prototype.removeEventListener = function(type, listener) {
          for (var _i = 0, _a = this.transports; _i < _a.length; _i++) {
            var transport = _a[_i];
            transport.removeEventListener(type, listener);
          }
        };
        TrafficMirroringTransport2.prototype.postMessage = function(message) {
          for (var _i = 0, _a = this.transports; _i < _a.length; _i++) {
            var transport = _a[_i];
            transport.postMessage(message);
          }
        };
        return TrafficMirroringTransport2;
      }()
    );
    exports.default = TrafficMirroringTransport;
  }
});

// node_modules/snack-sdk/build/transports/types.js
var require_types2 = __commonJS({
  "node_modules/snack-sdk/build/transports/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/snack-sdk/build/transports/index.js
var require_transports2 = __commonJS({
  "node_modules/snack-sdk/build/transports/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTrafficMirroringTransport = exports.createTransport = exports.ConnectionMetricsEmitter = void 0;
    var TrafficMirroringTransport_1 = __importDefault(require_TrafficMirroringTransport());
    var TransportImplSocketIO_1 = __importDefault(require_TransportImplSocketIO());
    __exportStar(require_types2(), exports);
    __exportStar(require_ConnectionMetricsEmitter(), exports);
    var ConnectionMetricsEmitter_1 = require_ConnectionMetricsEmitter();
    Object.defineProperty(exports, "ConnectionMetricsEmitter", { enumerable: true, get: function() {
      return __importDefault(ConnectionMetricsEmitter_1).default;
    } });
    function createTransport(options) {
      return new TransportImplSocketIO_1.default(options);
    }
    exports.createTransport = createTransport;
    function createTrafficMirroringTransport(options) {
      return new TrafficMirroringTransport_1.default(options);
    }
    exports.createTrafficMirroringTransport = createTrafficMirroringTransport;
  }
});

// node_modules/snack-sdk/build/transports/TransportImplWebPlayer.js
var require_TransportImplWebPlayer = __commonJS({
  "node_modules/snack-sdk/build/transports/TransportImplWebPlayer.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert_1 = __importDefault(require_assert());
    var TransportImplBase_1 = __importDefault(require_TransportImplBase());
    var TransportImplWebPlayer = (
      /** @class */
      function(_super) {
        __extends(TransportImplWebPlayer2, _super);
        function TransportImplWebPlayer2(config) {
          var _this = _super.call(this, { name: config.name, verbose: config.verbose }) || this;
          _this.status = "stopped";
          _this.handleDomWindowMessage = function(event) {
            var _a;
            if (event.origin === _this.origin) {
              try {
                var message = JSON.parse(event.data);
                var type = message.type;
                if (type === "CONNECT") {
                  var connectionId = JSON.stringify(message.device);
                  _this.handleChannelEvent("join", connectionId);
                } else if (type === "DISCONNECT") {
                  var connectionId = JSON.stringify(message.device);
                  _this.handleChannelEvent("leave", connectionId);
                } else if (type === "MESSAGE") {
                  var connectionId = JSON.stringify(message.message.device);
                  _this.handleMessage(connectionId, message.message);
                }
              } catch (_b) {
                (_a = _this.logger) === null || _a === void 0 ? void 0 : _a.warn("Invalid message", event.data);
              }
            }
          };
          var origin = new URL(config.webPlayerURL).origin;
          _this.currentWindow = config.window;
          _this.targetWindowRef = config.ref;
          _this.status = "stopped";
          _this.origin = origin;
          return _this;
        }
        TransportImplWebPlayer2.prototype.start = function() {
          var _a;
          assert_1.default(this.currentWindow);
          (_a = this.currentWindow) === null || _a === void 0 ? void 0 : _a.addEventListener("message", this.handleDomWindowMessage, false);
          this.status = "started";
        };
        TransportImplWebPlayer2.prototype.stop = function() {
          assert_1.default(this.currentWindow);
          this.currentWindow.removeEventListener("message", this.handleDomWindowMessage, false);
          this.currentWindow = void 0;
          this.targetWindowRef = void 0;
          this.status = "stopped";
        };
        TransportImplWebPlayer2.prototype.isStarted = function() {
          return this.status === "started" && this.currentWindow != null;
        };
        TransportImplWebPlayer2.prototype.sendAsync = function(channel, message) {
          var _a;
          return __awaiter(this, void 0, void 0, function() {
            var targetWindow;
            return __generator(this, function(_b) {
              assert_1.default(this.isStarted);
              targetWindow = (_a = this.targetWindowRef) === null || _a === void 0 ? void 0 : _a.current;
              assert_1.default(targetWindow);
              targetWindow.postMessage(JSON.stringify(message), this.origin);
              return [
                2
                /*return*/
              ];
            });
          });
        };
        TransportImplWebPlayer2.prototype.onVerifyCodeMessageSize = function(codeMessage) {
          return true;
        };
        return TransportImplWebPlayer2;
      }(TransportImplBase_1.default)
    );
    exports.default = TransportImplWebPlayer;
  }
});

// node_modules/snack-sdk/build/transports/webPlayer.js
var require_webPlayer = __commonJS({
  "node_modules/snack-sdk/build/transports/webPlayer.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWebPlayerIFrameURL = exports.createWebPlayerTransport = void 0;
    var TransportImplWebPlayer_1 = __importDefault(require_TransportImplWebPlayer());
    function createWebPlayerTransport(config) {
      return new TransportImplWebPlayer_1.default(config);
    }
    exports.createWebPlayerTransport = createWebPlayerTransport;
    function getWebPlayerIFrameURL(webPlayerURL, sdkVersion, initialURL, verbose) {
      if (sdkVersion < "40.0.0" || typeof window === "undefined") {
        return void 0;
      }
      return webPlayerURL.replace("%%SDK_VERSION%%", sdkVersion.split(".")[0]) + "/index.html?initialUrl=" + encodeURIComponent(initialURL) + "&origin=" + encodeURIComponent(window.location.origin) + "&verbose=" + verbose;
    }
    exports.getWebPlayerIFrameURL = getWebPlayerIFrameURL;
  }
});

// node_modules/snack-sdk/build/Session.js
var require_Session = __commonJS({
  "node_modules/snack-sdk/build/Session.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var mapValues_1 = __importDefault(require_mapValues());
    var nullthrows_1 = __importDefault(require_nullthrows());
    var snack_content_1 = require_build();
    var DependencyResolver_1 = __importStar(require_DependencyResolver());
    var DevSession_1 = __importDefault(require_DevSession());
    var FileUploader_1 = __importDefault(require_FileUploader());
    var Logger_1 = require_Logger();
    var State = __importStar(require_State());
    var WantedVersions_1 = require_WantedVersions();
    var defaultConfig_1 = __importStar(require_defaultConfig());
    var transports_1 = require_transports2();
    var webPlayer_1 = require_webPlayer();
    var utils_1 = require_utils();
    var Snack = (
      /** @class */
      function() {
        function Snack2(options) {
          var _this = this;
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
          this.stateListeners = /* @__PURE__ */ new Set();
          this.logListeners = /* @__PURE__ */ new Set();
          this.transportListeners = {};
          this.uploadAssetAsync = function(contents) {
            return __awaiter(_this, void 0, void 0, function() {
              var url, fileUploader;
              return __generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    url = "";
                    fileUploader = new FileUploader_1.default({
                      apiURL: this.apiURL,
                      logger: this.logger,
                      callback: function(_request, resultURL, error) {
                        if (error) {
                          throw error;
                        } else if (resultURL) {
                          url = resultURL;
                        }
                      }
                    });
                    fileUploader.add("asset", {
                      type: "ASSET",
                      contents
                    });
                    return [4, fileUploader.waitForCompletion()];
                  case 1:
                    _a2.sent();
                    return [2, url];
                }
              });
            });
          };
          this.onFileUploaded = function(request, resultURL, error) {
            _this.setState(function(_a2) {
              var files = _a2.files;
              return {
                files: State.addObject(files, request.path, __assign(__assign(__assign({}, request.file), resultURL ? { contents: resultURL } : {}), error ? { error } : {}))
              };
            });
          };
          this.onWantedDependencyVersions = function(_sdkVersion, result, error) {
            var wantedDependencyVersions = error ? {} : result;
            _this.setState(function(_a2) {
              var dependencies2 = _a2.dependencies, sdkVersion2 = _a2.sdkVersion;
              return {
                wantedDependencyVersions,
                missingDependencies: DependencyResolver_1.getMissingDependencies(dependencies2, sdkVersion2, wantedDependencyVersions)
              };
            });
          };
          this.onDependencyResolved = function(request, result, error) {
            _this.setState(function(_a2) {
              var dependencies2 = _a2.dependencies, sdkVersion2 = _a2.sdkVersion, wantedDependencyVersions = _a2.wantedDependencyVersions;
              var newDependencies = State.addObject(dependencies2, request.name, __assign(__assign(__assign(__assign({}, dependencies2[request.name]), { version: request.version }), result ? {
                handle: result.handle,
                peerDependencies: result.dependencies
              } : {}), error ? { error } : {}));
              return newDependencies !== dependencies2 ? {
                dependencies: newDependencies,
                missingDependencies: DependencyResolver_1.getMissingDependencies(newDependencies, sdkVersion2, wantedDependencyVersions)
              } : null;
            });
          };
          this.onDevSessionSendBeaconCloseRequest = function(sendBeaconCloseRequest) {
            _this.setState(function(_state) {
              return {
                sendBeaconCloseRequest
              };
            });
          };
          this.onTransportEvent = function(transport, event) {
            var _a2, _b2, _c2;
            var type = event.type, data = event.data;
            var connectionId = event.connectionId;
            switch (type) {
              case "connect":
                (_a2 = _this.logger) === null || _a2 === void 0 ? void 0 : _a2.comm("Client connected (" + transport + ")", connectionId);
                _this.onClientConnected(transport, connectionId, data);
                break;
              case "disconnect":
                (_b2 = _this.logger) === null || _b2 === void 0 ? void 0 : _b2.comm("Client disconnected (" + transport + ")", connectionId, data);
                _this.onClientDisconnected(transport, connectionId, data);
                break;
              case "protocol_message":
                (_c2 = _this.logger) === null || _c2 === void 0 ? void 0 : _c2.comm_recv("Message received (" + transport + ")", connectionId, data);
                _this.onProtocolMessageReceived(transport, connectionId, event.data);
                break;
              case "send_message":
                _this.onProtocolMessageSent(transport, event.data);
                break;
            }
          };
          var channel = utils_1.createChannel(options.channel);
          var sdkVersion = snack_content_1.validateSDKVersion((_a = options.sdkVersion) !== null && _a !== void 0 ? _a : defaultConfig_1.default.sdkVersion);
          var dependencies = options.dependencies ? __assign({}, options.dependencies) : {};
          this.options = options;
          this.apiURL = (_b = options.apiURL) !== null && _b !== void 0 ? _b : defaultConfig_1.default.apiURL;
          this.snackpubURL = (_c = options.snackpubURL) !== null && _c !== void 0 ? _c : defaultConfig_1.default.snackpubURL;
          this.runtimeEndpoint = (_d = options.runtimeEndpoint) !== null && _d !== void 0 ? _d : snack_content_1.SNACK_RUNTIME_URL_ENDPOINT;
          this.logger = options.verbose ? Logger_1.createLogger(true) : void 0;
          this.codeChangesDelay = (_e = options.codeChangesDelay) !== null && _e !== void 0 ? _e : 0;
          this.reloadTimeout = (_f = options.reloadTimeout) !== null && _f !== void 0 ? _f : 0;
          this.previewTimeout = (_g = options.previewTimeout) !== null && _g !== void 0 ? _g : 1e4;
          this.createTransport = (_h = options.createTransport) !== null && _h !== void 0 ? _h : transports_1.createTransport;
          var webPlayerURL = (_j = options.webPlayerURL) !== null && _j !== void 0 ? _j : defaultConfig_1.default.webPlayerURL;
          var transports = (_k = options.transports) !== null && _k !== void 0 ? _k : {};
          if (options.online) {
            transports = State.addObject(transports, "pubsub", this.createTransport({
              name: "pubsub",
              channel,
              verbose: options.verbose,
              apiURL: this.apiURL,
              snackpubURL: this.snackpubURL
            }));
          }
          if (options.webPreviewRef) {
            transports = State.addObject(transports, "webplayer", webPlayer_1.createWebPlayerTransport({
              ref: options.webPreviewRef,
              verbose: options.verbose,
              window: nullthrows_1.default(typeof window !== "undefined" ? window : global),
              webPlayerURL
            }));
          }
          this.state = this.updateDerivedState({
            disabled: !!options.disabled,
            unsaved: false,
            name: (_l = options.name) !== null && _l !== void 0 ? _l : "",
            description: (_m = options.description) !== null && _m !== void 0 ? _m : "",
            sdkVersion,
            files: (_o = options.files) !== null && _o !== void 0 ? _o : {},
            dependencies,
            missingDependencies: DependencyResolver_1.getMissingDependencies(dependencies, sdkVersion),
            connectedClients: {},
            transports,
            user: options.user,
            id: options.id,
            saveURL: options.id ? utils_1.createURL(this.runtimeEndpoint, sdkVersion, void 0, options.id) : void 0,
            savedSDKVersion: options.id ? sdkVersion : void 0,
            online: false,
            url: utils_1.createURL(this.runtimeEndpoint, sdkVersion, channel, options.id),
            channel,
            deviceId: options.deviceId,
            snackId: options.snackId,
            accountSnackId: options.accountSnackId,
            webPlayerURL
          }, defaultConfig_1.SnackIdentityState);
          this.state.unsaved = false;
          this.wantedDependencyVersions = new WantedVersions_1.WantedDependencyVersions({
            apiUrl: this.apiURL,
            logger: this.logger,
            callback: this.onWantedDependencyVersions
          });
          this.dependencyResolver = new DependencyResolver_1.default({
            snackagerURL: (_p = options.snackagerURL) !== null && _p !== void 0 ? _p : defaultConfig_1.default.snackagerURL,
            logger: this.logger,
            callback: this.onDependencyResolved
          });
          this.fileUploader = new FileUploader_1.default({
            apiURL: this.apiURL,
            logger: this.logger,
            callback: this.onFileUploaded
          });
          this.DevSession = new DevSession_1.default({
            apiURL: this.apiURL,
            logger: this.logger,
            onSendBeaconCloseRequest: this.onDevSessionSendBeaconCloseRequest
          });
          (_q = this.logger) === null || _q === void 0 ? void 0 : _q.info("Snack created", this.getState());
          this.onStateChanged(this.state, defaultConfig_1.SnackIdentityState);
        }
        Snack2.prototype.setSDKVersion = function(sdkVersion) {
          snack_content_1.validateSDKVersion(sdkVersion);
          return this.setState(function(state) {
            return state.sdkVersion !== sdkVersion ? {
              sdkVersion,
              missingDependencies: DependencyResolver_1.getMissingDependencies(state.dependencies, sdkVersion, state.wantedDependencyVersions)
            } : null;
          });
        };
        Snack2.prototype.setName = function(name) {
          return this.setState(function(state) {
            return state.name !== name ? { name } : null;
          });
        };
        Snack2.prototype.setDescription = function(description) {
          return this.setState(function(state) {
            return state.description !== description ? { description } : null;
          });
        };
        Snack2.prototype.setUser = function(user) {
          return this.setState(function(state) {
            return state.user !== user ? { user } : null;
          });
        };
        Snack2.prototype.setDeviceId = function(deviceId) {
          return this.setState(function(state) {
            return state.deviceId !== deviceId ? { deviceId } : null;
          });
        };
        Snack2.prototype.setFocus = function() {
          this.DevSession.setFocus(this.state);
        };
        Snack2.prototype.setCodeChangesDelay = function(delay) {
          if (this.codeChangesDelay !== delay) {
            this.codeChangesDelay = delay;
            this._sendCodeChangesDebounced(this.state);
          }
        };
        Snack2.prototype.setWebPlayerURL = function(webPlayerURL) {
          var _this = this;
          this.setState(function(state) {
            var newWebPlayerURL = webPlayerURL !== null && webPlayerURL !== void 0 ? webPlayerURL : defaultConfig_1.default.webPlayerURL;
            if (state.webPlayerURL !== newWebPlayerURL && _this.options.webPreviewRef) {
              var transports = state.transports;
              transports = State.addObject(transports, "webplayer", webPlayer_1.createWebPlayerTransport({
                ref: _this.options.webPreviewRef,
                verbose: _this.options.verbose,
                window: nullthrows_1.default(typeof window !== "undefined" ? window : global),
                webPlayerURL: newWebPlayerURL
              }));
              return { webPlayerURL: newWebPlayerURL, transports };
            }
            return null;
          });
        };
        Snack2.prototype.sendCodeChanges = function() {
          this._sendCodeChangesDebounced(this.state, true);
        };
        Snack2.prototype._sendCodeChangesDebounced = function(state, immediate) {
          var _this = this;
          if (this.codeChangesTimer) {
            clearTimeout(this.codeChangesTimer);
            this.codeChangesTimer = void 0;
          }
          if (!immediate && this.codeChangesDelay > 0) {
            this.codeChangesTimer = setTimeout(function() {
              return _this._sendCodeChangesDebounced(state, true);
            }, this.codeChangesDelay);
            return;
          } else if (!immediate && this.codeChangesDelay < 0) {
            return;
          }
          var transports = state.transports, files = state.files, dependencies = state.dependencies, sdkVersion = state.sdkVersion;
          for (var key in transports) {
            transports[key].postMessage({
              type: "update_code",
              data: {
                files,
                dependencies,
                sdkVersion
              }
            });
          }
        };
        Snack2.prototype.saveAsync = function(options) {
          var _a, _b, _c, _d, _e, _f;
          return __awaiter(this, void 0, void 0, function() {
            var prevState, _g, name, description, sdkVersion, files, dependencies, user, payload, previewPromise, url, response, data, id_1, saveURL_1, hashId, accountSnackId_1, snackId_1, e_1;
            var _this = this;
            return __generator(this, function(_h) {
              switch (_h.label) {
                case 0:
                  prevState = this.state;
                  return [4, this.fileUploader.waitForCompletion()];
                case 1:
                  _h.sent();
                  _g = this.state, name = _g.name, description = _g.description, sdkVersion = _g.sdkVersion, files = _g.files, dependencies = _g.dependencies, user = _g.user;
                  _h.label = 2;
                case 2:
                  _h.trys.push([2, 5, , 6]);
                  payload = {
                    manifest: {
                      sdkVersion,
                      name,
                      description,
                      dependencies: mapValues_1.default(dependencies, function(dep) {
                        return dep.version;
                      })
                    },
                    code: mapValues_1.default(files, function(file) {
                      file = __assign({}, file);
                      delete file.error;
                      return file;
                    }),
                    dependencies: mapValues_1.default(dependencies, function(dep) {
                      dep = __assign({}, dep);
                      delete dep.error;
                      return dep;
                    }),
                    isDraft: (_a = options === null || options === void 0 ? void 0 : options.isDraft) !== null && _a !== void 0 ? _a : false
                  };
                  (_b = this.logger) === null || _b === void 0 ? void 0 : _b.info("Saving...", payload);
                  previewPromise = this.getPreviewAsync();
                  url = this.apiURL + "/--/api/v2/snack/save";
                  return [4, utils_1.fetch(url, {
                    method: "POST",
                    body: JSON.stringify(payload),
                    headers: __assign({ "Content-Type": "application/json" }, (options === null || options === void 0 ? void 0 : options.ignoreUser) ? {} : utils_1.createUserHeader(user))
                  })];
                case 3:
                  response = _h.sent();
                  return [4, response.json()];
                case 4:
                  data = _h.sent();
                  if (!(data === null || data === void 0 ? void 0 : data.id)) {
                    throw new Error(((_d = (_c = data.errors) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.message) || "Failed to save");
                  }
                  (_e = this.logger) === null || _e === void 0 ? void 0 : _e.info("Saved", data);
                  id_1 = data.id;
                  saveURL_1 = utils_1.createURL(this.runtimeEndpoint, sdkVersion, void 0, id_1);
                  hashId = data.hashId;
                  accountSnackId_1 = data.accountSnackId;
                  snackId_1 = data.snackId;
                  this.setState(function(state) {
                    return {
                      id: id_1,
                      saveURL: saveURL_1,
                      unsaved: State.isUnsaved(state, prevState),
                      savedSDKVersion: (options === null || options === void 0 ? void 0 : options.isDraft) && state.savedSDKVersion ? state.savedSDKVersion : sdkVersion,
                      accountSnackId: accountSnackId_1,
                      snackId: snackId_1
                    };
                  });
                  previewPromise.then(function(connectedClients) {
                    var conns = Object.values(connectedClients).filter(function(c) {
                      return c.previewURL;
                    }).sort(function(a, b) {
                      var _a2, _b2;
                      return ((_a2 = a.previewTimestamp) !== null && _a2 !== void 0 ? _a2 : 0) - ((_b2 = b.previewTimestamp) !== null && _b2 !== void 0 ? _b2 : 0);
                    });
                    if (conns.length) {
                      _this.uploadPreview(id_1, conns[0].previewURL, conns[0].status !== "error");
                    }
                  });
                  return [2, {
                    id: id_1,
                    url: saveURL_1,
                    hashId,
                    accountSnackId: accountSnackId_1,
                    snackId: snackId_1
                  }];
                case 5:
                  e_1 = _h.sent();
                  (_f = this.logger) === null || _f === void 0 ? void 0 : _f.error(e_1);
                  throw e_1;
                case 6:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        Snack2.prototype.getDownloadURLAsync = function(saveOptions) {
          return __awaiter(this, void 0, void 0, function() {
            var state;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.fileUploader.waitForCompletion()];
                case 1:
                  _a.sent();
                  state = this.getState();
                  if (!(!state.id || state.unsaved)) return [3, 3];
                  return [4, this.saveAsync(saveOptions)];
                case 2:
                  _a.sent();
                  state = this.getState();
                  _a.label = 3;
                case 3:
                  return [2, this.apiURL + "/--/api/v2/snack/download/" + state.id];
              }
            });
          });
        };
        Snack2.prototype.uploadPreview = function(id, previewURL, status) {
          var _a, _b, _c, _d, _e, _f;
          return __awaiter(this, void 0, void 0, function() {
            var url, payload, response, data, e_2;
            return __generator(this, function(_g) {
              switch (_g.label) {
                case 0:
                  url = this.apiURL + "/--/api/v2/snack/updateMetadata";
                  payload = {
                    id,
                    previewLocation: previewURL,
                    status: status ? "SUCCESS" : "FAILURE"
                  };
                  (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info("Uploading preview...", payload);
                  _g.label = 1;
                case 1:
                  _g.trys.push([1, 4, , 5]);
                  return [4, utils_1.fetch(url, {
                    method: "POST",
                    body: JSON.stringify(payload),
                    headers: {
                      "Content-Type": "application/json"
                    }
                  })];
                case 2:
                  response = _g.sent();
                  return [4, response.json()];
                case 3:
                  data = _g.sent();
                  if (data.id) {
                    (_b = this.logger) === null || _b === void 0 ? void 0 : _b.info("Uploaded preview", data);
                  } else {
                    throw new Error((_e = (_d = (_c = data.errors) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.message) !== null && _e !== void 0 ? _e : "Unknown error");
                  }
                  return [3, 5];
                case 4:
                  e_2 = _g.sent();
                  (_f = this.logger) === null || _f === void 0 ? void 0 : _f.error("Failed to upload preview", e_2);
                  return [3, 5];
                case 5:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        Snack2.prototype.getState = function() {
          return this.state;
        };
        Snack2.prototype.getStateAsync = function() {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this.wantedDependencyVersions.waitForCompletion()];
                case 1:
                  _a.sent();
                  return [4, this.dependencyResolver.waitForCompletion()];
                case 2:
                  _a.sent();
                  return [4, this.fileUploader.waitForCompletion()];
                case 3:
                  _a.sent();
                  return [2, this.getState()];
              }
            });
          });
        };
        Snack2.prototype.addStateListener = function(listener) {
          var _this = this;
          this.stateListeners.add(listener);
          return function() {
            return _this.stateListeners.delete(listener);
          };
        };
        Snack2.prototype.setState = function(stateFn) {
          var update = stateFn(this.state);
          if (update) {
            var oldState_1 = this.state;
            var newState_1 = __assign(__assign({}, oldState_1), update);
            this.state = this.updateDerivedState(newState_1, oldState_1);
            this.onStateChanged(newState_1, oldState_1);
            this.stateListeners.forEach(function(listener) {
              return listener(newState_1, oldState_1);
            });
          }
        };
        Snack2.prototype.updateDerivedState = function(state, prevState) {
          state.unsaved = state.unsaved || State.isUnsaved(state, prevState);
          this.updateDerivedOnlineState(state, prevState);
          this.updateDerivedDependenciesState(state, prevState);
          this.updateDerivedWebPreviewState(state, prevState);
          return state;
        };
        Snack2.prototype.onStateChanged = function(state, prevState) {
          this.updateWantedDependencyVersions(state, prevState);
          this.updateDependencyResolver(state, prevState);
          this.updateFileUploader(state, prevState);
          this.updateTransports(state, prevState);
          this.DevSession.setState(state, prevState);
        };
        Snack2.prototype.updateFiles = function(files) {
          return this.setState(function(state) {
            var newFiles = State.updateObjects(state.files, files);
            return newFiles !== state.files ? { files: newFiles } : null;
          });
        };
        Snack2.prototype.updateFileUploader = function(state, prevState) {
          var _a;
          var files = state.files;
          var prevFiles = prevState.files;
          if (!prevState.disabled && (!state.disabled && files !== prevFiles || state.disabled)) {
            for (var path in prevFiles) {
              if (!files[path] || files[path].contents !== prevFiles[path].contents || state.disabled) {
                this.fileUploader.remove(path, prevFiles[path]);
              }
            }
          }
          if (!state.disabled && (files !== prevFiles || prevState.disabled)) {
            for (var path in files) {
              var file = files[path];
              if (file.type === "ASSET" && typeof file.contents === "object" && !file.error && (((_a = prevFiles[path]) === null || _a === void 0 ? void 0 : _a.contents) !== file.contents || prevState.disabled)) {
                this.fileUploader.add(path, file);
              }
            }
          }
        };
        Snack2.prototype.updateDependencies = function(dependencies) {
          return this.setState(function(state) {
            var newDependencies = State.updateObjects(state.dependencies, dependencies);
            return newDependencies !== state.dependencies ? {
              dependencies: newDependencies,
              missingDependencies: DependencyResolver_1.getMissingDependencies(newDependencies, state.sdkVersion, state.wantedDependencyVersions)
            } : null;
          });
        };
        Snack2.prototype.updateDerivedDependenciesState = function(state, prevState) {
          var _a, _b, _c, _d;
          if (state.wantedDependencyVersions !== prevState.wantedDependencyVersions || state.dependencies !== prevState.dependencies) {
            for (var name_1 in state.dependencies) {
              var dep = state.dependencies[name_1];
              var wantedVersion = (_d = (_b = (_a = state.wantedDependencyVersions) === null || _a === void 0 ? void 0 : _a[name_1]) !== null && _b !== void 0 ? _b : (_c = state.wantedDependencyVersions) === null || _c === void 0 ? void 0 : _c[DependencyResolver_1.getPackageName(name_1)]) !== null && _d !== void 0 ? _d : void 0;
              if (dep.wantedVersion !== wantedVersion) {
                state.dependencies = state.dependencies === prevState.dependencies ? __assign({}, state.dependencies) : state.dependencies;
                var version = (dep.version === "*" || dep.wantedVersion && dep.version === dep.wantedVersion) && wantedVersion ? wantedVersion : dep.version;
                state.dependencies[name_1] = __assign(__assign({}, dep), {
                  version,
                  wantedVersion
                });
                if (dep.handle && dep.version !== version) {
                  delete state.dependencies[name_1].handle;
                }
              }
            }
          }
          if (state.dependencies !== prevState.dependencies) {
            for (var name_2 in state.dependencies) {
              var dep = state.dependencies[name_2];
              if (dep !== prevState.dependencies[name_2]) {
                var error = DependencyResolver_1.verifyDependency(name_2, dep.version);
                if (error) {
                  state.dependencies[name_2] = __assign(__assign({}, dep), { error });
                }
              }
            }
          }
        };
        Snack2.prototype.updateWantedDependencyVersions = function(state, _prevState) {
          if (!state.disabled && Object.keys(state.dependencies).length) {
            this.wantedDependencyVersions.setSDKVersion(state.sdkVersion);
          }
        };
        Snack2.prototype.updateDependencyResolver = function(state, prevState) {
          var _a, _b, _c;
          var dependencies = state.dependencies;
          var prevDependencies = prevState.dependencies;
          if (!prevState.disabled && (dependencies !== prevDependencies || state.disabled || state.sdkVersion !== prevState.sdkVersion)) {
            for (var name_3 in prevDependencies) {
              if (!dependencies[name_3] || dependencies[name_3].version !== prevDependencies[name_3].version || state.disabled || snack_content_1.isModulePreloaded(name_3, state.sdkVersion) && !snack_content_1.isModulePreloaded(name_3, prevState.sdkVersion)) {
                this.dependencyResolver.remove(name_3, prevDependencies[name_3].version, prevState.sdkVersion);
              }
            }
          }
          if (!state.disabled && (dependencies !== prevDependencies || prevState.disabled || state.sdkVersion !== prevState.sdkVersion || state.wantedDependencyVersions !== prevState.wantedDependencyVersions)) {
            for (var name_4 in dependencies) {
              var dependency = dependencies[name_4];
              if (!dependency.handle && !dependency.error && !snack_content_1.isModulePreloaded(name_4, state.sdkVersion) && !(dependency.version === "*" && !state.wantedDependencyVersions) && (((_a = prevDependencies[name_4]) === null || _a === void 0 ? void 0 : _a.version) !== dependency.version || dependency.version === "*" && !prevState.wantedDependencyVersions || ((_b = prevDependencies[name_4]) === null || _b === void 0 ? void 0 : _b.handle) || ((_c = prevDependencies[name_4]) === null || _c === void 0 ? void 0 : _c.error) || prevState.disabled)) {
                this.dependencyResolver.add(name_4, dependency.version, state.sdkVersion);
              }
            }
          }
        };
        Snack2.prototype.setDisabled = function(disabled) {
          return this.setState(function(state) {
            return disabled !== state.disabled ? { disabled } : null;
          });
        };
        Snack2.prototype.setOnline = function(enabled) {
          var _this = this;
          return this.setState(function(state) {
            if (enabled && !state.transports["pubsub"]) {
              return {
                transports: State.addObject(state.transports, "pubsub", _this.createTransport({
                  name: "pubsub",
                  apiURL: _this.apiURL,
                  snackpubURL: _this.snackpubURL,
                  channel: state.channel,
                  verbose: !!_this.logger
                }))
              };
            } else if (!enabled && state.transports["pubsub"]) {
              var connectedClients = state.connectedClients;
              for (var key in state.connectedClients) {
                if (state.connectedClients[key].transport === "pubsub") {
                  connectedClients = State.removeObject(connectedClients, key);
                }
              }
              return {
                transports: State.removeObject(state.transports, "pubsub"),
                connectedClients
              };
            } else {
              return null;
            }
          });
        };
        Snack2.prototype.updateDerivedOnlineState = function(state, prevState) {
          var transports = state.transports, sdkVersion = state.sdkVersion, channel = state.channel, id = state.id, name = state.name, disabled = state.disabled, savedSDKVersion = state.savedSDKVersion;
          if (transports !== prevState.transports || sdkVersion !== prevState.sdkVersion || channel !== prevState.channel || id !== prevState.id || name !== prevState.name || savedSDKVersion !== prevState.savedSDKVersion) {
            state.online = !!transports["pubsub"] && !disabled;
            state.url = utils_1.createURL(this.runtimeEndpoint, sdkVersion, channel, savedSDKVersion && savedSDKVersion !== sdkVersion ? void 0 : id);
            state.onlineName = "" + (name || "Unnamed Snack");
          }
        };
        Snack2.prototype.updateDerivedWebPreviewState = function(state, prevState) {
          var transports = state.transports, sdkVersion = state.sdkVersion, url = state.url, webPlayerURL = state.webPlayerURL;
          if (url && !prevState.url || sdkVersion !== prevState.sdkVersion || webPlayerURL !== prevState.webPlayerURL) {
            state.webPreviewURL = transports["webplayer"] && webPlayerURL ? webPlayer_1.getWebPlayerIFrameURL(webPlayerURL, sdkVersion, url, !!this.logger) : void 0;
          }
        };
        Snack2.prototype.reloadConnectedClients = function() {
          var _a;
          var connectedTransports = /* @__PURE__ */ new Set();
          this.setState(function(state) {
            var connectedClients = state.connectedClients;
            for (var key in state.connectedClients) {
              var connectedClient = state.connectedClients[key];
              connectedTransports.add(state.transports[connectedClient.transport]);
              connectedClients = State.addObject(connectedClients, key, __assign(__assign({}, connectedClient), { status: "reloading" }));
            }
            return connectedClients !== state.connectedClients ? { connectedClients } : null;
          });
          var reloadMessage = {
            type: "RELOAD_SNACK"
          };
          if (connectedTransports.size) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.comm("Reloading...");
            connectedTransports.forEach(function(transport) {
              transport.postMessage({
                type: "protocol_message",
                data: reloadMessage
              });
            });
          }
        };
        Snack2.prototype.getPreviewAsync = function() {
          var _this = this;
          var _a;
          var _b = this.state, connectedClients = _b.connectedClients, transports = _b.transports;
          var connectedTransports = /* @__PURE__ */ new Set();
          Object.values(connectedClients).forEach(function(_a2) {
            var transport = _a2.transport;
            return connectedTransports.add(transports[transport]);
          });
          if (!connectedTransports.size) {
            return Promise.resolve(connectedClients);
          }
          var requestStatusMessage = {
            type: "REQUEST_STATUS"
          };
          if (connectedTransports.size) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.comm("Requesting preview...");
            connectedTransports.forEach(function(transport) {
              transport.postMessage({
                type: "protocol_message",
                data: requestStatusMessage
              });
            });
          }
          return new Promise(function(resolve, reject) {
            var timeoutTimer;
            var completedConnections = /* @__PURE__ */ new Set();
            var unsubscribe = _this.addStateListener(function(state, prevState) {
              var _a2;
              if (state.connectedClients !== prevState.connectedClients) {
                for (var key in connectedClients) {
                  if (connectedClients[key].previewTimestamp !== ((_a2 = state.connectedClients[key]) === null || _a2 === void 0 ? void 0 : _a2.previewTimestamp) || !state.connectedClients[key]) {
                    completedConnections.add(key);
                    if (completedConnections.size === Object.values(connectedClients).length) {
                      unsubscribe();
                      clearTimeout(timeoutTimer);
                      resolve(state.connectedClients);
                      return;
                    }
                  }
                }
              }
            });
            timeoutTimer = setTimeout(function() {
              unsubscribe();
              reject(new Error("Operation timed out"));
            }, _this.previewTimeout);
          });
        };
        Snack2.prototype.updateTransports = function(state, prevState) {
          var _this = this;
          var transports = state.transports;
          var prevTransports = prevState.transports;
          if (!prevState.disabled && (transports !== prevTransports || state.disabled)) {
            for (var id in prevTransports) {
              if (this.transportListeners[id] && (transports[id] !== prevTransports[id] || state.disabled)) {
                prevTransports[id].removeEventListener("message", this.transportListeners[id]);
                delete this.transportListeners[id];
                prevTransports[id].postMessage({ type: "stop" });
              }
            }
          }
          if (!state.disabled && (transports !== prevTransports || prevState.disabled)) {
            var _loop_1 = function(id2) {
              if (!this_1.transportListeners[id2] && (transports[id2] !== prevTransports[id2] || prevState.disabled)) {
                this_1.transportListeners[id2] = function(event) {
                  return _this.onTransportEvent(id2, event);
                };
                transports[id2].addEventListener("message", this_1.transportListeners[id2]);
                transports[id2].postMessage({ type: "start" });
              }
            };
            var this_1 = this;
            for (var id in transports) {
              _loop_1(id);
            }
          }
          if (!state.disabled && !State.isBusy(state) && (transports !== prevTransports || State.isCodeChanged(state, prevState) || prevState.disabled)) {
            this._sendCodeChangesDebounced(state, prevTransports !== transports || !State.isBusy(state) && State.isBusy(prevState));
          }
        };
        Snack2.prototype.onClientConnected = function(transport, connectedClientId, data) {
          this.setState(function(state) {
            return {
              connectedClients: State.addObject(state.connectedClients, connectedClientId, {
                transport,
                id: data.id,
                name: data.name,
                platform: data.platform,
                status: "ok"
              })
            };
          });
        };
        Snack2.prototype.onClientDisconnected = function(_transport, connectedClientId, _data) {
          var _this = this;
          this.setState(function(state) {
            var connectedClient = state.connectedClients[connectedClientId];
            if ((connectedClient === null || connectedClient === void 0 ? void 0 : connectedClient.status) === "reloading" && _this.reloadTimeout >= 0) {
              if (_this.pruneConnectionsTimer) {
                clearTimeout(_this.pruneConnectionsTimer);
                _this.pruneConnectionsTimer = void 0;
              }
              _this.pruneConnectionsTimer = setTimeout(function() {
                _this.pruneConnectionsTimer = void 0;
                _this.setState(function(state2) {
                  var connectedClients2 = state2.connectedClients;
                  for (var key in state2.connectedClients) {
                    if (state2.connectedClients[key].status === "reloading") {
                      connectedClients2 = State.removeObject(connectedClients2, key);
                    }
                  }
                  return connectedClients2 !== state2.connectedClients ? { connectedClients: connectedClients2 } : null;
                });
              }, _this.reloadTimeout);
              return null;
            } else {
              var connectedClients = State.removeObject(state.connectedClients, connectedClientId);
              return connectedClients !== state.connectedClients ? { connectedClients } : null;
            }
          });
        };
        Snack2.prototype.addLogListener = function(listener) {
          var _this = this;
          this.logListeners.add(listener);
          return function() {
            return _this.logListeners.delete(listener);
          };
        };
        Snack2.prototype.onProtocolMessageReceived = function(transport, connectedClientId, message) {
          var _a;
          if (!this.state.connectedClients[connectedClientId]) {
            return;
          }
          switch (message.type) {
            case "CONSOLE":
              this.onConsoleMessageReceived(connectedClientId, message);
              break;
            case "ERROR":
              this.onErrorMessageReceived(connectedClientId, message);
              break;
            case "STATUS_REPORT":
              this.onStatusReportMessageReceived(connectedClientId, message);
              break;
            // @ts-ignore: CODE is echoed by pubsub, we ignore it
            case "CODE":
              break;
            // @ts-ignore: RELOAD_SNACK is echoed by pubsub, we ignore it
            case "RELOAD_SNACK":
              break;
            // @ts-ignore: REQUEST_STATUS is echoed by pubsub, we ignore it
            case "REQUEST_STATUS":
              break;
            default:
              (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error("Invalid message received", transport, message);
              break;
          }
        };
        Snack2.prototype.onProtocolMessageSent = function(transport, message) {
          switch (message.type) {
            case "CODE":
              this.setState(function(state) {
                var connectedClients = state.connectedClients;
                for (var connectedClientId in connectedClients) {
                  var connectedClient = connectedClients[connectedClientId];
                  if (connectedClient.transport === transport) {
                    connectedClients = State.addObject(connectedClients, connectedClientId, __assign(__assign({}, connectedClient), { error: void 0, status: connectedClient.status === "error" ? "ok" : connectedClient.status }));
                  }
                }
                return connectedClients !== state.connectedClients ? { connectedClients } : null;
              });
              break;
          }
        };
        Snack2.prototype.onConsoleMessageReceived = function(connectedClientId, message) {
          var payload = message.payload || [];
          var event = {
            type: message.method,
            connectedClient: this.state.connectedClients[connectedClientId],
            message: payload.join(" ")
          };
          this.logListeners.forEach(function(listener) {
            return listener(event);
          });
        };
        Snack2.prototype.onErrorMessageReceived = function(connectedClientId, message) {
          var _a, _b, _c;
          try {
            var json = JSON.parse(message.error);
            var error_1 = utils_1.createError({
              name: json.name || "Error",
              message: json.message || "",
              fileName: json.fileName,
              lineNumber: json.lineNumber || ((_a = json.loc) === null || _a === void 0 ? void 0 : _a.line) || json.line,
              columnNumber: json.columnNumber || ((_b = json.loc) === null || _b === void 0 ? void 0 : _b.column) || json.column,
              stack: json.stack
            });
            this.setState(function(state) {
              return {
                connectedClients: State.addObject(state.connectedClients, connectedClientId, __assign(__assign({}, state.connectedClients[connectedClientId]), { error: error_1, status: "error" }))
              };
            });
          } catch (_d) {
            (_c = this.logger) === null || _c === void 0 ? void 0 : _c.error("Failed to parse received error message", message);
          }
        };
        Snack2.prototype.onStatusReportMessageReceived = function(connectedClientId, message) {
          var previewLocation = message.previewLocation;
          this.setState(function(state) {
            return {
              connectedClients: State.addObject(state.connectedClients, connectedClientId, __assign(__assign({}, state.connectedClients[connectedClientId]), { previewURL: previewLocation, previewTimestamp: Date.now() }))
            };
          });
        };
        return Snack2;
      }()
    );
    exports.default = Snack;
  }
});

// node_modules/snack-sdk/build/types.js
var require_types3 = __commonJS({
  "node_modules/snack-sdk/build/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/snack-sdk/build/index.js
var require_build2 = __commonJS({
  "node_modules/snack-sdk/build/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseRuntimeUrl = exports.createRuntimeUrl = exports.Snack = exports.defaultConfig = exports.getDeprecatedModule = exports.standardizeDependencies = exports.isFeatureSupported = exports.getSupportedSDKVersions = exports.isValidSemver = exports.getPreloadedModules = exports.isModulePreloaded = void 0;
    var snack_content_1 = require_build();
    Object.defineProperty(exports, "isModulePreloaded", { enumerable: true, get: function() {
      return snack_content_1.isModulePreloaded;
    } });
    Object.defineProperty(exports, "getPreloadedModules", { enumerable: true, get: function() {
      return snack_content_1.getPreloadedModules;
    } });
    Object.defineProperty(exports, "isValidSemver", { enumerable: true, get: function() {
      return snack_content_1.isValidSemver;
    } });
    Object.defineProperty(exports, "getSupportedSDKVersions", { enumerable: true, get: function() {
      return snack_content_1.getSupportedSDKVersions;
    } });
    Object.defineProperty(exports, "isFeatureSupported", { enumerable: true, get: function() {
      return snack_content_1.isFeatureSupported;
    } });
    Object.defineProperty(exports, "standardizeDependencies", { enumerable: true, get: function() {
      return snack_content_1.standardizeDependencies;
    } });
    Object.defineProperty(exports, "getDeprecatedModule", { enumerable: true, get: function() {
      return snack_content_1.getDeprecatedModule;
    } });
    Object.defineProperty(exports, "createRuntimeUrl", { enumerable: true, get: function() {
      return snack_content_1.createRuntimeUrl;
    } });
    Object.defineProperty(exports, "parseRuntimeUrl", { enumerable: true, get: function() {
      return snack_content_1.parseRuntimeUrl;
    } });
    var Session_1 = __importDefault(require_Session());
    exports.Snack = Session_1.default;
    var defaultConfig_1 = __importDefault(require_defaultConfig());
    exports.defaultConfig = defaultConfig_1.default;
    __exportStar(require_transports2(), exports);
    __exportStar(require_types3(), exports);
  }
});
export default require_build2();
/*! Bundled license information:

pubnub/dist/web/pubnub.min.js:
  (*! *****************************************************************************
      Copyright (c) Microsoft Corporation.
  
      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.
  
      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** *)
  (*! lil-uuid - v0.1 - MIT License - https://github.com/lil-js/uuid *)

diff/dist/diff.js:
  (*!
  
   diff v4.0.1
  
  Software License Agreement (BSD License)
  
  Copyright (c) 2009-2015, Kevin Decker <kpdecker@gmail.com>
  
  All rights reserved.
  
  Redistribution and use of this software in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:
  
  * Redistributions of source code must retain the above
    copyright notice, this list of conditions and the
    following disclaimer.
  
  * Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the
    following disclaimer in the documentation and/or other
    materials provided with the distribution.
  
  * Neither the name of Kevin Decker nor the names of its
    contributors may be used to endorse or promote products
    derived from this software without specific prior
    written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  @license
  *)
*/
//# sourceMappingURL=snack-sdk.js.map
