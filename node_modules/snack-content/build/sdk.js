"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.standardizeDependencies = exports.isFeatureSupported = exports.isValidSemver = exports.getSupportedSDKVersions = exports.getDeprecatedModule = exports.validateSDKVersion = exports.getPreloadedModules = exports.isModulePreloaded = void 0;
const semver_1 = __importDefault(require("semver"));
const sdks_1 = __importDefault(require("./sdks"));
const features_1 = __importDefault(require("./sdks/features"));
/**
 * Checks whether a specific module/dependency is preloaded for the given SDK version.
 */
function isModulePreloaded(name, sdkVersion, coreModulesOnly) {
    const sdk = sdks_1.default[sdkVersion];
    if (!sdk)
        return false;
    return !!(sdk.coreModules[name] || (!coreModulesOnly && sdk.bundledModules[name]));
}
exports.isModulePreloaded = isModulePreloaded;
/**
 * Returns the list of pre-loaded modules for the given SDK version.
 */
function getPreloadedModules(sdkVersion, coreModulesOnly) {
    const sdk = sdks_1.default[sdkVersion];
    if (!sdk)
        return {};
    return coreModulesOnly
        ? sdk.coreModules
        : {
            ...sdk.coreModules,
            ...sdk.bundledModules,
        };
}
exports.getPreloadedModules = getPreloadedModules;
function validateSDKVersion(sdkVersion) {
    if (Object.keys(sdks_1.default).indexOf(sdkVersion) < 0) {
        throw new Error(`Invalid SDKVersion, the following versions are supported: ${Object.keys(sdks_1.default)}`);
    }
    return sdkVersion;
}
exports.validateSDKVersion = validateSDKVersion;
/**
 * Checks whether the module is deprecated for the given sdk-version and returns
 * the alternative module or error description instead. If the module is not deprecated
 * `undefined` is returned.
 */
function getDeprecatedModule(name, sdkVersion) {
    var _a, _b;
    return (_b = (_a = sdks_1.default[sdkVersion]) === null || _a === void 0 ? void 0 : _a.deprecatedModules) === null || _b === void 0 ? void 0 : _b[name];
}
exports.getDeprecatedModule = getDeprecatedModule;
/**
 * Returns the list of supported SDK versions.
 */
function getSupportedSDKVersions() {
    return Object.keys(sdks_1.default);
}
exports.getSupportedSDKVersions = getSupportedSDKVersions;
/**
 * Verifies whether a string is a valid semver.
 */
function isValidSemver(version) {
    return version === 'latest' || !!semver_1.default.validRange(version);
}
exports.isValidSemver = isValidSemver;
/**
 * Checks whether a feature is supported by the given SDK version.
 */
function isFeatureSupported(feature, sdkVersion) {
    const featureVersion = features_1.default[feature];
    if (!featureVersion) {
        throw new Error(`Invalid SDKFeature, the following versions are supported: ${Object.keys(features_1.default)}`);
    }
    return semver_1.default.gte(sdkVersion, featureVersion);
}
exports.isFeatureSupported = isFeatureSupported;
/**
 * Converts older dependency formats into the SnackDependencies type.
 */
function standardizeDependencies(dependencies) {
    let result = dependencies;
    for (const name in dependencies) {
        const dep = dependencies[name];
        if (typeof dep === 'string') {
            result = result === dependencies ? { ...dependencies } : result;
            result[name] = {
                version: dep,
            };
        }
        else if (typeof dep === 'object') {
            const peerDependencies = standardizePeerDependencies(dep.peerDependencies);
            if (dep.peerDependencies !== peerDependencies) {
                result = result === dependencies ? { ...dependencies } : result;
                result[name] = {
                    ...dep,
                    peerDependencies,
                };
            }
        }
        else {
            // Invalid dependency
            result = result === dependencies ? { ...dependencies } : result;
            delete result[name];
        }
    }
    return result;
}
exports.standardizeDependencies = standardizeDependencies;
/**
 * @internal
 */
function standardizePeerDependencies(peerDependencies) {
    if (!peerDependencies) {
        return peerDependencies;
    }
    let result = peerDependencies;
    for (const name in peerDependencies) {
        const peerDep = peerDependencies[name];
        if (typeof peerDep === 'string' || peerDep === null) {
            // :thumbsup: regular peer-dependency
        }
        else if (typeof peerDep === 'object' && typeof peerDep.version === 'string') {
            result = result === peerDependencies ? { ...peerDependencies } : result;
            result[name] = peerDep.version;
        }
        else {
            // Invalid peer-dependency
            result = result === peerDependencies ? { ...peerDependencies } : result;
            delete result[name];
        }
    }
    return result;
}
//# sourceMappingURL=sdk.js.map