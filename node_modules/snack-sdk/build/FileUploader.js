"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
var FileUploader = /** @class */ (function () {
    function FileUploader(options) {
        this.status = {};
        this.apiURL = options.apiURL;
        this.callback = options.callback;
        this.logger = options.logger;
    }
    FileUploader.prototype.add = function (path, file) {
        var status = this.status[path];
        if (status && status.file === file) {
            return status.promise;
        }
        this.status[path] = {
            file: file,
            promise: this.upload(path, file),
        };
        return this.status[path].promise;
    };
    FileUploader.prototype.remove = function (path, file) {
        var _a;
        if (!file || ((_a = this.status[path]) === null || _a === void 0 ? void 0 : _a.file) === file) {
            delete this.status[path];
        }
    };
    FileUploader.prototype.waitForCompletion = function () {
        return __awaiter(this, void 0, void 0, function () {
            var promises;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = Object.values(this.status).map(function (status) { return status.promise; });
                        _a.label = 1;
                    case 1:
                        if (!promises.length) return [3 /*break*/, 3];
                        return [4 /*yield*/, Promise.all(promises)];
                    case 2:
                        _a.sent();
                        promises = Object.values(this.status).map(function (status) { return status.promise; });
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    FileUploader.prototype.upload = function (path, file) {
        var _a, _b, _c, _d, _e, _f, _g;
        return __awaiter(this, void 0, void 0, function () {
            var url, input, formData, response, text, result, resultURL, e_1, error;
            return __generator(this, function (_h) {
                switch (_h.label) {
                    case 0:
                        _h.trys.push([0, 5, , 6]);
                        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.module('Uploading file', path, '...');
                        url = void 0;
                        input = void 0;
                        switch (file.type) {
                            case 'CODE':
                                url = this.apiURL + "/--/api/v2/snack/uploadCode";
                                input = {
                                    method: 'POST',
                                    body: JSON.stringify({ code: file.contents }),
                                    headers: { 'Content-Type': 'application/json' },
                                };
                                break;
                            case 'ASSET':
                                url = this.apiURL + "/--/api/v2/snack/uploadAsset";
                                if ((typeof FormData !== 'undefined' && file.contents instanceof FormData) ||
                                    (typeof file.contents === 'object' && ((_b = file.contents.constructor) === null || _b === void 0 ? void 0 : _b.name) === 'FormData')) {
                                    input = {
                                        method: 'POST',
                                        body: file.contents,
                                    };
                                }
                                else if (typeof FormData !== 'undefined') {
                                    formData = new FormData();
                                    // @ts-expect-error: file.contents can be both File or Blob
                                    formData.append('asset', file.contents, ((_c = file.contents) === null || _c === void 0 ? void 0 : _c.name) || path);
                                    input = {
                                        method: 'POST',
                                        body: formData,
                                    };
                                }
                                else {
                                    // TODO: Add support for uploading files using ArrayBuffer in body to the /snack/uploadAsset end-point
                                    // That way it's no longer neccessary to polyfill FormData is environments such as node.
                                    throw new Error('Uploading assets is not supported in this environment. Make sure FormData is polyfilled or provide the data as a FormData object');
                                }
                                break;
                            default:
                                // @ts-ignore: Property 'type' does not exist on type 'never'
                                throw new Error("Invalid file type " + file.type);
                        }
                        return [4 /*yield*/, utils_1.fetch(url, input)];
                    case 1:
                        response = _h.sent();
                        if (!!response.ok) return [3 /*break*/, 3];
                        return [4 /*yield*/, response.text()];
                    case 2:
                        text = _h.sent();
                        throw new Error(text);
                    case 3: return [4 /*yield*/, response.json()];
                    case 4:
                        result = _h.sent();
                        resultURL = result.url;
                        if (((_d = this.status[path]) === null || _d === void 0 ? void 0 : _d.file) === file) {
                            (_e = this.logger) === null || _e === void 0 ? void 0 : _e.module('Uploaded file', path, resultURL);
                            delete this.status[path];
                            try {
                                this.callback({ path: path, file: file }, resultURL);
                            }
                            catch (e) {
                                return [2 /*return*/, Promise.reject(e)];
                            }
                        }
                        return [3 /*break*/, 6];
                    case 5:
                        e_1 = _h.sent();
                        error = utils_1.createError({
                            message: "Failed to upload file " + path + " (" + e_1.message + ")",
                            fileName: path,
                        });
                        (_f = this.logger) === null || _f === void 0 ? void 0 : _f.error(error);
                        if (((_g = this.status[path]) === null || _g === void 0 ? void 0 : _g.file) === file) {
                            delete this.status[path];
                            this.callback({ path: path, file: file }, undefined, error);
                        }
                        return [3 /*break*/, 6];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    return FileUploader;
}());
exports.default = FileUploader;
//# sourceMappingURL=FileUploader.js.map