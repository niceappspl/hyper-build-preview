"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var mapValues_1 = __importDefault(require("lodash/mapValues"));
var nullthrows_1 = __importDefault(require("nullthrows"));
var snack_content_1 = require("snack-content");
var DependencyResolver_1 = __importStar(require("./DependencyResolver"));
var DevSession_1 = __importDefault(require("./DevSession"));
var FileUploader_1 = __importDefault(require("./FileUploader"));
var Logger_1 = require("./Logger");
var State = __importStar(require("./State"));
var WantedVersions_1 = require("./WantedVersions");
var defaultConfig_1 = __importStar(require("./defaultConfig"));
var transports_1 = require("./transports");
var webPlayer_1 = require("./transports/webPlayer");
var utils_1 = require("./utils");
var Snack = /** @class */ (function () {
    function Snack(options) {
        var _this = this;
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        this.stateListeners = new Set();
        this.logListeners = new Set();
        this.transportListeners = {};
        /**
         * Helper function that uploads an asset and returns its url.
         */
        this.uploadAssetAsync = function (contents) { return __awaiter(_this, void 0, void 0, function () {
            var url, fileUploader;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = '';
                        fileUploader = new FileUploader_1.default({
                            apiURL: this.apiURL,
                            logger: this.logger,
                            callback: function (_request, resultURL, error) {
                                if (error) {
                                    throw error;
                                }
                                else if (resultURL) {
                                    url = resultURL;
                                }
                            },
                        });
                        fileUploader.add('asset', {
                            type: 'ASSET',
                            contents: contents,
                        });
                        return [4 /*yield*/, fileUploader.waitForCompletion()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, url];
                }
            });
        }); };
        this.onFileUploaded = function (request, resultURL, error) {
            // When a file has been uploaded, store its url in the state. This state should be persisted
            // by the client so that the next time it doesn't need to be uploaded again.
            _this.setState(function (_a) {
                var files = _a.files;
                return ({
                    files: State.addObject(files, request.path, __assign(__assign(__assign({}, request.file), (resultURL ? { contents: resultURL } : {})), (error ? { error: error } : {}))),
                });
            });
        };
        this.onWantedDependencyVersions = function (_sdkVersion, result, error) {
            var wantedDependencyVersions = error ? {} : result;
            _this.setState(function (_a) {
                var dependencies = _a.dependencies, sdkVersion = _a.sdkVersion;
                return ({
                    wantedDependencyVersions: wantedDependencyVersions,
                    missingDependencies: DependencyResolver_1.getMissingDependencies(dependencies, sdkVersion, wantedDependencyVersions),
                });
            });
        };
        this.onDependencyResolved = function (request, result, error) {
            // When a dependency is resolved, store its handle and peer-dependencies
            // in the state. This state should be persisted by the client so that the next
            // time it doesn't need to be resolved again.
            _this.setState(function (_a) {
                var dependencies = _a.dependencies, sdkVersion = _a.sdkVersion, wantedDependencyVersions = _a.wantedDependencyVersions;
                var newDependencies = State.addObject(dependencies, request.name, __assign(__assign(__assign(__assign({}, dependencies[request.name]), { version: request.version }), (result
                    ? {
                        handle: result.handle,
                        peerDependencies: result.dependencies,
                    }
                    : {})), (error ? { error: error } : {})));
                return newDependencies !== dependencies
                    ? {
                        dependencies: newDependencies,
                        missingDependencies: DependencyResolver_1.getMissingDependencies(newDependencies, sdkVersion, wantedDependencyVersions),
                    }
                    : null;
            });
        };
        this.onDevSessionSendBeaconCloseRequest = function (sendBeaconCloseRequest) {
            _this.setState(function (_state) { return ({
                sendBeaconCloseRequest: sendBeaconCloseRequest,
            }); });
        };
        this.onTransportEvent = function (transport, event) {
            var _a, _b, _c;
            var type = event.type, data = event.data;
            // @ts-ignore
            var connectionId = event.connectionId;
            switch (type) {
                case 'connect':
                    (_a = _this.logger) === null || _a === void 0 ? void 0 : _a.comm("Client connected (" + transport + ")", connectionId);
                    _this.onClientConnected(transport, connectionId, data);
                    break;
                case 'disconnect':
                    (_b = _this.logger) === null || _b === void 0 ? void 0 : _b.comm("Client disconnected (" + transport + ")", connectionId, data);
                    _this.onClientDisconnected(transport, connectionId, data);
                    break;
                case 'protocol_message':
                    (_c = _this.logger) === null || _c === void 0 ? void 0 : _c.comm_recv("Message received (" + transport + ")", connectionId, data);
                    _this.onProtocolMessageReceived(transport, connectionId, event.data);
                    break;
                case 'send_message':
                    _this.onProtocolMessageSent(transport, event.data);
                    break;
            }
        };
        var channel = utils_1.createChannel(options.channel);
        var sdkVersion = snack_content_1.validateSDKVersion((_a = options.sdkVersion) !== null && _a !== void 0 ? _a : defaultConfig_1.default.sdkVersion);
        var dependencies = options.dependencies ? __assign({}, options.dependencies) : {};
        this.options = options;
        this.apiURL = (_b = options.apiURL) !== null && _b !== void 0 ? _b : defaultConfig_1.default.apiURL;
        this.snackpubURL = (_c = options.snackpubURL) !== null && _c !== void 0 ? _c : defaultConfig_1.default.snackpubURL;
        this.runtimeEndpoint = (_d = options.runtimeEndpoint) !== null && _d !== void 0 ? _d : snack_content_1.SNACK_RUNTIME_URL_ENDPOINT;
        this.logger = options.verbose ? Logger_1.createLogger(true) : undefined;
        this.codeChangesDelay = (_e = options.codeChangesDelay) !== null && _e !== void 0 ? _e : 0;
        this.reloadTimeout = (_f = options.reloadTimeout) !== null && _f !== void 0 ? _f : 0;
        this.previewTimeout = (_g = options.previewTimeout) !== null && _g !== void 0 ? _g : 10000;
        this.createTransport = (_h = options.createTransport) !== null && _h !== void 0 ? _h : transports_1.createTransport;
        var webPlayerURL = (_j = options.webPlayerURL) !== null && _j !== void 0 ? _j : defaultConfig_1.default.webPlayerURL;
        var transports = (_k = options.transports) !== null && _k !== void 0 ? _k : {};
        if (options.online) {
            transports = State.addObject(transports, 'pubsub', this.createTransport({
                name: 'pubsub',
                channel: channel,
                verbose: options.verbose,
                apiURL: this.apiURL,
                snackpubURL: this.snackpubURL,
            }));
        }
        if (options.webPreviewRef) {
            transports = State.addObject(transports, 'webplayer', webPlayer_1.createWebPlayerTransport({
                ref: options.webPreviewRef,
                verbose: options.verbose,
                window: nullthrows_1.default(typeof window !== 'undefined' ? window : global),
                webPlayerURL: webPlayerURL,
            }));
        }
        this.state = this.updateDerivedState({
            disabled: !!options.disabled,
            unsaved: false,
            name: (_l = options.name) !== null && _l !== void 0 ? _l : '',
            description: (_m = options.description) !== null && _m !== void 0 ? _m : '',
            sdkVersion: sdkVersion,
            files: (_o = options.files) !== null && _o !== void 0 ? _o : {},
            dependencies: dependencies,
            missingDependencies: DependencyResolver_1.getMissingDependencies(dependencies, sdkVersion),
            connectedClients: {},
            transports: transports,
            user: options.user,
            id: options.id,
            saveURL: options.id
                ? utils_1.createURL(this.runtimeEndpoint, sdkVersion, undefined, options.id)
                : undefined,
            savedSDKVersion: options.id ? sdkVersion : undefined,
            online: false,
            url: utils_1.createURL(this.runtimeEndpoint, sdkVersion, channel, options.id),
            channel: channel,
            deviceId: options.deviceId,
            snackId: options.snackId,
            accountSnackId: options.accountSnackId,
            webPlayerURL: webPlayerURL,
        }, defaultConfig_1.SnackIdentityState);
        this.state.unsaved = false;
        this.wantedDependencyVersions = new WantedVersions_1.WantedDependencyVersions({
            apiUrl: this.apiURL,
            logger: this.logger,
            callback: this.onWantedDependencyVersions,
        });
        this.dependencyResolver = new DependencyResolver_1.default({
            snackagerURL: (_p = options.snackagerURL) !== null && _p !== void 0 ? _p : defaultConfig_1.default.snackagerURL,
            logger: this.logger,
            callback: this.onDependencyResolved,
        });
        this.fileUploader = new FileUploader_1.default({
            apiURL: this.apiURL,
            logger: this.logger,
            callback: this.onFileUploaded,
        });
        this.DevSession = new DevSession_1.default({
            apiURL: this.apiURL,
            logger: this.logger,
            onSendBeaconCloseRequest: this.onDevSessionSendBeaconCloseRequest,
        });
        (_q = this.logger) === null || _q === void 0 ? void 0 : _q.info('Snack created', this.getState());
        this.onStateChanged(this.state, defaultConfig_1.SnackIdentityState);
    }
    //
    // Content
    //
    /**
     * Sets the Expo SDK version.
     * @param sdkVersion Valid SDK version (e.g. "38.0.0")
     */
    Snack.prototype.setSDKVersion = function (sdkVersion) {
        snack_content_1.validateSDKVersion(sdkVersion);
        return this.setState(function (state) {
            return state.sdkVersion !== sdkVersion
                ? {
                    sdkVersion: sdkVersion,
                    missingDependencies: DependencyResolver_1.getMissingDependencies(state.dependencies, sdkVersion, state.wantedDependencyVersions),
                }
                : null;
        });
    };
    /**
     * Sets the name of the Snack.
     * @param name E.g. "conspicious orange"
     */
    Snack.prototype.setName = function (name) {
        return this.setState(function (state) { return (state.name !== name ? { name: name } : null); });
    };
    /**
     * Sets the description of the Snack.
     * @param name E.g. "My awesome Snack"
     */
    Snack.prototype.setDescription = function (description) {
        return this.setState(function (state) { return (state.description !== description ? { description: description } : null); });
    };
    /**
     * Sets the associated user account.
     *
     * When set and `online` is true, causes this Snack to appear on the
     * "Recently in Development" section of all Expo clients that are signed
     * in with that account.
     */
    Snack.prototype.setUser = function (user) {
        return this.setState(function (state) { return (state.user !== user ? { user: user } : null); });
    };
    /**
     * Sets the device-id of an Expo client. When set and `online` is true, causes this
     * Snack to appear on the "Recently in Development" section of that Expo client.
     */
    Snack.prototype.setDeviceId = function (deviceId) {
        return this.setState(function (state) { return (state.deviceId !== deviceId ? { deviceId: deviceId } : null); });
    };
    /**
     * Sets the focus to this Snack.
     *
     * Causes this Snack to be moved to the top of the "Recently in Development" list
     * in the Expo client.
     */
    Snack.prototype.setFocus = function () {
        this.DevSession.setFocus(this.state);
    };
    /**
     * Sets the delay that is used before sending code updates to the connected clients.
     * Use this method to set the "debounce" timeout to use for sending code changes
     * over pubsub.
     *
     * ```
     *   -1 = Disable automatic sending of code changes (use `sendCodeChanges` to trigger the send)
     *    0 = Code changes are sent immediately to the connected clients
     * 1..n = Code changes are debounced and sent after the wait time
     * ```
     *
     * @param delay Timeout in milliseconds (or -1 to disable automatic code updates)
     */
    Snack.prototype.setCodeChangesDelay = function (delay) {
        if (this.codeChangesDelay !== delay) {
            this.codeChangesDelay = delay;
            this._sendCodeChangesDebounced(this.state);
        }
    };
    /**
     * Update the `webPlayerURL` which serves the webPlayer runtime.
     */
    Snack.prototype.setWebPlayerURL = function (webPlayerURL) {
        var _this = this;
        this.setState(function (state) {
            var newWebPlayerURL = webPlayerURL !== null && webPlayerURL !== void 0 ? webPlayerURL : defaultConfig_1.default.webPlayerURL;
            if (state.webPlayerURL !== newWebPlayerURL && _this.options.webPreviewRef) {
                var transports = state.transports;
                transports = State.addObject(transports, 'webplayer', webPlayer_1.createWebPlayerTransport({
                    ref: _this.options.webPreviewRef,
                    verbose: _this.options.verbose,
                    window: nullthrows_1.default(typeof window !== 'undefined' ? window : global),
                    webPlayerURL: newWebPlayerURL,
                }));
                return { webPlayerURL: newWebPlayerURL, transports: transports };
            }
            return null;
        });
    };
    /**
     * Sends any pending code changes to the connected clients.
     * No changes are send if all clients are already up to date.
     */
    Snack.prototype.sendCodeChanges = function () {
        this._sendCodeChangesDebounced(this.state, true);
    };
    Snack.prototype._sendCodeChangesDebounced = function (state, immediate) {
        var _this = this;
        // Clear the debounce timer
        if (this.codeChangesTimer) {
            clearTimeout(this.codeChangesTimer);
            this.codeChangesTimer = undefined;
        }
        // Schedule debounced update
        if (!immediate && this.codeChangesDelay > 0) {
            this.codeChangesTimer = setTimeout(function () { return _this._sendCodeChangesDebounced(state, true); }, this.codeChangesDelay);
            return;
        }
        else if (!immediate && this.codeChangesDelay < 0) {
            return;
        }
        // Send the changes
        var transports = state.transports, files = state.files, dependencies = state.dependencies, sdkVersion = state.sdkVersion;
        for (var key in transports) {
            transports[key].postMessage({
                type: 'update_code',
                data: {
                    files: files,
                    dependencies: dependencies,
                    sdkVersion: sdkVersion,
                },
            });
        }
    };
    //
    // Save
    //
    /**
     * Uploads the current code to Expo's servers and return a url that points to that version of the code.
     */
    Snack.prototype.saveAsync = function (options) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function () {
            var prevState, _g, name, description, sdkVersion, files, dependencies, user, payload, previewPromise, url, response, data, id_1, saveURL_1, hashId, accountSnackId_1, snackId_1, e_1;
            var _this = this;
            return __generator(this, function (_h) {
                switch (_h.label) {
                    case 0:
                        prevState = this.state;
                        // Wait for any pending asset uploads the complete before saving
                        return [4 /*yield*/, this.fileUploader.waitForCompletion()];
                    case 1:
                        // Wait for any pending asset uploads the complete before saving
                        _h.sent();
                        _g = this.state, name = _g.name, description = _g.description, sdkVersion = _g.sdkVersion, files = _g.files, dependencies = _g.dependencies, user = _g.user;
                        _h.label = 2;
                    case 2:
                        _h.trys.push([2, 5, , 6]);
                        payload = {
                            manifest: {
                                sdkVersion: sdkVersion,
                                name: name,
                                description: description,
                                dependencies: mapValues_1.default(dependencies, function (dep) { return dep.version; }),
                            },
                            code: mapValues_1.default(files, function (file) {
                                file = __assign({}, file);
                                delete file.error;
                                return file;
                            }),
                            dependencies: mapValues_1.default(dependencies, function (dep) {
                                dep = __assign({}, dep);
                                delete dep.error;
                                return dep;
                            }),
                            isDraft: (_a = options === null || options === void 0 ? void 0 : options.isDraft) !== null && _a !== void 0 ? _a : false,
                        };
                        (_b = this.logger) === null || _b === void 0 ? void 0 : _b.info('Saving...', payload);
                        previewPromise = this.getPreviewAsync();
                        url = this.apiURL + "/--/api/v2/snack/save";
                        return [4 /*yield*/, utils_1.fetch(url, {
                                method: 'POST',
                                body: JSON.stringify(payload),
                                headers: __assign({ 'Content-Type': 'application/json' }, ((options === null || options === void 0 ? void 0 : options.ignoreUser) ? {} : utils_1.createUserHeader(user))),
                            })];
                    case 3:
                        response = _h.sent();
                        return [4 /*yield*/, response.json()];
                    case 4:
                        data = _h.sent();
                        if (!(data === null || data === void 0 ? void 0 : data.id)) {
                            throw new Error(((_d = (_c = data.errors) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.message) || 'Failed to save');
                        }
                        (_e = this.logger) === null || _e === void 0 ? void 0 : _e.info('Saved', data);
                        id_1 = data.id;
                        saveURL_1 = utils_1.createURL(this.runtimeEndpoint, sdkVersion, undefined, id_1);
                        hashId = data.hashId;
                        accountSnackId_1 = data.accountSnackId;
                        snackId_1 = data.snackId;
                        this.setState(function (state) { return ({
                            id: id_1,
                            saveURL: saveURL_1,
                            unsaved: State.isUnsaved(state, prevState),
                            savedSDKVersion: (options === null || options === void 0 ? void 0 : options.isDraft) && state.savedSDKVersion ? state.savedSDKVersion : sdkVersion,
                            accountSnackId: accountSnackId_1,
                            snackId: snackId_1,
                        }); });
                        previewPromise.then(function (connectedClients) {
                            var conns = Object.values(connectedClients)
                                .filter(function (c) { return c.previewURL; })
                                .sort(function (a, b) { var _a, _b; return ((_a = a.previewTimestamp) !== null && _a !== void 0 ? _a : 0) - ((_b = b.previewTimestamp) !== null && _b !== void 0 ? _b : 0); });
                            if (conns.length) {
                                _this.uploadPreview(id_1, conns[0].previewURL, conns[0].status !== 'error');
                            }
                        });
                        return [2 /*return*/, {
                                id: id_1,
                                url: saveURL_1,
                                hashId: hashId,
                                accountSnackId: accountSnackId_1,
                                snackId: snackId_1,
                            }];
                    case 5:
                        e_1 = _h.sent();
                        (_f = this.logger) === null || _f === void 0 ? void 0 : _f.error(e_1);
                        throw e_1;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Gets the URL at which the Snack can be downloaded as a zip file. Will automatically
     * save the Snack if it contains unsaved changes.
     */
    Snack.prototype.getDownloadURLAsync = function (saveOptions) {
        return __awaiter(this, void 0, void 0, function () {
            var state;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.fileUploader.waitForCompletion()];
                    case 1:
                        _a.sent();
                        state = this.getState();
                        if (!(!state.id || state.unsaved)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.saveAsync(saveOptions)];
                    case 2:
                        _a.sent();
                        state = this.getState();
                        _a.label = 3;
                    case 3: return [2 /*return*/, this.apiURL + "/--/api/v2/snack/download/" + state.id];
                }
            });
        });
    };
    Snack.prototype.uploadPreview = function (id, previewURL, status) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function () {
            var url, payload, response, data, e_2;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        url = this.apiURL + "/--/api/v2/snack/updateMetadata";
                        payload = {
                            id: id,
                            previewLocation: previewURL,
                            status: status ? 'SUCCESS' : 'FAILURE',
                        };
                        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info('Uploading preview...', payload);
                        _g.label = 1;
                    case 1:
                        _g.trys.push([1, 4, , 5]);
                        return [4 /*yield*/, utils_1.fetch(url, {
                                method: 'POST',
                                body: JSON.stringify(payload),
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                            })];
                    case 2:
                        response = _g.sent();
                        return [4 /*yield*/, response.json()];
                    case 3:
                        data = _g.sent();
                        if (data.id) {
                            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.info('Uploaded preview', data);
                        }
                        else {
                            throw new Error((_e = (_d = (_c = data.errors) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.message) !== null && _e !== void 0 ? _e : 'Unknown error');
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        e_2 = _g.sent();
                        (_f = this.logger) === null || _f === void 0 ? void 0 : _f.error('Failed to upload preview', e_2);
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    //
    // State
    //
    /**
     * Returns the current state of the Snack. This includes files, dependencies
     * and other meta-data about the Snack.
     */
    Snack.prototype.getState = function () {
        return this.state;
    };
    /**
     * Waits for any pending operations such as running dependencies resolutions
     * before returning the state.
     */
    Snack.prototype.getStateAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.wantedDependencyVersions.waitForCompletion()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.dependencyResolver.waitForCompletion()];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, this.fileUploader.waitForCompletion()];
                    case 3:
                        _a.sent();
                        return [2 /*return*/, this.getState()];
                }
            });
        });
    };
    /**
     * Adds a callback for listening for any state changes.
     *
     * @example
     * ```
     * const unsubscribe = Snack.addStateListener((state, prevState) => {
     *   if (state.name !== prevState.name) {
     *     console.log('name changed: ', state.name);
     *   }
     * });
     *
     * Snack.setName('unforgiven orange'); // // Make a change to the state
     *
     * unsubscribe(); // Remove listener
     * ```
     */
    Snack.prototype.addStateListener = function (listener) {
        var _this = this;
        this.stateListeners.add(listener);
        return function () { return _this.stateListeners.delete(listener); };
    };
    Snack.prototype.setState = function (stateFn) {
        var update = stateFn(this.state);
        if (update) {
            var oldState_1 = this.state;
            var newState_1 = __assign(__assign({}, oldState_1), update);
            this.state = this.updateDerivedState(newState_1, oldState_1);
            this.onStateChanged(newState_1, oldState_1);
            this.stateListeners.forEach(function (listener) { return listener(newState_1, oldState_1); });
        }
    };
    Snack.prototype.updateDerivedState = function (state, prevState) {
        // Set unsaved to true whenever files or dependencies change
        state.unsaved = state.unsaved || State.isUnsaved(state, prevState);
        // Update other derived states
        this.updateDerivedOnlineState(state, prevState);
        this.updateDerivedDependenciesState(state, prevState);
        this.updateDerivedWebPreviewState(state, prevState);
        return state;
    };
    Snack.prototype.onStateChanged = function (state, prevState) {
        this.updateWantedDependencyVersions(state, prevState);
        this.updateDependencyResolver(state, prevState);
        this.updateFileUploader(state, prevState);
        this.updateTransports(state, prevState);
        this.DevSession.setState(state, prevState);
    };
    //
    // Files (code & assets)
    //
    /**
     * Updates code or asset files.
     *
     * Use this method to add/remove/update files and upload assets.
     * To remove a file specify `null` as the value of the file.
     *
     * @example
     * ```ts
     * const Snack = new Snack({
     *   files: {
     *     'App.js': { type: 'CODE', contents: 'console.log("hello world!");' },
     *     'data.json': { type: 'CODE', contents: '{}' },
     *   }
     * });
     *
     * // Add or update files
     * Snack.updateFiles({
     *   'App.js': {
     *     type: 'CODE',
     *     contents: 'console.log("Hello Snack!");'
     *   }
     * });
     *
     * // Upload an asset
     * Snack.updateFiles({
     *   'assets/logo.png': {
     *     type: 'ASSET',
     *     contents: file // File, Blob or FormData
     *   }
     * });
     *
     * // Add a pre-uploaded asset
     * Snack.updateFiles({
     *   'assets/expo.jpg': {
     *     type: 'ASSET',
     *     contents: 'https://mysite/expo.jpg'
     *   }
     * });
     *
     * // Remove files
     * Snack.updateFiles({
     *   'data.json': null,
     *   'assets/expo.jpg': null
     * });
     * ```
     */
    Snack.prototype.updateFiles = function (files) {
        return this.setState(function (state) {
            var newFiles = State.updateObjects(state.files, files);
            return newFiles !== state.files ? { files: newFiles } : null;
        });
    };
    Snack.prototype.updateFileUploader = function (state, prevState) {
        var _a;
        var files = state.files;
        var prevFiles = prevState.files;
        // Stop uploading any removed or changed assets
        if (!prevState.disabled && ((!state.disabled && files !== prevFiles) || state.disabled)) {
            for (var path in prevFiles) {
                if (!files[path] || files[path].contents !== prevFiles[path].contents || state.disabled) {
                    this.fileUploader.remove(path, prevFiles[path]);
                }
            }
        }
        // Start uploading any new or changed assets, or when the error is cleared
        if (!state.disabled && (files !== prevFiles || prevState.disabled)) {
            for (var path in files) {
                var file = files[path];
                if (file.type === 'ASSET' &&
                    typeof file.contents === 'object' &&
                    !file.error &&
                    (((_a = prevFiles[path]) === null || _a === void 0 ? void 0 : _a.contents) !== file.contents || prevState.disabled)) {
                    this.fileUploader.add(path, file);
                }
            }
        }
    };
    //
    // Dependencies
    //
    /**
     * Updates dependencies.
     *
     * Use this method to add/remove/update dependencies.
     * To remove a dependency specify `null` as the value of the key/value pair.
     *
     * @example
     * ```ts
     * const Snack = new Snack({
     *   dependencies: {
     *     'react-native-paper': '~2.0.0'
     *   }
     * });
     *
     * // Add dependency
     * Snack.updateDependencies({
     *   'expo-font': '9.0.0'
     * });
     *
     * // Remove dependency
     * Snack.updateDependencies({
     *   'expo-font': null
     * });
     * ```
     */
    Snack.prototype.updateDependencies = function (dependencies) {
        return this.setState(function (state) {
            var newDependencies = State.updateObjects(state.dependencies, dependencies);
            return newDependencies !== state.dependencies
                ? {
                    dependencies: newDependencies,
                    missingDependencies: DependencyResolver_1.getMissingDependencies(newDependencies, state.sdkVersion, state.wantedDependencyVersions),
                }
                : null;
        });
    };
    Snack.prototype.updateDerivedDependenciesState = function (state, prevState) {
        var _a, _b, _c, _d;
        if (state.wantedDependencyVersions !== prevState.wantedDependencyVersions ||
            state.dependencies !== prevState.dependencies) {
            for (var name_1 in state.dependencies) {
                var dep = state.dependencies[name_1];
                var wantedVersion = (_d = (_b = (_a = state.wantedDependencyVersions) === null || _a === void 0 ? void 0 : _a[name_1]) !== null && _b !== void 0 ? _b : (_c = state.wantedDependencyVersions) === null || _c === void 0 ? void 0 : _c[DependencyResolver_1.getPackageName(name_1)]) !== null && _d !== void 0 ? _d : undefined;
                if (dep.wantedVersion !== wantedVersion) {
                    state.dependencies =
                        state.dependencies === prevState.dependencies
                            ? __assign({}, state.dependencies) : state.dependencies;
                    var version = (dep.version === '*' || (dep.wantedVersion && dep.version === dep.wantedVersion)) &&
                        wantedVersion
                        ? wantedVersion
                        : dep.version;
                    state.dependencies[name_1] = __assign(__assign({}, dep), { version: version,
                        wantedVersion: wantedVersion });
                    if (dep.handle && dep.version !== version) {
                        delete state.dependencies[name_1].handle;
                    }
                }
            }
        }
        if (state.dependencies !== prevState.dependencies) {
            for (var name_2 in state.dependencies) {
                var dep = state.dependencies[name_2];
                if (dep !== prevState.dependencies[name_2]) {
                    var error = DependencyResolver_1.verifyDependency(name_2, dep.version);
                    if (error) {
                        state.dependencies[name_2] = __assign(__assign({}, dep), { error: error });
                    }
                }
            }
        }
    };
    Snack.prototype.updateWantedDependencyVersions = function (state, _prevState) {
        if (!state.disabled && Object.keys(state.dependencies).length) {
            this.wantedDependencyVersions.setSDKVersion(state.sdkVersion);
        }
    };
    Snack.prototype.updateDependencyResolver = function (state, prevState) {
        var _a, _b, _c;
        var dependencies = state.dependencies;
        var prevDependencies = prevState.dependencies;
        // Stop resolving any removed or changed dependencies
        if (!prevState.disabled &&
            (dependencies !== prevDependencies ||
                state.disabled ||
                state.sdkVersion !== prevState.sdkVersion)) {
            for (var name_3 in prevDependencies) {
                if (!dependencies[name_3] ||
                    dependencies[name_3].version !== prevDependencies[name_3].version ||
                    state.disabled ||
                    (snack_content_1.isModulePreloaded(name_3, state.sdkVersion) &&
                        !snack_content_1.isModulePreloaded(name_3, prevState.sdkVersion))) {
                    this.dependencyResolver.remove(name_3, prevDependencies[name_3].version, prevState.sdkVersion);
                }
            }
        }
        // Add any still unresolved dependencies to the dependency resolver
        if (!state.disabled &&
            (dependencies !== prevDependencies ||
                prevState.disabled ||
                state.sdkVersion !== prevState.sdkVersion ||
                state.wantedDependencyVersions !== prevState.wantedDependencyVersions)) {
            for (var name_4 in dependencies) {
                var dependency = dependencies[name_4];
                if (!dependency.handle &&
                    !dependency.error &&
                    !snack_content_1.isModulePreloaded(name_4, state.sdkVersion) &&
                    !(dependency.version === '*' && !state.wantedDependencyVersions) &&
                    (((_a = prevDependencies[name_4]) === null || _a === void 0 ? void 0 : _a.version) !== dependency.version ||
                        (dependency.version === '*' && !prevState.wantedDependencyVersions) || ((_b = prevDependencies[name_4]) === null || _b === void 0 ? void 0 : _b.handle) || ((_c = prevDependencies[name_4]) === null || _c === void 0 ? void 0 : _c.error) ||
                        prevState.disabled)) {
                    this.dependencyResolver.add(name_4, dependency.version, state.sdkVersion);
                }
            }
        }
    };
    //
    // Online
    //
    /**
     * Enables or disables the Snack.
     *
     * When disabled, no uploads or dependency resolve operations
     * are performed.
     */
    Snack.prototype.setDisabled = function (disabled) {
        return this.setState(function (state) { return (disabled !== state.disabled ? { disabled: disabled } : null); });
    };
    /**
     * Makes the Snack available online.
     *
     * When online, a pubsub channel is created to which clients can
     * connect.
     */
    Snack.prototype.setOnline = function (enabled) {
        var _this = this;
        return this.setState(function (state) {
            if (enabled && !state.transports['pubsub']) {
                return {
                    transports: State.addObject(state.transports, 'pubsub', _this.createTransport({
                        name: 'pubsub',
                        apiURL: _this.apiURL,
                        snackpubURL: _this.snackpubURL,
                        channel: state.channel,
                        verbose: !!_this.logger,
                    })),
                };
            }
            else if (!enabled && state.transports['pubsub']) {
                var connectedClients = state.connectedClients;
                for (var key in state.connectedClients) {
                    if (state.connectedClients[key].transport === 'pubsub') {
                        connectedClients = State.removeObject(connectedClients, key);
                    }
                }
                return {
                    transports: State.removeObject(state.transports, 'pubsub'),
                    connectedClients: connectedClients,
                };
            }
            else {
                return null;
            }
        });
    };
    Snack.prototype.updateDerivedOnlineState = function (state, prevState) {
        var transports = state.transports, sdkVersion = state.sdkVersion, channel = state.channel, id = state.id, name = state.name, disabled = state.disabled, savedSDKVersion = state.savedSDKVersion;
        if (transports !== prevState.transports ||
            sdkVersion !== prevState.sdkVersion ||
            channel !== prevState.channel ||
            id !== prevState.id ||
            name !== prevState.name ||
            savedSDKVersion !== prevState.savedSDKVersion) {
            state.online = !!transports['pubsub'] && !disabled;
            state.url = utils_1.createURL(this.runtimeEndpoint, sdkVersion, channel, savedSDKVersion && savedSDKVersion !== sdkVersion ? undefined : id);
            state.onlineName = "" + (name || 'Unnamed Snack');
        }
    };
    Snack.prototype.updateDerivedWebPreviewState = function (state, prevState) {
        var transports = state.transports, sdkVersion = state.sdkVersion, url = state.url, webPlayerURL = state.webPlayerURL;
        if ((url && !prevState.url) ||
            sdkVersion !== prevState.sdkVersion ||
            webPlayerURL !== prevState.webPlayerURL) {
            state.webPreviewURL =
                transports['webplayer'] && webPlayerURL
                    ? webPlayer_1.getWebPlayerIFrameURL(webPlayerURL, sdkVersion, url, !!this.logger)
                    : undefined;
        }
    };
    //
    // Transports
    //
    /**
     * Reloads all connected clients.
     *
     * Note: During the reload proces, clients may get disconnected which
     * causes the connectedClient to disappear and re-appear. The `reloadTimeout`
     * option in the constructor can be used to keep connectedClients "alive"
     * during the reload process.
     */
    Snack.prototype.reloadConnectedClients = function () {
        var _a;
        var connectedTransports = new Set();
        this.setState(function (state) {
            var connectedClients = state.connectedClients;
            for (var key in state.connectedClients) {
                var connectedClient = state.connectedClients[key];
                connectedTransports.add(state.transports[connectedClient.transport]);
                connectedClients = State.addObject(connectedClients, key, __assign(__assign({}, connectedClient), { status: 'reloading' }));
            }
            return connectedClients !== state.connectedClients ? { connectedClients: connectedClients } : null;
        });
        var reloadMessage = {
            type: 'RELOAD_SNACK',
        };
        if (connectedTransports.size) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.comm('Reloading...');
            connectedTransports.forEach(function (transport) {
                transport.postMessage({
                    type: 'protocol_message',
                    data: reloadMessage,
                });
            });
        }
    };
    /**
     * Requests a preview from the connected clients.
     *
     * The previews are returned in the `previewURL` field of each connectedClient.
     */
    Snack.prototype.getPreviewAsync = function () {
        var _this = this;
        var _a;
        var _b = this.state, connectedClients = _b.connectedClients, transports = _b.transports;
        var connectedTransports = new Set();
        Object.values(connectedClients).forEach(function (_a) {
            var transport = _a.transport;
            return connectedTransports.add(transports[transport]);
        });
        if (!connectedTransports.size) {
            return Promise.resolve(connectedClients);
        }
        // Send status request to all transports that have
        // active connectedClients.
        var requestStatusMessage = {
            type: 'REQUEST_STATUS',
        };
        if (connectedTransports.size) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.comm('Requesting preview...');
            connectedTransports.forEach(function (transport) {
                transport.postMessage({
                    type: 'protocol_message',
                    data: requestStatusMessage,
                });
            });
        }
        // Wait for all status-reports to be received and
        // return the connectedClients state when done.
        // Or timeout when it takes too long...
        return new Promise(function (resolve, reject) {
            var timeoutTimer;
            var completedConnections = new Set();
            var unsubscribe = _this.addStateListener(function (state, prevState) {
                var _a;
                if (state.connectedClients !== prevState.connectedClients) {
                    for (var key in connectedClients) {
                        if (connectedClients[key].previewTimestamp !== ((_a = state.connectedClients[key]) === null || _a === void 0 ? void 0 : _a.previewTimestamp) ||
                            !state.connectedClients[key]) {
                            completedConnections.add(key);
                            if (completedConnections.size === Object.values(connectedClients).length) {
                                unsubscribe();
                                clearTimeout(timeoutTimer);
                                resolve(state.connectedClients);
                                return;
                            }
                        }
                    }
                }
            });
            timeoutTimer = setTimeout(function () {
                unsubscribe();
                reject(new Error('Operation timed out'));
            }, _this.previewTimeout);
        });
    };
    Snack.prototype.updateTransports = function (state, prevState) {
        var _this = this;
        var transports = state.transports;
        var prevTransports = prevState.transports;
        // Stop any any removed transports
        if (!prevState.disabled && (transports !== prevTransports || state.disabled)) {
            for (var id in prevTransports) {
                if (this.transportListeners[id] &&
                    (transports[id] !== prevTransports[id] || state.disabled)) {
                    prevTransports[id].removeEventListener('message', this.transportListeners[id]);
                    delete this.transportListeners[id];
                    prevTransports[id].postMessage({ type: 'stop' });
                }
            }
        }
        // Start any added transports
        if (!state.disabled && (transports !== prevTransports || prevState.disabled)) {
            var _loop_1 = function (id) {
                if (!this_1.transportListeners[id] &&
                    (transports[id] !== prevTransports[id] || prevState.disabled)) {
                    this_1.transportListeners[id] = function (event) { return _this.onTransportEvent(id, event); };
                    transports[id].addEventListener('message', this_1.transportListeners[id]);
                    transports[id].postMessage({ type: 'start' });
                }
            };
            var this_1 = this;
            for (var id in transports) {
                _loop_1(id);
            }
        }
        // Update the code
        if (!state.disabled &&
            !State.isBusy(state) &&
            (transports !== prevTransports || State.isCodeChanged(state, prevState) || prevState.disabled)) {
            this._sendCodeChangesDebounced(state, prevTransports !== transports || (!State.isBusy(state) && State.isBusy(prevState)));
        }
    };
    Snack.prototype.onClientConnected = function (transport, connectedClientId, data) {
        this.setState(function (state) {
            return {
                connectedClients: State.addObject(state.connectedClients, connectedClientId, {
                    transport: transport,
                    id: data.id,
                    name: data.name,
                    platform: data.platform,
                    status: 'ok',
                }),
            };
        });
    };
    Snack.prototype.onClientDisconnected = function (_transport, connectedClientId, _data) {
        var _this = this;
        this.setState(function (state) {
            var connectedClient = state.connectedClients[connectedClientId];
            // When the connectedClient is reloading, schedule a cleanup
            // in case the connectedClient does not return
            if ((connectedClient === null || connectedClient === void 0 ? void 0 : connectedClient.status) === 'reloading' && _this.reloadTimeout >= 0) {
                if (_this.pruneConnectionsTimer) {
                    clearTimeout(_this.pruneConnectionsTimer);
                    _this.pruneConnectionsTimer = undefined;
                }
                _this.pruneConnectionsTimer = setTimeout(function () {
                    _this.pruneConnectionsTimer = undefined;
                    _this.setState(function (state) {
                        var connectedClients = state.connectedClients;
                        for (var key in state.connectedClients) {
                            if (state.connectedClients[key].status === 'reloading') {
                                connectedClients = State.removeObject(connectedClients, key);
                            }
                        }
                        return connectedClients !== state.connectedClients ? { connectedClients: connectedClients } : null;
                    });
                }, _this.reloadTimeout);
                return null;
            }
            else {
                // Otherwise, remove the connectedClient immediately
                var connectedClients = State.removeObject(state.connectedClients, connectedClientId);
                return connectedClients !== state.connectedClients ? { connectedClients: connectedClients } : null;
            }
        });
    };
    //
    // Messaging
    //
    /**
     * Adds a callback for listening for any client generated log messages.
     *
     * @example
     * ```
     * const unsubscribe = Snack.addLogListener((log) => {
     *   console.log('log message received: ', log);
     * });
     *
     * unsubscribe(); // Remove listener
     * ```
     */
    Snack.prototype.addLogListener = function (listener) {
        var _this = this;
        this.logListeners.add(listener);
        return function () { return _this.logListeners.delete(listener); };
    };
    Snack.prototype.onProtocolMessageReceived = function (transport, connectedClientId, message) {
        var _a;
        // Ignore messages from clients that are not setup yet or have disconnected
        if (!this.state.connectedClients[connectedClientId]) {
            return;
        }
        switch (message.type) {
            case 'CONSOLE':
                this.onConsoleMessageReceived(connectedClientId, message);
                break;
            case 'ERROR':
                this.onErrorMessageReceived(connectedClientId, message);
                break;
            case 'STATUS_REPORT':
                this.onStatusReportMessageReceived(connectedClientId, message);
                break;
            // @ts-ignore: CODE is echoed by pubsub, we ignore it
            case 'CODE':
                break;
            // @ts-ignore: RELOAD_SNACK is echoed by pubsub, we ignore it
            case 'RELOAD_SNACK':
                break;
            // @ts-ignore: REQUEST_STATUS is echoed by pubsub, we ignore it
            case 'REQUEST_STATUS':
                break;
            default:
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error('Invalid message received', transport, message);
                break;
        }
    };
    Snack.prototype.onProtocolMessageSent = function (transport, message) {
        switch (message.type) {
            case 'CODE':
                this.setState(function (state) {
                    var connectedClients = state.connectedClients;
                    for (var connectedClientId in connectedClients) {
                        var connectedClient = connectedClients[connectedClientId];
                        if (connectedClient.transport === transport) {
                            connectedClients = State.addObject(connectedClients, connectedClientId, __assign(__assign({}, connectedClient), { error: undefined, status: connectedClient.status === 'error' ? 'ok' : connectedClient.status }));
                        }
                    }
                    return connectedClients !== state.connectedClients ? { connectedClients: connectedClients } : null;
                });
                break;
        }
    };
    Snack.prototype.onConsoleMessageReceived = function (connectedClientId, message) {
        var payload = message.payload || [];
        var event = {
            type: message.method,
            connectedClient: this.state.connectedClients[connectedClientId],
            message: payload.join(' '),
        };
        this.logListeners.forEach(function (listener) { return listener(event); });
    };
    Snack.prototype.onErrorMessageReceived = function (connectedClientId, message) {
        var _a, _b, _c;
        try {
            var json = JSON.parse(message.error);
            var error_1 = utils_1.createError({
                name: json.name || 'Error',
                message: json.message || '',
                fileName: json.fileName,
                lineNumber: json.lineNumber || ((_a = json.loc) === null || _a === void 0 ? void 0 : _a.line) || json.line,
                columnNumber: json.columnNumber || ((_b = json.loc) === null || _b === void 0 ? void 0 : _b.column) || json.column,
                stack: json.stack,
            });
            this.setState(function (state) { return ({
                connectedClients: State.addObject(state.connectedClients, connectedClientId, __assign(__assign({}, state.connectedClients[connectedClientId]), { error: error_1, status: 'error' })),
            }); });
        }
        catch (_d) {
            (_c = this.logger) === null || _c === void 0 ? void 0 : _c.error('Failed to parse received error message', message);
        }
    };
    Snack.prototype.onStatusReportMessageReceived = function (connectedClientId, message) {
        var previewLocation = message.previewLocation;
        this.setState(function (state) { return ({
            connectedClients: State.addObject(state.connectedClients, connectedClientId, __assign(__assign({}, state.connectedClients[connectedClientId]), { previewURL: previewLocation, previewTimestamp: Date.now() })),
        }); });
    };
    return Snack;
}());
exports.default = Snack;
//# sourceMappingURL=Session.js.map